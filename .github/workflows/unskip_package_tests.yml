name: "Unskip package tests if task is done"
on:
  workflow_dispatch:
    inputs:
      packages:
        description: 'Packages separated by spaces'
        required: true
        type: string
#  schedule:
#    - cron: '0 * * * *'

jobs:
  check_skipped_tests:
    name: Get packages with skipped tests
    runs-on: ubuntu-22.04
    outputs:
      deleted_skip_reason_packages: ${{ steps.deleted_skipReason_packages.outputs.deleted_skip_reason_packages}}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
          token: ${{ secrets.WRITE_TOKEN }}
      - name: Get packages with tests
        id: packages_with_tests
        run: |
          PACKAGES_TEST=''
          PACKAGES=${ls -la | grep '^d' | awk '{print $9}'}
          for package in $PACKAGES; do
            if [ -d "$package/src/tests" ] && grep -rq "skipReason: 'GROK-.*: .*'" "$package/src/tests"; then
                PACKAGES_TEST+= "$package"
            fi
          done
          echo "Jira_skipReason_packages=$PACKAGES_TEST" >> $GITHUB_OUTPUT
        working-directory: packages
      - name: Get packages with deleted skipReason in tests
        id: deleted_skipReason_packages
        run: |
          apt update && apt install -y curl
          deleted_skip_reason_packages=''
          for package in ${{ steps.test-package.outcome.Jira_skipReason_packages }}; do
            files=($(grep -ro "skipReason: 'GROK-.*: .*'" "$package/src/tests" | awk -F: '{print $1}'))
            issues=($(grep -ro "skipReason: 'GROK-.*: .*'" "$package/src/tests" | awk -F: '{print $3}'))
            for ((i=0; i<${#files[@]}; i++)); do
              file=${files[$i]}
              issue=$(echo "${issues[$i]}" | cut -c2-)
              if [[ $(curl -u ${{ secrets.JIRA_LOGIN }}:${{ secrets.JIRA_TOKEN }} -X GET -H "Content-Type: application/json" https://reddata.atlassian.net/rest/api/2/issue/$issue?fields=status | jq -r '.fields.status.name') == "Done" ]] || [[ $(curl -u ${{ secrets.JIRA_LOGIN }}:${{ secrets.JIRA_TOKEN }} -X GET -H "Content-Type: application/json" https://reddata.atlassian.net/rest/api/2/issue/$issue?fields=status | jq -r '.fields.status.name') == "Won't fix" ]]; then
                 skipreasons=()
                 while IFS= read -r line; do
                     skipreasons+=("$line")
                 done < <(grep -ro "skipReason: 'GROK-.*: .*'" "$package/src/tests/$file")
                 for reason in "${skipreasons[@]}"; do
                     sed -i "s/{\$reason}//" "$package/src/tests/$file"
                     echo deleted skipReason $reason in package $package in test-file $file
                 done
                 deleted_skip_reason_packages+=$package
              fi
            done
          done
          echo "deleted_skip_reason_packages=$deleted_skip_reason_packages" >> $GITHUB_OUTPUT
        working-directory: packages
      - name: Commit changes
        id: commit_unskip
        if: steps.deleted_skipReason_packages.outputs.deleted_skip_reason_packages != ''
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          git commit -m "GitHub Actions: Unskip tests for packages ${{ steps.deleted_skipReason_packages.outputs.deleted_skip_reason_packages }}

          Workflow ${{ github.workflow }} ${{ github.run_number }}
          https://github.com/datagrok-ai/public/actions/runs/${{ github.run_id }}"
        working-directory: packages
  matrix:
    name: Transform packages to matrix
    runs-on: ubuntu-22.04
    needs: check_skipped_tests
    if: needs.check_skipped_tests.outputs.deleted_skip_reason_packages != ''
    outputs:
      matrix_publish: ${{ steps.generate-matrix.outputs.matrix_publish }}
    steps:
      - name: Generate matrix
        id: generate-matrix
        run: |
          MATRIX_PUBLISH_JSON="["
          for PACKAGE in $(echo ${{ needs.check_skipped_tests.outputs.deleted_skip_reason_packages }} | sort -u); do
            DIR="packages/${PACKAGE}"
            if [ -f "${DIR}/package.json" ]; then
              MATRIX_PUBLISH_JSON+="{\"package\": \"${PACKAGE}\""
              current_version="$(jq -r '.version' "${DIR}/package.json")"
              MATRIX_PUBLISH_JSON+=", \"version\": \"${current_version}\""
              author="$(jq -r '.author.email' "${DIR}/package.json")"
              MATRIX_PUBLISH_JSON+=", \"author\": \"${author}\""
              dependencies="$(jq '(. | select( has("dependencies") == true ).dependencies) * (. | select( has("devDependencies") == true ).devDependencies)' "${DIR}/package.json")"
              unpublished_deps="$(jq -r '. | to_entries | map(select(.value | match("\\.\\./.*")))[] | "\(.key)=\(.value)"' <<<$dependencies | tr '\n' ' ')"
              MATRIX_PUBLISH_JSON+=", \"unpublished_deps\": \"$unpublished_deps\""
              MATRIX_PUBLISH_JSON+="}"
            fi
          done
          MATRIX_PUBLISH_JSON="${MATRIX_PUBLISH_JSON//\}\{/\}, \{}"
          MATRIX_PUBLISH_JSON+="]"
          PUBLISH_JSON="{\"include\": ${MATRIX_PUBLISH_JSON}}"
          echo "matrix_publish=${PUBLISH_JSON}" >> $GITHUB_OUTPUT
  test_packages:
    name: Testing packages with uskipped tests 
    runs-on: ubuntu-22.04
    needs: 
      - check_skipped_tests
      - matrix
    if: needs.check_skipped_tests.outputs.deleted_skip_reason_packages
    env:
      HOST: GitHubAction
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.matrix_publish) }}
    steps:
      - name: Run datagrok stand
        id: datagrok-image
        run: |
          echo "Find grok dependencies packages"
          grok_deps="$(jq  -r '. | select( has("devDependencies") == true ).devDependencies | to_entries[] | .key | select(test("@datagrok/.*")?)' packages/${{ matrix.package }}/package.json)"
          profiles='--profile datagrok --profile db --profile grok_connect'
          echo "Check if CVM is required for the package"
          if [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "chem" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "simpkpd" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "dendrogram" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "cvmtests" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"chem"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"simpkpd"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"cvmtests"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"dendrogram"* ]]; then
            echo "Add Scripting as dependency for package ${{ matrix.package }}"
            profiles+=' --profile scripting'
          fi
          if [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "chem" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"chem"* ]]; then
            echo "Add Grok Compute as dependency for package ${{ matrix.package }}"
            profiles+=' --profile grok_compute'
          fi
          echo "Check if Grok Spawner is required for the package"
          if [ -d "packages/${{ matrix.package }}/dockerfiles" ]; then
            profiles+=' --profile grok_spawner'
          fi
          echo "Run datagrok stand with profiles ${profiles}"
          docker system prune -af --volumes
          if [[ "${{ matrix.unpublished_deps }}" == "" ]] && [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" != "chem" ]] && [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" != "bio" ]] && [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" != "peptides" ]]; then
            DATAGROK_VERSION='latest'
          else
            DATAGROK_VERSION='bleeding-edge'
          fi
          export DATAGROK_VERSION
          docker compose -p datagrok -f "docker/localhost.docker-compose.yaml" ${profiles} up -d
          echo "Set docker_sha"
          docker_sha=$(docker images --quiet "datagrok/datagrok:$DATAGROK_VERSION")
          echo "docker_sha=$docker_sha" >> $GITHUB_OUTPUT
          echo "Notify about version used for tests"
          echo "::notice title=${{ matrix.package }}::datagrok/datagrok:$DATAGROK_VERSION SHA=$docker_sha docker version was used for tests"
          df -h
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          registry-url: 'https://registry.npmjs.org'
          scope: '@datagrok'
      - name: Upgrade npm
        run: npm install -g npm@x
      - name: npm version
        run: npm version
      - name: Do npm install for packages
        run: npm install
        id: install
        working-directory: packages/${{ matrix.package }}
      - name: js api dependency for unpublished dependencies
        if: ${{ matrix.unpublished_deps != '' }}
        run: npm install
        working-directory: ./js-api
      - name: install unpublished dependencies
        if: ${{ matrix.unpublished_deps != '' }}
        run: |
          crnt=$(pwd)
          for dep in $(echo -e ${{ matrix.unpublished_deps }}); do
            cd $(awk -F'=' '{print $2}' <<<$dep)
            echo "Install dependencies for $(awk -F'=' '{print $2}' <<<$dep)"
            npm install
            cd $crnt
          done
        working-directory: packages/${{ matrix.package }}
      - name: webpack cache
        uses: actions/cache@v3
        with:
          path: packages/${{ matrix.package }}/node_modules/.cache/webpack/
          key: ${{ matrix.package }}-${{ github.ref_name }}-webpack-build
          restore-keys: |
            ${{ matrix.package }}-master-webpack-build
      - name: Build package
        id: build
        run: npm run build
        working-directory: packages/${{ matrix.package }}
      - name: Install datagrok tools
        id: datagrok-tools
        run: npm install -g datagrok-tools@latest
      - name: Wait for Datagrok to become available
        timeout-minutes: 5
        run: |
          until .github/scripts/check-output.sh "curl -s http://127.0.0.1:8080/api/info/server" '"Http Server"'
          do
            sleep 1
            docker logs --timestamps $(docker ps -q -f "label=com.docker.compose.project=datagrok" -f "label=com.docker.compose.service=datagrok")
            echo -e "\nRetrying..."
          done
          curl -s http://127.0.0.1:8080/api/info/server
          curl -s http://127.0.0.1:8080/api/admin/health
      - name: Create configuration for grok command-line tool
        run: |
          grok config add --default --alias ${HOST} --server 'http://127.0.0.1:8080/api' --key admin
          cat /home/runner/.grok/config.yaml
      - name: Install Grok Dependencies before package publish to Datagrok
        run: |
          grok_deps="$(jq  -r '. | select( has("devDependencies") == true ).devDependencies | to_entries[] | .key | select(test("@datagrok/.*")?)' package.json)"
          if [ -n "$grok_deps" ]; then
            for dep in $grok_deps; do
              current_dir=$(pwd)
              cd node_modules/$dep
              count=0
              retries=5
              echo "Publishing $dep to ${HOST}..."
              until grok publish ${HOST}; do
                exit=$?
                wait=$((2 ** count))
                count=$((count + 1))
                if [ $count -lt "$retries" ]; then
                  echo "Retry $count/$retries exited $exit, retrying 'grok publish ${HOST}' for $dep in $wait seconds..."
                  sleep $wait
                else
                  echo "Retry $count/$retries exited $exit, no more retries left for 'grok publish ${HOST}' for $dep."
                  exit $exit
                fi
              done
              cd $current_dir
            done
          fi
        working-directory: packages/${{ matrix.package }}
      - name: Publish package to Datagrok
        run: |
          count=0
          retries=5
          until grok publish ${HOST}; do
            exit=$?
            docker logs --timestamps --tail 100 $(docker ps -q -f "label=com.docker.compose.project=datagrok" -f "label=com.docker.compose.service=datagrok")
            wait=$((2 ** count))
            count=$((count + 1))
            if [ "$count" -lt "$retries" ]; then
              echo "Retry $count/$retries exited $exit, retrying 'grok publish ${HOST}' in $wait seconds..."
              sleep $wait
            else
              echo "Retry $count/$retries exited $exit, no more retries left for 'grok publish ${HOST}'."
              exit $exit
            fi
          done
        working-directory: packages/${{ matrix.package }}
      - name: Test Package
        continue-on-error: true
        timeout-minutes: 15
        id: test-package
        run: npm run test -- --skip-build --skip-publish --record --csv --verbose
        working-directory: packages/${{ matrix.package }}
      - name: Upload Artifact
        if: always() && steps.test-package.outcome != 'skipped'
        uses: actions/upload-artifact@v3
        with:
          name: ${{ matrix.package }}.test-results
          path: |
            packages/${{ matrix.package }}/test-record.mp4
            packages/${{ matrix.package }}/test-report.csv
            packages/${{ matrix.package }}/test-console-output.log
          retention-days: 14
          if-no-files-found: warn
      - name: Create error notification
        if: failure() && steps.test-package.outcome == 'failure'
        env:
          SLACK_ID: ${{ secrets.SLACK_ID }}
        run: |
          docker logs --timestamps $(docker ps -q -f "label=com.docker.compose.project=datagrok" -f "label=com.docker.compose.service=datagrok")
          echo "::error title=${{ matrix.package }}: failed tests with datagrok:bleeding-edge SHA=${{ steps.datagrok-image.outputs.docker_sha }}::Check job output for details"
          echo ",${{ matrix.author }}" >> authors.txt
          content=$(tail -c +2 trololo.txt)
          IFS=, read -ra authors <<< "$content"
          channel_id=""
          for author in "${authors[@]}"; do
            channel_id+=,$(echo "$EMAIL_SLACK_ID" | jq -r ".$author")
          done
          channel_ids="${channel_id:1}"
          echo "::add-mask::$channel_ids"
          echo SLACK_CHANNEL=$channel_ids >> $GITHUB_ENV

      - name: Prepare Slack Message
        run: |
          jobs=$(curl -L \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            ${{ github.event.workflow_run.jobs_url }})          
          header="GitHub Workflow <${{ github.event.workflow_run.html_url }}|${{ github.event.workflow_run.name }} ${{ github.event.workflow_run.run_number }}> failed:"
          echo SLACK_MESSAGE_HEADER=$header >> $GITHUB_ENV
          echo -e "SLACK_MESSAGE_BODY=$(jq -r '(.jobs[] | select(.conclusion == "failure") | {job: .name, step: (.steps[] | select(.conclusion == "failure").name), url: .html_url}) | "â€¢ <" + (.url) + "|" + (.job) + " / " + (.step) +  ">"' <<<$jobs)" | sed -e '$ ! s/$/\\n/' -e 's/"/\\"/g' | tr -d '\n' >> $GITHUB_ENV          

      - name: Send to Slack
        id: slack
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: ${{ env.SLACK_CHANNEL }}
          payload: |
            {
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "${{ env.SLACK_MESSAGE_HEADER }}"
                        }
                    },
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "${{ matrix.package }} has been failed after auto unskip tests. ${{ env.SLACK_MESSAGE_CONTEXT }}"
                        }
                    }
                    
                ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACKBOT_TOKEN }}
