import fs from 'fs';
import path from 'path';
import walk from 'ignore-walk';
import * as utils from '../utils/utils';
import * as color from '../utils/color-utils';

const annotationForApiFile = `/**\nThis file is auto-generated by the grok api command.\nIf you notice any changes, please push them to the repository.\nDo not edit this file manually.\n*/\n`;

const sep = '\n';

const packageFuncDirs = ['package.ts', 'package.g.ts'];
const apiFile = 'package-api.ts';

const curDir = process.cwd();
const srcDir = path.join(curDir, 'src');
const funcFilePath = path.join(fs.existsSync(srcDir) ? srcDir : curDir, apiFile);
const packagePath = path.join(curDir, 'package.json');
const names = new Set<string>();

let _package: any = {};

function generateQueryWrappers(verbose: boolean): void {
  const queriesDir = path.join(curDir, 'queries');
  if (!fs.existsSync(queriesDir)) {
    if (verbose) {
      color.warn(`Directory ${queriesDir} not found`);
      console.log('Skipping API generation for queries...');
    }
    return;
  }

  const files = walk.sync({
    path: './queries',
    ignoreFiles: ['.npmignore', '.gitignore'],
  });

  const wrappers = [];
  for (const file of files) {
    if (!file.endsWith(utils.queryExtension)) continue;
    const filepath = path.join(queriesDir, file);
    const script = fs.readFileSync(filepath, 'utf8');
    if (!script) continue;

    const queries = script.split(/--\s*end/).map((q) => q.trim()).filter((q) => q.length > 0);
    for (const q of queries) {
      const name = utils.getScriptName(q, utils.commentMap[utils.queryExtension]);
      if (!name) continue;

      checkNameColision(name);

      const tb = new utils.TemplateBuilder(utils.queryWrapperTemplate)
        .replace('FUNC_NAME', name)
        .replace('FUNC_NAME_LOWERCASE', name)
        .replace('PACKAGE_NAMESPACE', _package?.friendlyName ?? '');

      const description = utils.getScriptDescription(q, utils.commentMap[utils.queryExtension]);
      const inputs = utils.getScriptInputs(q, utils.commentMap[utils.queryExtension]);
      const outputType = utils.getScriptOutputType(q, utils.commentMap[utils.queryExtension]);
      tb.replace('PARAMS_OBJECT', inputs)
        .replace('TYPED_PARAMS', inputs)
        .replace('FUNC_DESCRIPTION', description)
        .replace('OUTPUT_TYPE', outputType === 'void' ? utils.dgToTsTypeMap['dataframe'] : outputType);
      wrappers.push(tb.build(1));
    }
  }

  saveWrappersToFile('queries', wrappers, verbose);
}

function generateScriptWrappers(verbose: boolean): void {
  const scriptsDir = path.join(curDir, 'scripts');
  const pythonDir = fs.existsSync(srcDir) ? path.join(srcDir, 'python') : path.join(curDir, 'python');
  if (!fs.existsSync(scriptsDir)) {
    if (verbose) {
      color.warn(`Directory ${scriptsDir} not found`);
      console.log('Skipping API generation for scripts...');
    }
    return;
  }
  const wrappers = [];

  for (let dir of [scriptsDir, pythonDir]) {
    if (!fs.existsSync(dir))
      continue;
    const files = walk.sync({
      path: dir,
      ignoreFiles: ['.npmignore', '.gitignore'],
    });
    for (const file of files) {
      let extension: string;
      if (!utils.scriptExtensions.some((ext) => (extension = ext, file.endsWith(ext)))) continue;

      const filepath = path.join(dir, file);
      const script = fs.readFileSync(filepath, 'utf8');
      if (!script) continue;

      const name = utils.getScriptName(script, utils.commentMap[extension!]);
      if (!name) continue;
      const description = utils.getScriptDescription(script);

      checkNameColision(name)

      const tb = new utils.TemplateBuilder(utils.scriptWrapperTemplate)
        .replace('FUNC_NAME', name)
        .replace('FUNC_NAME_LOWERCASE', name)
        .replace('PACKAGE_NAMESPACE', _package?.friendlyName ?? '');

      const inputs = utils.getScriptInputs(script);
      const outputType = utils.getScriptOutputType(script);
      tb.replace('PARAMS_OBJECT', inputs)
        .replace('TYPED_PARAMS', inputs)
        .replace('FUNC_DESCRIPTION', description)
        .replace('OUTPUT_TYPE', outputType);
      wrappers.push(tb.build(1));
    }
  }

  saveWrappersToFile('scripts', wrappers, verbose);
}

function generateFunctionWrappers(verbose: boolean): void {
  let filesToParse = packageFuncDirs.map((e) => path.join(curDir, 'src', e)).filter((e) => fs.existsSync(e));

  const annotaionRegex = /(?:\/\/[^\n]*\n)+export[^{]*/g;
  const nameRegex = /\s*export(?:\sasync)?\s*function\s*([^\s(]*)/;

  const wrappers = [];
  for (const file of filesToParse) {
    const fileData = fs.readFileSync(file, 'utf8');
    const annotations = fileData.matchAll(annotaionRegex);
    if (annotations === null)
      return;

    for (let annotation of annotations) {
      const name = (annotation[0].match(nameRegex) ?? [undefined, undefined])[1];
      const description = utils.getScriptDescription(annotation[0], utils.commentMap[utils.jsExtention]);
      if (!name)
        continue;

      const annotationInputs = utils.getScriptInputs(annotation[0], utils.commentMap[utils.jsExtention]);
      const annotationOutputDir = utils.getScriptOutputType(annotation[0], utils.commentMap[utils.jsExtention]);
      let outputType = '';

      outputType = annotationOutputDir ?? 'any';
      checkNameColision(name);

      const tb = new utils.TemplateBuilder(utils.scriptWrapperTemplate)
        .replace('FUNC_NAME', name)
        .replace('FUNC_NAME_LOWERCASE', name)
        .replace('PACKAGE_NAMESPACE', _package?.friendlyName ?? '')
        .replace('PARAMS_OBJECT', annotationInputs)
        .replace('FUNC_DESCRIPTION', description)
        .replace('TYPED_PARAMS', annotationInputs)
        .replace('OUTPUT_TYPE', outputType);
      wrappers.push(tb.build(1));
    }
  }

  saveWrappersToFile('funcs', wrappers, verbose);
}

function saveWrappersToFile(namespaceName: string, wrappers: string[], verbose: boolean) {
  if (wrappers.length === 0)
    return;
  if (!fs.existsSync(funcFilePath))
    createApiFile(verbose)

  const scriptApi = new utils.TemplateBuilder(utils.namespaceTemplate)
    .replace('PACKAGE_NAMESPACE', namespaceName)
    .replace('NAME', wrappers.join(sep.repeat(2)));
  fs.appendFileSync(funcFilePath, sep + scriptApi.build() + sep);
  if (verbose)
    color.success(`Successfully generated file ${apiFile}${sep}`);
}

function createApiFile(verbose: boolean) {
  if (fs.existsSync(funcFilePath) && verbose) {
    color.warn(`The file ${funcFilePath} already exists`);
    console.log('Rewriting its contents...');
  }
  fs.writeFileSync(funcFilePath, annotationForApiFile + utils.dgImports + sep, 'utf8');
}

function checkNameColision(name: string) {
  if (names.has(name))
    console.log('There is collision in name ' + name)
  names.add(name);
}

export function api(args: { _: string[], verbose?: boolean, v?: boolean }): boolean {
  const verbose = args.verbose || args.v || false;
  _package = JSON.parse(fs.readFileSync(packagePath, { encoding: 'utf-8' }));
  if (_package.friendlyName)
    _package.friendlyName = _package.friendlyName.replaceAll(' ', '')
  const nOptions = Object.keys(args).length - 1 - (args.verbose ? 1 : 0) - (args.v ? 1 : 0);
  if (args['_'].length !== 1 || nOptions > 0) return false;
  if (!utils.isPackageDir(process.cwd())) {
    color.error('File `package.json` not found. Run the command from the package directory');
    return false;
  }
  createApiFile(verbose);
  generateScriptWrappers(verbose);
  generateQueryWrappers(verbose);
  generateFunctionWrappers(verbose);
  return true;
}
