const fs = require('fs');
const path = require('path');

const tsParser = require('@typescript-eslint/typescript-estree');
const generate = require('@babel/generator').default;

const {
  reservedDecorators,
  getFuncAnnotation,
  generateImport,
  generateExport,
  typesToAnnotation,
  dgAnnotationTypes,
  decoratorOptionToAnnotation,
  inputOptionsNames,
} = require('../bin/utils/func-generation');

const {toCamelCase} = require('../bin/commands/migrate');

const {api} = require('../bin/commands/api');

const baseImport = 'import * as DG from \'datagrok-api/dg\';\n';
// eslint-disable-next-line max-len
const annotationForGeneratedFile = `/**\nThis file is auto-generated by the webpack command.\nIf you notice any changes, please push them to the repository.\nDo not edit this file manually.\n*/\n`;

class FuncGeneratorPlugin {
  constructor(options = {outputPath: './src/package.g.ts'}) {
    this.options = options;
  }

  apply(compiler) {
    const srcDirPath = path.join(compiler.context, 'src');
    let packageFilePath = path.join(srcDirPath, 'package.ts');
    if (!fs.existsSync(packageFilePath))
      packageFilePath = path.join(srcDirPath, 'package.js');
    const tsFiles = this._getTsFiles(srcDirPath);
    const genImports = [];
    const genExports = [];

    compiler.hooks.compilation.tap('FuncGeneratorPlugin', (_compilation) => {
      this._clearGeneratedFile();

      for (const file of tsFiles) {
        const content = fs.readFileSync(file, 'utf-8');
        if (!content.includes('@grok.decorators.')) continue;

        if (!content) continue;
        const ast = tsParser.parse(content, {
          sourceType: 'module',
          plugins: [
            ['decorators', {decoratorsBeforeExport: true}],
            'classProperties',
            'typescript',
          ],
        });
        const functions = [];
        const imports = new Set();
        this._walk(ast, (node, parentClass) => {
          const decorators = node.decorators;
          if (!decorators || decorators.length === 0) return;

          if (node?.type === 'ClassDeclaration') {
            this._addNodeData(
              node,
              file,
              srcDirPath,
              functions,
              imports,
              genImports,
              genExports,
            );
          }

          if (node?.type === 'MethodDefinition') {
            this._addNodeData(
              node,
              file,
              srcDirPath,
              functions,
              imports,
              genImports,
              genExports,
              parentClass,
            );
          }
        });
        this._insertImports([...imports]);
        fs.appendFileSync(this.options.outputPath, functions.join(''), 'utf-8');
      }
      this._checkPackageFileForDecoratorsExport(packageFilePath);
      // Uncommment to add obvious import/export
      // this._writeToPackageFile(packageFilePath, genImports, genExports);
    });
    api({_: ['api']});
  }

  _addNodeData(
    node,
    file,
    srcDirPath,
    functions,
    imports,
    genImports,
    genExports,
    parent = undefined,
  ) {
    if (
      !node.decorators ||
      !node.decorators.length ||
      node.decorators?.length === 0
    )
      return;

    function modifyImportPath(dirPath, filePath) {
      const relativePath = path.relative(dirPath, filePath);
      return `./${relativePath
        .slice(0, relativePath.length - 3)
        .replace(/\\/g, '/')}`;
    }

    const decorator = node.decorators[0];
    const exp = decorator.expression;
    const name = exp.callee?.property?.name || exp.callee?.name;
    const identifierName = node.id?.name || node.key?.name;
    const className = parent?.id?.name || parent?.key?.name;

    if (!name) return;

    const decoratorOptions = this._readDecoratorOptions(
      exp.arguments[0]?.properties ?? [],
    );

    decoratorOptions.set('tags', [
      ...(reservedDecorators[name]['metadata']['tags'] ?? []),
      ...(decoratorOptions.get('tags') ?? []),
    ]);
    
    const role = reservedDecorators[name]['metadata']['role'];
    if (role?.length > 0) {
      const camelRole = toCamelCase(role);

      if (!decoratorOptions.has('meta')) 
        decoratorOptions.set('meta', {role: camelRole});
      else {
        const meta = decoratorOptions.get('meta');
        meta['role'] = meta['role'] ? `${meta['role']},${camelRole}` : camelRole;
      }
    }

    const functionParams =
      node?.type === 'MethodDefinition' ? this._readMethodParamas(node) : [];
    const annotationByReturnObj = node?.type === 'MethodDefinition' ? this._readOutputsFromReturnType(node) : undefined;
    
    const isMethodAsync = this._isMethodAsync(node);
    const importString = generateImport(
      node?.type === 'MethodDefinition' ? className : identifierName,
      modifyImportPath(path.dirname(this.options.outputPath), file),
    );
    const metadataCopy = {...reservedDecorators[name]['metadata']};
    delete metadataCopy.role;
    
    imports.add(importString);
    const funcName = `${
      node?.type === 'MethodDefinition' ? '' : '_'
    }${identifierName}`;
    const funcAnnotaionOptions = {
      ...{name: funcName},
      ...metadataCopy,
      ...(annotationByReturnObj ?
        {outputs: annotationByReturnObj ?? []} :
        {}),
      ...Object.fromEntries(decoratorOptions),
      ...{inputs: functionParams},
      ...{isAsync: isMethodAsync},
    };

    let actualType = undefined;
    if (annotationByReturnObj?.length > 1)
      actualType = 'any';
    else if (annotationByReturnObj?.length === 1 && annotationByReturnObj[0]?.actualType)
      actualType = annotationByReturnObj[0].actualType;
    else if (funcAnnotaionOptions.outputs?.length === 0)
      actualType = 'void';

    // if (!funcAnnotaionOptions.name) funcAnnotaionOptions.name = identifierName;
    function containsAnything(funcAnnotaionOptions) {
      let hasValues = false;
      const arrays = ['tags', 'inputs', 'outputs'];
      for (const option of Object.keys(funcAnnotaionOptions)) {
        if (arrays.includes(option)) {
          if (funcAnnotaionOptions[option].length > 0)
            hasValues = true;
        } else if (option != 'isAsync' && option != 'name')
          hasValues = true;
      }
      return hasValues;
    }
    if (funcAnnotaionOptions.name === funcName && containsAnything(funcAnnotaionOptions))
      delete funcAnnotaionOptions.name;
    functions.push(
      reservedDecorators[name]['genFunc'](
        getFuncAnnotation(funcAnnotaionOptions),
        identifierName,
        '\n',
        className ?? '',
        functionParams,
        actualType,
        funcAnnotaionOptions.isAsync ?? false,
      ),
    );
    genImports.push(
      generateImport(
        funcName,
        modifyImportPath(srcDirPath, this.options.outputPath),
      ),
    );
    genExports.push(generateExport(funcName));
  }

  _isMethodAsync(node) {
    let result = false;
    if (node.type === 'MethodDefinition') result = node.value.async;
    return result;
  }

  _readImports(content) {
    const importRegex = /(import(?:[\s\w{},*]+from\s*)?['']([^'']+)[''];)/g;
    const results = [];

    let match;
    while ((match = importRegex.exec(content)) !== null) 
      results.push(`${match[1]}\n`);
    
    return results;
  }

  _readDecoratorOptions(properties, readForParams= false) {
    const resultMap = new Map();
    let resultObj = undefined;
    // for (const prop of properties)
    //   resultMap.set(prop.key.name ?? prop.key.value, this._evalLiteral(prop.value));
    const optionsToAdd = new Map();
    for (const prop of properties) {
      const key = decoratorOptionToAnnotation.get(prop.key.name ?? prop.key.value ?? '') ?? prop.key.name ?? prop.key.value;
      if (!readForParams && key === 'result')
        resultObj = this._evalLiteral(prop.value);
      else if (readForParams && inputOptionsNames.includes( prop.key.name ?? prop.key.value)) 
        optionsToAdd.set(key, this._evalLiteral(prop.value));
      else
        resultMap.set(key, this._evalLiteral(prop.value));
    }
    
    for (const [key, value] of optionsToAdd)
      resultMap.set(key, value);
    if (resultObj)
      resultMap.set('outputs', [resultObj]);
    
    return resultMap;
  }

  _evalLiteral(node) {
    if (!node) return null;
    switch (node.type) {
    case 'Literal':
      return node.value;

    case 'ArrayExpression':
      return node.elements.map((el) => this._evalLiteral(el));

    case 'MemberExpression':
      return dgAnnotationTypes[node?.property?.name ?? ''] ?? 'dynamic';

    case 'ObjectExpression':
      return Object.fromEntries(
        node.properties.map((p) => {
          return [p.key.name || p.key.value, this._evalLiteral(p.value)];
        }),
      );

    default:
      return '';
    }
  }

  _readMethodParamas(node) {
    const params = node?.value?.params?.map((param) => {
      let baseParam =
        param.type === 'TSNonNullExpression' ? param.expression : param;
      const options =
        param.decorators?.length > 0 ?
          Object.fromEntries(
            this._readDecoratorOptions(
              param.decorators[0]?.expression?.arguments[0].properties, true),
          ) :
          undefined;
        
      // Commented code finds value by default of function's variable
      // let defaultValue = undefined;
      if (baseParam.type === 'AssignmentPattern') {
        // if (baseParam?.right?.type  === 'Literal')
        //   defaultValue = baseParam?.right?.raw;
        baseParam = baseParam?.left;
      }
      const optional = param.optional;
      if (baseParam.type === 'RestElement' || baseParam.type === 'Identifier') {
        let name =
          baseParam.type === 'RestElement' ?
            `...${baseParam.argument.name}` :
            baseParam.name;
        if (baseParam?.argument?.typeAnnotation) {
          name +=
            ': ' +
            generate(baseParam.argument.typeAnnotation.typeAnnotation).code;
        }

        let type = '';
        if (baseParam?.typeAnnotation?.typeAnnotation)
          type = generate(baseParam.typeAnnotation.typeAnnotation).code;
        else type = 'any';

        const params =
          baseParam.typeAnnotation.typeAnnotation.typeArguments?.params;
        if (type !== 'any' && params && params.length > 0)
          type += `<${params.map((e) => e.typeName?.name ?? 'any').join(',')}>`;
        return {name: name, type: type, options: options, optional: optional};
      }
      // Commented code belove sets more strong types for ObjectPatterns and ArrayPatterns
      // else if (baseParam.type === 'ObjectPattern' || baseParam.type === 'ArrayPattern') {
      //   let name = '';
      //   if (baseParam.type === 'ObjectPattern') {
      //     const properties = baseParam.properties.map(prop => {
      //       if (prop.type === 'Property' && prop.key.type === 'Identifier')
      //         return prop.key.name;
      //       else if (prop.type === 'RestElement' && prop.argument.type === 'Identifier')
      //         return `...${prop.argument.name}`;
      //       else
      //         return generate(prop).code;
      //     });
      //     name = `{ ${properties.join(', ')} }`;
      //   } else {
      //     const elements = baseParam.elements.map(elem => {
      //       if (elem) {
      //         if (elem.type === 'Identifier')
      //           return elem.name;
      //         else
      //           return generate(elem).code;
      //       } else return '';
      //     });
      //     name = `[${elements.join(', ')}]`;
      //   }

      //   let type = '';
      //   if (baseParam.typeAnnotation)
      //     type = generate(baseParam.typeAnnotation.typeAnnotation).code;
      //   else
      //     type = 'any';

      //   return { name: name, type: type, options: options };
      // }

      return {name: 'value', type: 'any', options: undefined, optional: optional};
    });
    return params;
  }

  _getTsFiles(root) {
    const tsFiles = [];
    const extPattern = /\.tsx?$/;
    const excludedFiles = ['package-test.ts', 'package.g.ts'];

    function findFiles(dir) {
      const files = fs.readdirSync(dir);
      for (const file of files) {
        const fullPath = path.join(dir, file);
        if (fs.statSync(fullPath).isDirectory()) findFiles(fullPath);
        else if (extPattern.test(file) && !excludedFiles.includes(file))
          tsFiles.push(fullPath);
      }
    }

    findFiles(root);
    return tsFiles;
  }

  _walk(node, visitor, parent = null) {
    if (!node || typeof node !== 'object') return;

    visitor(node, parent);

    for (const key in node) {
      const value = node[key];
      if (Array.isArray(value)) {
        value.forEach((child) => {
          if (child && typeof child.type === 'string') {
            this._walk(
              child,
              visitor,
              node.type === 'ClassDeclaration' ? node : parent,
            );
          }
        });
      } else if (value && typeof value.type === 'string') {
        this._walk(
          value,
          visitor,
          node.type === 'ClassDeclaration' ? node : parent,
        );
      }
    }
  }

  _readReturnType(annotation) {
    let resultType = 'void';
    let nodeAnnotation = annotation;
    let isArray = false; 
    let isNullable = false; 
    if (nodeAnnotation?.type === 'TSUnionType' && 
      nodeAnnotation?.types?.length === 2 && 
      nodeAnnotation?.types?.some((e)=> e?.type === 'TSNullKeyword' || e?.type === 'TSVoidKeyword'|| e?.type === 'TSUndefinedKeyword')) {
      nodeAnnotation = 
        nodeAnnotation.types.filter((e)=> e.type !== 'TSNullKeyword' || e?.type === 'TSVoidKeyword' || e?.type === 'TSUndefinedKeyword')[0];
      isNullable = true;
    }
    

    if (
      nodeAnnotation &&
      nodeAnnotation.type !== 'TSUnionType' &&
      nodeAnnotation.type !== 'TSIntersectionType'
    ) {
      if (nodeAnnotation.typeName || nodeAnnotation.type === 'TSTypeReference') {
        resultType =
          nodeAnnotation.typeName?.right?.name ?? nodeAnnotation.typeName?.name;
      } else if (nodeAnnotation.type !== 'TSArrayType') 
        resultType = this._getTypeNameFromNode(nodeAnnotation);
      else if (nodeAnnotation.elementType.type !== 'TSTypeReference') {
        isArray = true;
        resultType = this._getTypeNameFromNode(nodeAnnotation?.elementType);
      } else {
        isArray = true;
        resultType =
          nodeAnnotation?.elementType?.typeName?.name ||
          nodeAnnotation?.elementType?.typeName?.right?.name;
      } 
    }
    let anotationType = typesToAnnotation[resultType];
    resultType = isNullable? 'any' : resultType;
    if (isArray && anotationType) anotationType = `list<${anotationType}>`;
    return [anotationType ?? 'dynamic', `${resultType}${isArray? '[]': ''}` ?? 'any'];
  }

  _readOutputsFromReturnType(node) {
    let results = [];
    let annotation = node.value?.returnType?.typeAnnotation;

    if (node?.type === 'ClassDeclaration')
      return [];
    
    if (annotation?.typeName?.name === 'Promise') {
      const argumnets = annotation.typeArguments?.params;
      if (argumnets && argumnets.length === 1) 
        annotation = argumnets[0];
      else annotation = {};
    }

    if (annotation?.type === 'TSTypeLiteral') 
      results = this._readOutputsFromReturnTypeObject(annotation);
    else {
      const [annotationType, resultType] = this._readReturnType(annotation);
      if (annotationType !== 'void') {
        results.push({
          name: 'result', 
          type: annotationType,
          actualType: resultType,
        });
      }
    }
    return results;
  }

  _readOutputsFromReturnTypeObject(node) {
    let i = 0;
    const results = [];
    for (const member of node.members) {
      const [annotationType, resultType] = this._readReturnType(annotation);
      results.push({
        name: member?.key?.name ?? `result${i}`,
        type: annotationType,
        actualType: resultType,
      });
      i++;
    }
    return results;
  }

  _getTypeNameFromNode(typeNode) {
    if (typeNode.type === 'TSTypeReference') 
      return typeNode.typeName.name;
    else if (typeNode.type === 'TSVoidKeyword') 
      return 'void';
    else if (typeNode.type === 'TSUndefinedKeyword ') 
      return 'undefined';
    else if (typeNode.type === 'TSNumberKeyword') 
      return 'number';
    else if (typeNode.type === 'TSStringKeyword') 
      return 'string';
    else if (typeNode.type === 'TSBooleanKeyword') 
      return 'boolean';
    else 
      return typeNode.type;
    
  }

  _clearGeneratedFile() {
    fs.writeFileSync(this.options.outputPath, baseImport);
  }

  _checkPackageFileForDecoratorsExport(packagePath) {
    const content = fs.readFileSync(packagePath, 'utf-8');
    const decoratorsExportRegex = /export\s*\*\s*from\s*'\.\/package\.g';/;
    if (!decoratorsExportRegex.test(content)) {
      console.warn(
        // eslint-disable-next-line max-len
        `\nWARNING: Your package doesn't export package.g.ts file to package.ts \n please add 'export * from './package.g';' to the package.ts file.\n`,
      );
    }
  }

  _writeToPackageFile(filePath, imports, exp) {
    if (imports.length !== exp.length) return;
    let content = fs.readFileSync(filePath, 'utf-8');
    for (let i = 0; i < imports.length; i++) {
      const importStatement = imports[i];
      const exportStatement = exp[i];
      if (!content.includes(importStatement.trim()))
        content = annotationForGeneratedFile + importStatement + content + exportStatement;
    }
    fs.writeFileSync(filePath, content, 'utf-8');
  }

  _insertImports(importArray) {
    if (fs.existsSync(this.options.outputPath)) {
      const content = fs.readFileSync(this.options.outputPath, 'utf-8');
      if (content) importArray.push(content);
      const output = importArray.join('');
      fs.writeFileSync(this.options.outputPath, `${output}`, 'utf-8');
    } else {
      fs.writeFileSync(
        this.options.outputPath,
        `${annotationForGeneratedFile}${baseImport}\n${importArray.join('')}`,
        'utf-8',
      );
    }
  }
}

module.exports = FuncGeneratorPlugin;
