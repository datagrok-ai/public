---
title: "Advanced scripting in Datagrok"
---

This section described advanced capabilities of Datagrok scripting.

### Output values validation

Datagrok functions return zero, one or more typed arguments.
Any single run of the function shall always return as many
output values as specified in the header, all having corresponding types.
It is expected that the output values would be
assigned throughout the script code, so that they are defined by the end of the script.
If for some reason this doesn't
happen, the two things will follow:

1. The unset output values would still be returned, but valued as `null`-s.

2. A warning `Output value ${output.param.name} was not set` will be print to
   [Datagrok Console](../datagrok/navigation/navigation.md#console) (open it with `Ctrl-~`).

In this script the value `c3` is missed to be set:

```
#name: TestMissingInputsR
#language: r
#output: int c1
#output: int c2
#output: int c3
c1 <- 12
c2 <- 15
```

Running the script produces the following output to the console:

```
Output value c3 was not set
  c1: 12
  c2: 15
  c3: null
```

We recommend using the Datagrok Console while validating your scripts.

### Advanced ways to execute scripts

First of all, a script can be executed right from the script editor (see picture below).

Other ways involve saving the script as a part of a [package](../develop/develop.md#packages). In this case, it gets
registered in the platform as a
[function](../datagrok/concepts/functions/functions.md), and can be invoked in different ways:

* From the [console](../datagrok/navigation/navigation.md#console)
* From the data job
* From the [transformations editor](../transform/recipe-editor.md)
* From the [function browser](https://public.datagrok.ai/functions)

![Scripting](../uploads/gifs/scripting-visualization.gif "Scripting")

When a function is invoked with no explicitly specified parameters, a dialog is shown. The UI is automatically generated
by creating editors for each parameter. Depending on the metadata associated with the parameters, the editor can be
enriched by [validators](#parameter-validators), [choices](#parameter-choices),
and [suggestions](#parameter-suggestions). Validators, choices, and suggestions are
[functions](../datagrok/concepts/functions/functions.md), that means they can be implemented in different ways (db query, script,
etc), and reused.

Registered scripts can be called via [JavaScript API](../develop/packages/js-api.md) in the following manner:

```javascript
grok.functions.call(`${packageName}:${scriptName}`, { params });
```

To see it in action, open this
[code snippet](https://public.datagrok.ai/js/samples/scripting/scripting) from our samples gallery. There you can find
more examples, such as
[adding a progress indicator](https://public.datagrok.ai/js/samples/functions/progress) to the user interface.

Scripts that have multiple output parameters may require a different approach. The
`grok.functions.call` method returns only the first output value, thus, in order to get all of them, you should work
with a function call:

```javascript
let f = await grok.functions.eval(`${packageName}:${scriptName}`);
let call = f.prepare({ params });
await call.call();
call.getParamValue('paramName');
```

In the first line we evaluate an expression and get the function that corresponds to our script. After passing the input
parameters and executing the script, we can retrieve any output value by the parameter's name.

## Environments

### Conda environments

Each script can be given a specific environment configuration under which it will run, including the language verison
and a set of libraries. [Conda](https://docs.conda.io/en/latest/)
is used as the environment management system. Conda environment is specified as a yaml configuration file or a string.

The benefit of using a Conda environment is that it gives a completely sandboxed, controlled area for running scripts,
and only takes time once to be pre-created and later be re-used by a reference with no delay for resolving dependencies
and installing language versions.

In Datagrok, Conda environment confinugration can be specified either right inside the script, or as part of
a [package](../develop/develop.md#packages). The package can be both the one containing the script or any other deployed
package with specified environment and available under your current user.

#### Specify environment in a package

Environment configuration is stored in the default Conda yaml format and can be
[exported](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file)
or [created manually](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#create-env-file-manually)
.

Configurations are stored in the same repository with the script, in the folder called
`environments` located under the repository root. Here is an
[example of such configuration](https://github.com/datagrok-ai/public/tree/master/environments)
for the [Datagrok public repository](https://github.com/datagrok-ai/public). Also, a package can define its own
configurations as well (
[see examples](https://github.com/datagrok-ai/public/tree/master/packages/Demo/scripts)).

If the `#environment` tag in the script header is not specified, the script uses the configuration defined in
[`default.yaml`](https://github.com/datagrok-ai/public/blob/master/environments/default.yaml).

This is how to define the "Chemprop" environment in the script header:

```
#environment: Chemprop
```

In this case, the environment `Chemprop` should be specified in a file
`environments/Chemprop.yaml` inside the package where this script belongs.

Datagrok identifies and resolves environments by their names. If an environment referred in a script wasn't previously
used, it will first be created on the
[Compute Virtual Machine](../develop/under-the-hood/infrastructure.md#compute-components). This may take up to several minutes.
If it was used at least once, a previously created environment will be re-used with no delay to run the script.

#### Specify environment in-place

Set an `environment` parameter of the script to a one-liner yaml specifying the standard Conda yaml config, but omitting
its name and enclosing braces `{}`. For example, we need to use the following Conda yaml config:

```yaml
name: envtest01
channels:
  - conda-forge
dependencies:
  - python=3.8
  - glom
  - pip:
      - requests
```

To use it in any script, specify it as follows:

```python
# name: EnvTestInline
# environment: channels: [conda-forge], dependencies: [python=3.8, glom, {pip: [requests]}]
# language: python
# output: string result

import re, requests
from glom import glom
import pandas as pd

target = {'a': {'b': {'c': 'd'}}}
result = glom(target, 'a.b.c')  # returns 'd'
```

When the script runs first time, the environment will be created on
the [Compute Virtual Machine](../develop/under-the-hood/infrastructure.md#compute-components), which may take some time, up to
several minutes. However, on the second run and onwards this environment will simply be reused. If the environment
string is changed in this script to some other environment which was previously created in same way even in some other
script, this environment will also be picked up and reused. These environments are handeled by Datagrok using MD5 hashes
of their body strings.

#### Reference an environment from another package

An environment `SomeEnv` specified in a package `SomePackage` is available from all scripts in the platform for
referencing as `SomePackage:SomeEnv`. If the package `SomePackage` is available to the current user, the reference will
work. Such environment reference is abailable in both package scripts and ad-hoc scripts created in the platform UI.

#### Global environments

Environment referencing is a handy way to organize global (organization-wide) environments. This will let an
administrator version such common environments through a dedicated package, and exactly one physical environment will be
re-used by many users, which is more space and time efficient.

Do the following steps:

1. Agree that one package, say, `GlobalEnvs` will now contain global environments
2. Choose a common prefix to name these global environments with, say, `Global`
3. Name all global environments in this package with the chosen prefix: `Global<ENVIRONMENT_NAME>`
4. Publish `GlobalEnvs` platform as `--release` to the platform and share it to `All Users`, or to the group of users
   you want to have access to these environments
5. Let other users know these environments are now available as
   `GlobalEnvs:Global<ENVIRONMENT_NAME>`

In the future, a script editor will be provided in Datagrok. For the property `#environment:` of the script, it will
enumerate in a dropdown list all available environments for the current user and the current script.

#### Common practices with Conda environments

It is a [known](https://github.com/conda/conda/issues/8051#issuecomment-464199791)
[issue](https://github.com/conda/conda/issues/8051#issuecomment-631862928)
[of Conda](https://github.com/conda/conda/issues/8051#issuecomment-808789923) that it tends to sometimes take a large
time to resolve (set up) an environment. Datagrok will interrupt Conda environment creation if it takes more than 5
minutes.

While we haven't found a workaround to this feature of Conda, we can recommend a way forward if you encounter a timing
problem with your Conda environment. It is often possible to find an equivalent set of packages from `pip` repositories.
Using `pip` via Conda environments doesn't have timing issues, and we advise to use the `pip` section of Conda yaml spec
to set up your libraries of interest.

#### Conda and Pip custom repositories

By default, conda uses conda-forge and pypi repositories to install packages. It is possible to specify custom conda and pip repositories in environments, for example to use `http://my-repo/custom/` as conda repository and `https://mirrors.sustech.edu.cn/pypi/simple` as pip repository use the following code

```
# environment: channels: [http://my-repo/custom/], dependencies: [python=3.8, glom, {pip: [--index-url https://mirrors.sustech.edu.cn/pypi/simple, requests]}]
```

### Renv environments

[_Renv_](https://rstudio.github.io/renv/articles/renv.html) environments are natively supported. Datagrok runs each R
script in a temporary folder with a unique name. This folder becomes an
_renv_ project folder for the current run of the script.

Start using _renv_ by initializing it and installing packages (see a
[full example](https://github.com/datagrok-ai/public/blob/master/packages/Demo/scripts/r/renv_spelling.R)):

```
#language: r
...
renv::init()
renv::install("hunspell@3.0.1")
...
```

An _renv_ session only impacts the R environment for this one single run, and no other R scripts running in parallel by
the users of the platform are aware of this local script environment.
_Renv_ uses a global package cache. It caches a package requested once with `renv::install` and re-uses whenever it is
requested onward. However, in case the latest package version is requested, such as in `renv::install("hunspell")`, _
renv_ connects to remote R package repositories assuring if the cached package needs to be updated to the newer version.
This may introduce a significant delay into the script, several seconds in practice. To avoid this, we recommend
installing a specific version of the package, such as in `renv::install("hunspell@3.0.1")`.

_Note_. At the R script's start and finish, Datagrok calls `renv::deactivate()` to assure the script's body isolation.
Therefore, the script's author doesn't need to call
`renv::deactivate()` manually.

We are planning to support [_renv_ lockfiles](https://rstudio.github.io/renv/articles/lockfile.html)
shipped with packages similarly to how it works now for Conda `yaml` files.

## Parameters

### Parameter validators

Validators check whether the value falls in the expected range, and provide visual cue if it does not. To add a
validator to a parameter, provide a comma-separated list of functions that will be invoked each time a value is changed.
A null indicates that the value is valid, anything else indicates an error which gets shown to the user.

A validator is a function that accepts one parameter of any type and returns a string. Choice providers are applicable
only to string parameters.

The following example adds a "containsLettersOnly" function to the "col" parameter:

```
#input: string s {validators: ["containslettersonly"]}
#input: column col {validators: ["containsmissingvalues"]}
```

```js
grok.functions.register({
    signature: 'List<String> jsVal1(int input)',
    run: (input) => input < 11 ? null : "Error val1" });

grok.functions.register({
    signature: 'List<String> jsVal2(int input)',
    run: (input) => input > 9 ? null : "Error val2" });
```

```python
# name: Numbers
# language: python
# input: int count1 {validators: ["jsval1", "jsval2"]} [Number of cells in table]
# input: int count2 {validators: ["jsval1"]} [Number of cells in table]
# input: int count3 {validators: ["jsval2"]} [Number of cells in table]
```

![Script Parameter Validators](../uploads/features/script-param-validators.gif "Script Parameter Validators")

### Parameter choices

Use choices to provide the editor a list of values to choose from. When choices are provided, the editor becomes a combo
box. Choices can be either a fixed list, or a function that returns a list.

A choice provider is a function with no parameters that returns a list of strings.

The following example demonstrates two ways of defining choices:

```
#input: string fruit {choices: ["apple", "banana"]}
#input: string vegetable {choices: jsveggies}
```

Here is a possible implementation of the "jsTypes" function used in the example:

```javascript
grok.functions.register({
    signature: 'List<String> jsVeggies()',
    run: () => ["Cucumber", "Cauliflower"]});
```

![Script Parameter Choices](../uploads/features/script-param-choices.gif "Script Parameter Choices")

### Parameter suggestions

Use parameter suggestions to help users enter a correct value. For instance, when entering a product name, it might make
sense to dynamically query a database for values starting with the already entered text, and suggest to auto-complete
the value.

Suggestions are functions that take one string argument, and return a list of strings to be suggested to user.
Suggestions work only for string parameters.

The following example helps user enter a country name by dynamically retrieving a list of names from a web service:

```python
# name: Sales by country
# language: python
# input: string country = uk {suggestions: jsSuggestCountryName}
```

```js
grok.functions.register({
  signature: 'List<String> jsSuggestCountryName(String text)',
  isAsync: true,
  run: async function(text) {
    let response = await fetch('https://restcountries.eu/rest/v2/name/' + text);
    return response.status === 200 ? (await response.json()).map(country => country['name']) : [];
  }
});
```

![Script Parameter Suggestions](../uploads/features/script-param-suggestions.gif "Script Parameter Suggestions")

#### Auto-complete via SQL

The same concept could be used for SQL queries:

![auto-complete-sql](auto-complete-sql.png)

### Parameter editors

Use parameter editor to set the output of another function to the parameter value. All function parameters will be
seamlessly integrated to the function call form.

```
//input: dataframe table {editor: Package:DataQuery}
//input: dataframe table {editor: Package:DataQuery(1, "France")}
```

Here, Datagrok will execute the `Package:DataQuery` function right before your script and pass the output table to the
script as an input parameter.

```
//input: dataframe table {editor: PowerPack:DataQuery; editor-button: Outliers...}
```

Specify the `editor-button` parameter to add a button that executes your subfunction separately and allows the user to
check the output before starting the script.

### Examples

```
#input: dataframe t1 {columns:numerical} [first input data table]
#input: dataframe t2 {columns:numerical} [second input data table]
#input: column x {type:numerical; table:t1} [x axis column name]
#input: column y {type:numerical} [y axis column name]
#input: column date {type:datetime; format:mm/dd/yyyy} [date column name]
#input: column_list numdata {type:numerical; table:t1} [numerical columns names]
#input: int numcomp = 2 {range:2-7} [number of components]
#input: bool center = true [number of components]
#input: string type = high {choices: ["high", "low"]} [type of filter]
#output: dataframe result {action:join(t1)} [pca components]
#output: graphics scatter [scatter plot]
```

## Filtering

You can use these fields to filter scripts with [smart search](../explore/search-filter-select/smart-search.md):

| Field       | Description                                                       |
|-------------|-------------------------------------------------------------------|
| ID          |                                                                   |
| name        |                                                                   |
| runs        | list of [FuncCall](../datagrok/concepts/functions/function-call.md) object |
| createdOn   |                                                                   |
| updatedOn   |                                                                   |
| author      | [User](../govern/user.md) object                                  |
| starredBy   | [User](../govern/user.md) object                                  |
| commentedBy | [User](../govern/user.md) object                                  |
| usedBy      | [User](../govern/user.md) object                                  |

## Videos

[Dev Meeting 1: Getting Started â€” Cross Language Support](https://www.youtube.com/watch?v=p7_qOU_IzLM&t=954s)

See also:

* [Grok scripting](../develop/under-the-hood/grok-script.md)
* [R](https://www.r-project.org/about.html)
* [Python](https://www.python.org)
* [Octave](https://octave.org/)
* [Julia](https://julialang.org)
* [JavaScript](https://www.javascript.com)
* [Packages](../develop/develop.md#packages)
* [JavaScript API](../develop/packages/js-api.md)
* [Functions](../datagrok/concepts/functions/functions.md)
* [Function call](../datagrok/concepts/functions/function-call.md)

Let's take a look at a simple R script that returns a square of the input parameter:

```
#name: RSquare
#language: r
#input: double x
#output: double result

result = x * x
```

## Using RichFunctionView input control

The **RichFunctionView** is an advanced input control,
allowing you to create complex full-featured interface for your script

It has all the features of basic script view, such as
[captions](scripting-for-non-developers.mdx#input-captions),
[viewers for outputs](scripting-for-non-developers.mdx#adding-viewers-for-output-dataframes)
etc.

In addition to it, you can use:

* [Viewers for input dataframes](#adding-input-dataframes-viewers)
* Grouping [inputs](#grouping-inputs) and [outputs](#grouping-outputs)
* Automatic [export](#exporting-to-a-file)
* Saving and accessing [history](#accessing-history)

To enable it, add following code to your script header:

```mdx-code-block
<Tabs>
<TabItem value="python" label="Python">
```

```python
# name: RichFunctionView Demo
# language: python
# editor: Compute:RichFunctionViewEditor
```

```mdx-code-block
</TabItem>
<TabItem value="js" label="Javascript">
```

```javascript
//name: RichFunctionView Demo
//language: javascript
//editor: Compute:RichFunctionViewEditor
```

```mdx-code-block
</TabItem>
<TabItem value="result" label="Result">
```

![rich-function-demo](rich-function-demo.gif)

```mdx-code-block
</TabItem>
</Tabs>
```

:::warning Package dependency

The `RichFunctionViewEditor` is a part of `Compute` package.
Ensure that `Compute` package is installed before working with `RichFunctionViewEditor`

:::

:::tip

Use Rich function view only when you are sure that the script works as expected.
Features of Rich function view affect GUI only and have no effect on computations.

:::

### Adding input dataframes viewers

You can add viewers for input dataframes. Using them, you can review your input data before starting computations.

```mdx-code-block
<Tabs>
<TabItem value="python" label="Python/R">
```

```python
# input: dataframe test { viewer: Line chart | Grid }
```

```mdx-code-block
</TabItem>
<TabItem value="js" label="JavaScript">
```

```javascript
//input: dataframe test { viewer: Line chart | Grid }
```

```mdx-code-block
</TabItem>
<TabItem value="result" label="Result">
```

![input-viewers](input-viewers.gif)

```mdx-code-block
</TabItem>
</Tabs>
```

### Grouping inputs

You can group script inputs into categories using the `category` tag.
Specified categories are rendered as separate blocks of the input form.

```mdx-code-block
<Tabs>
<TabItem value="python" label="Python/R">
```

```python
# input: dataframe tempData { caption: Temperature data; category: Experimental data }
# input: double initialPressure { caption: Initial pressure; category: Experimental data }
# input: double desiredPressure { caption: Goal pressure; category: Goals }
# input: double desiredHumidity { caption: Goal humidity; category: Goals }
# editor: Compute:RichFunctionViewEditor
```

```mdx-code-block
</TabItem>
<TabItem value="js" label="JavaScript">
```

```javascript
//input: dataframe tempData { caption: Temperature data; category: Experimental data }
//input: double initialPressure { caption: Initial pressure; category: Experimental data }
//input: double desiredPressure { caption: Goal pressure; category: Goals }
//input: double desiredHumidity { caption: Goal humidity; category: Goals }
//editor: Compute:RichFunctionViewEditor
```

:::tip

Here we also use `caption` tag to control input fields' labels.

:::

```mdx-code-block
</TabItem>
<TabItem value="result" label="Result">
```

![input-categories](input-categories.png)

```mdx-code-block
</TabItem>
</Tabs>
```

### Grouping outputs

You also can specify categories for output parameters.
In case of output parameters, `category` tag will specify the output tab used to show output parameters value.
Following code will generate UI with 3 output tabs:

```mdx-code-block
<Tabs>
<TabItem value="short" label="Short sample">
```

```javascript
//output: dataframe tempOnTime4 { viewer: Line chart; category: Experimental data }
//output: dataframe tempOnTime5 { viewer: Line chart | Line chart; category: Simulation data }
//output: double IC3 { category: Tab #3}
//output: double IC4 { category: Tab #3}
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript
//name: Grouping outputs
//language: javascript
//input: dataframe test { viewer: Line chart }
//input: double S1 = 50 { caption: S1 }
//output: dataframe tempOnTime4 { viewer: Line chart; category: Experimental data }
//output: double IC1 { category: Experimental data }
//output: dataframe tempOnTime5 { viewer: Line chart | Line chart; category: Simulation data }
//output: double IC2 { category: Simulation data }
//output: double IC3 { category: Tab #3 }
//output: double IC4 { category: Tab #3 }
//editor: Compute:RichFunctionViewEditor

tempOnTime4 = test;
tempOnTime5 = test;

IC1 = 10;
IC2 = 20;
IC3 = test.rowCount * 2;
IC4 = test.rowCount;
```

:::tip

View includes 4 tabs in total since there is a separate tab for input dataframe viewers.

:::

```mdx-code-block
</TabItem>
<TabItem value="result" label="Result">
```

![output-categories](output-categories.gif)

```mdx-code-block
</TabItem>
</Tabs>
```

### Exporting to a file

You may use one-click export feature to save entire script run data to a local file.
To generate export file,
Select <i class="fas fa-arrow-to-bottom"></i> **Export** icon on the top panel.
Automatic export saves all input and output values with their captions,
units and even viewers' screenshots.
This feature is available for all scripts using Rich function view by default.

<details>
<summary> Export file example </summary>
<div>

![export-demo](export-demo.gif)

</div>
</details>

### Accessing history

Each script run is saved on the server. Saved script run includes both input and output values of the run.
To review the history of runs, click on the <i class="fas fa-history"></i> **History** button on the top panel.

History panel appears on the right side. To load the run into the UI, click on the corresponding card.
The historical runs are immutable. Thus, if you load historical run and then run it again changing input values,
the platform will create a new historical run.

This is a feature of the Rich function view.

<!---

This part should be modes to advanced sections

## How to integrate script into third-party software

Datagrok was designed to be as extensible and easy to integrate with as possible, so out-of-the box
we get many platform integration capabilities such as authentication, data access, and many others. In addition to that,
there are some capabilities specific to models: [REST API](#rest-api) and
[embedding as iframe](#embedding-as-iframe).

### REST API

Once registered, each function gets assigned a REST API endpoint that allows external code to execute it by passing the
input parameters, along with the authentication token. This allows instantaneous deployment of scientific methods for
external consumption. To find our how to use it:

- Select the script in [Scripts section](https://public.datagrok.ai/scripts).
- Press F4 to open the context panel on the right.
- Expand the `REST` pane on it.

Both JavaScript and Curl samples are provided.

<details>
<summary> REST API panel </summary>
<div>

![rest-api](script-rest.png)

</div>
</details>

### JS API

JavaScript-based apps have access to the whole Datagrok platform via the [JS API](../develop/packages/js-api.md).

### Embedding as iframe

Sometimes, an app has to be included in the external web page.
The simplest way to achieve it is via the [iframe](https://www.w3schools.com/tags/tag_iframe.ASP) element. To embed a model, click on the hamburger icon in the top left corner, and choose `Embed...`.
You will see a dialog with the HTML code on top that you can use to embed this into external site. Note that you can change parameter values right in the URL.

<details>
<summary> Embedded iframe preview </summary>
<div>

![embed-as-iframe](embed-as-iframe.png)

</div>
</details>

### JavaScript

There is the set of [script examples](https://public.datagrok.ai/js/samples) available publicly.
Feel free to play around with them to explore different Datagrok capabilities.

You may to use debugging output. Output could be written:

- into DG interface (use `grok.shell.info()` / `grok.shell.warning()` / `grok.shell.error()`)
- into the console (use `console.log()` and developer console available by F12)

In addition, you can use built-in Inspector to see what's happening "under the hood" of the platform. To open Inspector, use `Alt+I` hotkey.
For example, Inspector provides an information about triggered events.

### Octave

Octave scripts are run in a separate container on server. This container includes following Octave packages:

- [symbolic](https://gnu-octave.github.io/packages/symbolic/)
- [optim](https://gnu-octave.github.io/packages/optim/)

Always provide `pkg load %PACKAGE_NAME%` in your scripts, since script runs are fully independent.

### Python

Here is a script header that is prepended to your script:

```
import os
import io
import json
import pandas as pd
import requests
from datetime import datetime, timedelta
```

See [Conda environments](scripting.md#conda-environments) for details.

### R

See [Renv environments](scripting.md#renv-environments) for details.

:::tip Pro tip

You may create and store scripts locally (as any other code)
using [packages](https://datagrok.ai/help/develop/#packages) feature.

:::\

<details>
<summary> To run a previously created script</summary>
<div>

- Find it in [Scripts secton](https://public.datagrok.ai/scripts).
- Right click on script card. Context menu appears.
- Choose **Run** action.

</div>
</details>

### Validating inputs

You can add custom validation on input values of your script. By default, the input form only validates that value is presented and has expected type.
A validator is a JS-function that accepts one parameter of any type and returns `null` (if validation passes) or error string (if valdiation fails).
You can add multiple validators on each input value.

```mdx-code-block
<Tabs>
<TabItem value="short" label="Short sample">
```

```javascript
//input: int rowCount {validators: ["isPositive"]}

grok.functions.register({
  signature: 'List<String> isPositive(int input)',
  run: (input) => input > 0 ? null : "Should be positive"
});
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript
//name: Custom validation sample
//description: Hello world script
//language: javascript
//input: int rowCount {validators: ["isPositive"]}

grok.functions.register({
  signature: 'List<String> isPositive(int input)',
  run: (input) => input > 0 ? null : "Should be positive"
});
```

```mdx-code-block
</TabItem>
<TabItem value="result" label="Result">
```

![builtin-validators](builtin-validators.gif)

```mdx-code-block
</TabItem>
</Tabs>
```

Use [Console](../datagrok/navigation/navigation.md#console) to execute it. Simply type
`<YOUR_USER_NAME>:RSquare(3)`:

```
 > RSquare(3)
   result: 9
```

The syntax for invoking the scripts is the same, regardless of the language used. In the same way, you can call Grok
Functions. See [Grok Scripting](../develop/under-the-hood//grok-script.md) for more details.

--->

You may specify different [options](../datagrok/concepts/functions/func-params-annotation.md#options) in header.
