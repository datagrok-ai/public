<!-- TITLE: Scripting -->
<!-- SUBTITLE: -->

# Scripting

Scripting is an integration mechanism with languages for statistical/mathematical computing. 
Scripting combines fast interactive visualizations and other features of the Datagrok platform 
with thousands of statistical packages and visualizations available in 
[R](https://www.r-project.org/about.html), [Python](https://www.python.org), [Octave](https://octave.org/),
[Julia](https://julialang.org), or [JavaScript](https://www.javascript.com).

## Header

Each script should have a header that contains some metadata, 
along with the information on input and output parameters. See all available [header parameters](#header-parameters). 
Each line starts with a comment. 

Let's take a look at a simple R script that returns a square of the input parameter:   

```
#name: RSquare
#language: r
#input: double x
#output: double result

result = x * x
```

In order to register a script, do **Tools | Scripting | New Script**, paste the code above, and click Save.
Congratulations, you've just written and published an R script and made it available to the whole community!

Use [Console](../overview/console.md) to execute it. Simply type "RSquare(3)":
```
 > RSquare(3)
   result: 9
```

The syntax for invoking the scripts is the same, regardless of the language used. In the same way, you can
call Grok Functions. See [Grok Scripting](../overview/grok-script.md) for more details.

## Running a script

First of all, a script can be executed right from the script editor (see picture below).

Other ways involve saving the script as a part of the project. In this case, it gets registered in the platform
as a [function](../overview/functions/function.md), and can be invoked in different ways:    
* From the [console](../overview/console.md)
* From the [data job](../access/data-job.md)
* From the [transformations editor](../transform/recipe-editor.md)
* From the function browser (**Help | Functions**)  

![Scripting](../uploads/gifs/scripting-visualization.gif "Scripting")

When a function is invoked with no explicitly specified parameters, a dialog is shown. The UI is
automatically generated by creating editors for each parameter. Depending on the metadata associated
with the parameters, the editor can be enriched by [validators](#validators), [choices](#choices),
and [suggestions](#suggestions). Validators, choices, and suggestions are [functions](../overview/functions/function.md),
that means they can be implemented in different ways (db query, script, etc), and reused. 

## Environments

Each script can be associated with the specific package configuration that it depends on. 
[Conda](https://docs.conda.io/en/latest/) is used as the environment management system. Environment configuration 
is stored in the default Conda format and can be 
[exported](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file) 
or [created manually](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#create-env-file-manually).

Configurations are stored in the same repository with the script, in the folder called `environments`
located under the repository root. Here is an 
[example of such configuration](https://github.com/datagrok-ai/public/tree/master/environments)
for the [Datagrok public repository](https://github.com/datagrok-ai/public). Also, a package can define
its own configurations as well ([see examples](https://github.com/datagrok-ai/public/tree/master/packages/PythonScripts)).

If the `#environment` tag in the script header is not specified, the script uses the configuration
defined in the `default.yaml`.  

This is how to define the "chemprop" environment in the script header: 

```
#environment: chemprop
```

### Parameter Validators

Validators check whether the value falls in the expected range, and provide visual cue if it does not.
To add a validator to a parameter, provide a comma-separated list of functions that will be invoked
each time a value is changed. A null indicates that the value is valid, anything else indicates an 
error which gets shown to the user.

A validator is a function that accepts one parameter of any time, and returns a string. Choice providers
are applicable only to string parameters.  

The following example adds a "containsLettersOnly" function to the "col" parameter:

```
#input: string s {validators: ["containsLettersOnly"]}
#input: column col {validators: ["containsMissingValues"]}
```

```js
grok.functions.register({
    signature: 'List<String> jsVal1(int input)',
    run: (input) => input < 11 ? null : "Error val1" });

grok.functions.register({
    signature: 'List<String> jsVal2(int input)',
    run: (input) => input > 9 ? null : "Error val2" });
```

```python
#name: Numbers
#language: python
#input: int count1 {validators: ["jsVal1", "jsVal2"]} [Number of cells in table]
#input: int count2 {validators: ["jsVal1"]} [Number of cells in table]
#input: int count3 {validators: ["jsVal2"]} [Number of cells in table]
```

![Script Parameter Validators](../uploads/features/script-param-validators.gif "Script Parameter Validators") 


### Parameter Choices

Use choices to provide the editor a list of values to choose from. When choices are provided,
the editor becomes a combo box. Choices can be either a fixed list, or a function that returns a list.

A choice provider is a function with no parameters that returns a list of strings.

The following example demonstrates two ways of defining choices:

```
#input: string fruit {choices: ["Apple", "Banana"]}
#input: string vegetable {choices: jsVeggies}
```

Here is a possible implementation of the "jsTypes" function used in the example:
```javascript
grok.functions.register({
    signature: 'List<String> jsVeggies()',
    run: () => ["Cucumber", "Cauliflower"]});
```

![Script Parameter Choices](../uploads/features/script-param-choices.gif "Script Parameter Choices") 


### Parameter Suggestions

Use parameter suggestions to help users enter a correct value. For instance, when entering
a product name, it might make sense to dynamically query a database for values starting with
the already entered text, and suggest to auto-complete the value. 

Suggestions are functions that take one string argument, and return a list of strings to be
suggested to user. Suggestions work only for string parameters.  

The following example helps user enter a country name by dynamically retrieving a list of names
from a web service: 

```python
#name: Sales by country
#language: python
#input: string country = uk {suggestions: jsSuggestCountryName}
```

```js
grok.functions.register({
  signature: 'List<String> jsSuggestCountryName(String text)',
  isAsync: true,
  run: async function(text) {
    let response = await fetch('https://restcountries.eu/rest/v2/name/' + text); 
    return response.status === 200 ? (await response.json()).map(country => country['name']) : [];
  }
});
```

![Script Parameter Suggestions](../uploads/features/script-param-suggestions.gif "Script Parameter Suggestions") 


## Header parameters

| Parameter   | Description                        |
|-------------|------------------------------------|
| name        | Name                               |
| description | Description                        |
| language    | Script language (see list below)   |
| help-url    | Help URL                           |
| reference   | Reference to research papers       |
| tags        | Tags                               |
| sample      | Name of a sample file              |
| input       | Input parameter                    |
| output      | Output parameter                   |
| environment | Environment name                   |
| condition   | Condition

Also it is possible to add custom parameter using "meta." prefix.

 
### Supported languages

| Language parameter value | Description    |
|--------------------------|----------------|
| r                        | R              |
| python                   | Python         |
| octave                   | Octave         |
| julia                    | Julia          |
| grok                     | Grok Scripting |
| javascript               | JavaScript     |

### Format template for 'input' and 'output':

```
#<direction>: <type> <name> = <value> {<option tag>:<value>; ...} [<description>]  
```
  
**direction** - parameter direction:

*   input
*   output

**type** - parameter type:

*   **dataframe** \- data frame
*   **int** \- integer scalar
*   **double** \- float scalar
*   **bool** \- boolean scalar
*   **graphics** \- graphics
*   **string** \- string
*   **column** \- column from selected table
*   **column_list** \- list of columns from selected table
*   **datetime** \- datetime
*   **file** \- file, variable in script contains path to file
*   **blob** \- blob, variable in script contains path to binary file

**name** - parameter name that will be used in script. Optional for graphical output.
  
**value** - used for scalar inputs as value and graphics outputs as index of graphical element. Optional.
  
**option tag** - list of default UI options for parameter. Optional.
  
**description** - parameter brief description, text. Optional.

### Options

#### Common

| Option      | Value                     | Description              |
|-------------|---------------------------|--------------------------|
| validators  | List separated with comma | List of named validators |

Named validators:
* containsMissingValues
* columnName - checks if table contains current column name
* columnIsNumerical
* columnIsCategorical

Validator also can be any function that that returns "null" if validation is right, or string with error message 
otherwise.


#### For "dataframe" type

| Option      | Value       | Description                             |
|-------------|-------------|-----------------------------------------|
| columns     | numerical   | Only numerical columns will be loaded   |
| categorical | categorical | Only categorical columns will be loaded |

#### For "column" and "column_list" types

| Option     | Value                           | Description                                                  |
|------------|---------------------------------|--------------------------------------------------------------|
| type       | numerical                       | In dialog will be showed only numerical types columns        |
| type       | categorical                     | In dialog will be showed only categorical types columns      | 
| type       | dateTime                        | In dialog will be showed only dateTime columns               |
| format     | MM/dd/yyyy                      | Datetime format, for dateTime columns and datetime type only |
| allowNulls | true/false                      | Adds validation of missing values presents                   |
| action     | join("table parameter name")    | Joins result to specified table, for output parameters only                 | 
| action     | replace("table parameter name") | Replaces result with columns in specified table, for output parameters only | 


#### For "string" type

| Option      | Value                     | Description                          |
|-------------|---------------------------|--------------------------------------|
| choices     | List separated with comma, or function name that returns list of strings | List of choices for string parameter |
| suggestions | Function name that returns list of strings with string input corresponding to script input | List of suggestions for string parameter |
 
Header line examples: 
```
#input: string choices = int {choices: ["string", "int", "bool"]}
#input: string choices = int {choices: JsTypes}

#input: string option = int {suggestions: JsSuggestType}
```


### Examples:

```
#input: dataframe t1 {columns:numerical} [First input data table]
#input: dataframe t2 {columns:numerical} [Second input data table]
#input: column x {type:numerical; table:T1} [X axis column name]
#input: column y {type:numerical} [Y axis column name]
#input: column date {type:dateTime; format:MM/dd/yyyy} [Date column name]
#input: column_list numData {type:numerical; table:T1} [Numerical columns names]
#input: int numComp = 2 {range:2-7} [Number of components]
#input: bool center = TRUE [Number of components]
#input: string type = high {choices: ["high", "low"]} [Type of filter]
#output: dataframe result {action:join(t1)} [PCA components]
#output: graphics scatter [Scatter plot]
```

## Filtering

You can use these fields to filter scripts with [smart search](../overview/smart-search.md):

| Field       | Description                     |
|-------------|---------------------------------|
| id          |                                 |
| name        |                                 |
| runs        | list of [FuncCall](../overview/functions/function-call.md) object|
| createdOn   |                                 |
| updatedOn   |                                 | 
| author      | [User](../govern/user.md) object |
| starredBy   | [User](../govern/user.md) object |
| commentedBy | [User](../govern/user.md) object |
| usedBy      | [User](../govern/user.md) object |

See also:

  * [Grok Scripting](../overview/grok-script.md)
  * [R](https://www.r-project.org/about.html)
  * [Python](https://www.python.org)
  * [Julia](https://julialang.org)
  * [JavaScript](https://www.javascript.com)
