#file: noinspection YAMLIncompatibleTypes
AWSTemplateFormatVersion: "2010-09-09"

Description: Datagrok template to deploy all components to ECS Fargate

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Access configuration
        Parameters:
          - InternetSubnetAllow
          - InternetSubnetAllow2
          - InternetSubnetAllow3
      - Label:
          default: GPU configuration
        Parameters:
          - GpuRequired
          - GpuAMI
          - GpuInstanceType
    ParameterLabels:
      InternetSubnetAllow:
        default: 'InternetSubnetAllow: Allow connect from CIDR'
      InternetSubnetAllow2:
        default: 'InternetSubnetAllow2: Allow connect from additional CIDR (Optional)'
      InternetSubnetAllow3:
        default: 'InternetSubnetAllow3: Allow connect from additional CIDR (Optional)'
      GpuRequired:
        default: GPU required
      GpuAMI:
        default: GPU AMI
      GpuInstanceType:
        default: GPU Instance Type

Parameters:
  InternetSubnetAllow:
    Description: Subnet for access to Datagrok endpoint. Set CIDR to 0.0.0.0/0 to allow all IP addresses access, or another CIDR range.
    Type: String
    AllowedPattern: '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+'

  InternetSubnetAllow2:
    Description: Additional subnet for access to Datagrok endpoint. You can omit this parameter is already specified InternetSubnetAllow.
    Type: String
    Default: ""
    AllowedPattern: (^$)|([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+)

  InternetSubnetAllow3:
    Description: Additional subnet for access to Datagrok endpoint. You can omit this parameter is already specified InternetSubnetAllow.
    Type: String
    Default: ""
    AllowedPattern: (^$)|([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+)

  Postfix:
    Description: URL postfix for backward compatibility. Leave blank for new installations
    Type: String

  GpuRequired:
    Description: Set to true if you want to run GPU workloads.
    Type: String
    AllowedValues:
      - "true"
      - "false"
    Default: "false"

  GpuAMI:
    Description: The AMI ID for the GPU instance. Check https://docs.aws.amazon.com/AmazonECS/latest/developerguide/retrieve-ecs-optimized_AMI.html for options
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2/gpu/amzn2-ami-ecs-gpu-hvm-2.0.20241017-x86_64-ebs/image_id

  GpuInstanceType:
    Description: The instance type for the GPU instance.
    Type: String
    AllowedValues:
      - p3.2xlarge
      - p3.8xlarge
      - p3.16xlarge
      - p3dn.24xlarge
      - p5.48xlarge
      - g3s.xlarge
      - g3.4xlarge
      - g3.8xlarge
      - g3.16xlarge
      - g4dn.xlarge
      - g4dn.2xlarge
      - g4dn.4xlarge
      - g4dn.8xlarge
      - g4dn.12xlarge
      - g4dn.16xlarge
      - g5.xlarge
      - g5.2xlarge
      - g5.4xlarge
      - g5.8xlarge
      - g5.16xlarge
      - g5.12xlarge
      - g5.24xlarge
      - g5.48xlarge
      - g6.xlarge
      - g6.2xlarge
      - g6.4xlarge
      - g6.8xlarge
      - g6.16xlarge
      - g6.12xlarge
      - g6.24xlarge
      - g6.48xlarge
      - g6.metal
      - gr6.4xlarge
      - g6e.xlarge
      - g6e.2xlarge
      - g6e.4xlarge
      - g6e.8xlarge
      - g6e.16xlarge
      - g6e.12xlarge
    Default: g4dn.xlarge

Rules:
  InternetSubnetAllow:
    RuleCondition: !Or
      - !Not
        - !Equals
          - !Ref InternetSubnetAllow2
          - ""
      - !Not
        - !Equals
          - !Ref InternetSubnetAllow3
          - ""
    Assertions:
      - Assert: !Not
          - !Equals
            - !Ref InternetSubnetAllow
            - !Ref InternetSubnetAllow2
        AssertDescription: Subnets for access to Datagrok client endpoints must be unique (InternetSubnetAllow and InternetSubnetAllow2 match)
      - Assert: !Not
          - !Equals
            - !Ref InternetSubnetAllow
            - !Ref InternetSubnetAllow3
        AssertDescription: Subnets for access to Datagrok client endpoints must be unique (InternetSubnetAllow and InternetSubnetAllow3 match)
      - Assert: !Not
          - !Equals
            - !Ref InternetSubnetAllow2
            - !Ref InternetSubnetAllow3
        AssertDescription: Subnets for access to Datagrok client endpoints must be unique (InternetSubnetAllow2 and InternetSubnetAllow3 match)

Conditions:
  AccessFromNatGW: !And
    - !Condition InternetIngressAccess
    - !Condition InternetEgressAccess

  AccessFromInternetSubnetAllow2: !Not
    - !Equals
      - !Ref InternetSubnetAllow2
      - ""

  AccessFromInternetSubnetAllow3: !Not
    - !Equals
      - !Ref InternetSubnetAllow3
      - ""

  GpuRequired: !Equals
    - !Ref GpuRequired
    - "true"

Resources:
  DatagrokDBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: !Sub ${AWS::StackName} Datagrok DatagrokDB Subnet Group
      DBSubnetGroupName: !Sub
        - ${AWS::StackName}${postfix}-rds-subnet
        - postfix: !Ref Postfix
      SubnetIds:
        - !Ref DatagrokDataSubnet1
        - !Ref DatagrokDataSubnet2
      Tags:
        - Key: datagrok.component
          Value: rds

  DatagrokDBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok DB Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-rds
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      VpcId: !Ref DatagrokVPC
      SecurityGroupEgress: []
      SecurityGroupIngress:
        - Description: !Sub ${AWS::StackName} Allow connection from datagrok server
          FromPort: 5432
          ToPort: 5432
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow connection from JKG server
          FromPort: 5432
          ToPort: 5432
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref CvmSecurityGroup

  CvmSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok CVM Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-cvm
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: cvm
      VpcId: !Ref DatagrokVPC

  CvmSecurityGroupInternalCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication within network CVM
      GroupId: !Ref CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref CvmSecurityGroup

  CvmSecurityGroupCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication from Datagrok to CVM components
      GroupId: !Ref CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref DatagrokSecurityGroup

  CvmSecurityGroupALBIntCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication from internal ALB to CVM components
      GroupId: !Ref CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref CvmALBIntSecurityGroup

  CvmALBIntSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok CVM ALB Internal Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-cvm-alb-int
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: cvm
      VpcId: !Ref DatagrokVPC
      SecurityGroupIngress:
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to CVM
          FromPort: 8090
          ToPort: 8090
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections to HTTP
          FromPort: 80
          ToPort: 80
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
      SecurityGroupEgress:
        - Description: !Sub ${AWS::StackName} CVM egress rules
          DestinationSecurityGroupId: !Ref CvmSecurityGroup
          FromPort: 0
          ToPort: 65535
          IpProtocol: TCP

  CvmEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: !Sub ${AWS::StackName} CVM egress rules
      DestinationSecurityGroupId: !Ref CvmSecurityGroup
      FromPort: 0
      GroupId: !Ref CvmALBIntSecurityGroup
      IpProtocol: TCP
      ToPort: 65535

  DatagrokSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      VpcId: !Ref DatagrokVPC

  DatagrokALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok ALB Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-alb
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      VpcId: !Ref DatagrokVPC

  DatagrokSecurityGroupInternalCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication within network Datagrok
      GroupId: !Ref DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref DatagrokSecurityGroup

  DatagrokSecurityGroupCvmCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication from CVM to Datagrok components
      GroupId: !Ref DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref CvmSecurityGroup

  DatagrokSecurityGroupALBCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication from ALB to Datagrok components
      GroupId: !Ref DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref DatagrokALBSecurityGroup

  DatagrokSecurityGroupIntALBCommunications:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: !Sub ${AWS::StackName} Allow communication from internal ALB to Datagrok components
      GroupId: !Ref DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId: !Ref DatagrokALBIntSecurityGroup

  DatagrokEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok egress rules
      DestinationSecurityGroupId: !Ref DatagrokSecurityGroup
      FromPort: 0
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 65535

  Datagrok80Ingress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref InternetSubnetAllow
      Description: !Sub ${AWS::StackName} 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80

  Datagrok443Ingress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref InternetSubnetAllow
      Description: !Sub ${AWS::StackName} 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443

  Datagrok80Ingress2:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref InternetSubnetAllow2
      Description: !Sub ${AWS::StackName} 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Condition: AccessFromInternetSubnetAllow2

  Datagrok443Ingress2:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref InternetSubnetAllow2
      Description: !Sub ${AWS::StackName} 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Condition: AccessFromInternetSubnetAllow2

  Datagrok80Ingress3:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref InternetSubnetAllow3
      Description: !Sub ${AWS::StackName} 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Condition: AccessFromInternetSubnetAllow3

  Datagrok443Ingress3:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref InternetSubnetAllow3
      Description: !Sub ${AWS::StackName} 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Condition: AccessFromInternetSubnetAllow3

  Datagrok80IngressVPC:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref CIDR
      Description: !Sub ${AWS::StackName} VPC 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80

  Datagrok443IngressVPC:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref CIDR
      Description: !Sub ${AWS::StackName} VPC 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443

  Datagrok80IngressNatGW:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Sub
        - ${ip}/32
        - ip: !Ref DatagrokNatGatewayEIP
      Description: !Sub ${AWS::StackName} NatGW 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Condition: AccessFromNatGW

  Datagrok443IngressNatGW:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Sub
        - ${ip}/32
        - ip: !Ref DatagrokNatGatewayEIP
      Description: !Sub ${AWS::StackName} NatGW 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId: !Ref DatagrokALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Condition: AccessFromNatGW

  DatagrokALBIntSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok ALB Internal Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-alb-int
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      VpcId: !Ref DatagrokVPC
      SecurityGroupIngress:
        - Description: !Sub ${AWS::StackName} Allow internal connections from CVM to Datagrok
          FromPort: 8080
          ToPort: 8080
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref CvmSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from CVM to Grok Pipe
          FromPort: 3000
          ToPort: 3000
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref CvmSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to Datagrok
          FromPort: 8080
          ToPort: 8080
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to Grok Connect
          FromPort: 1234
          ToPort: 1234
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to Grok Spawner
          FromPort: 8000
          ToPort: 8000
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to Grok Pipe
          FromPort: 3000
          ToPort: 3000
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to Rabbitmq
          FromPort: 5672
          ToPort: 5672
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
      SecurityGroupEgress:
        - Description: !Sub ${AWS::StackName} Datagrok egress rules
          DestinationSecurityGroupId: !Ref DatagrokSecurityGroup
          FromPort: 0
          ToPort: 65535
          IpProtocol: TCP

  DatagrokECSPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok policy for ECS Services
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Effect: Allow
            Resource:
              - !GetAtt DatagrokLogGroup.Arn
              - !Sub
                - ${log}:log-stream:*
                - log: !GetAtt DatagrokLogGroup.Arn
          - Action:
              - ecr:GetAuthorizationToken
            Effect: Allow
            Resource: '*'
          - Action:
              - ecr:BatchCheckLayerAvailability
              - ecr:BatchGetImage
              - ecr:GetDownloadUrlForLayer
            Effect: Allow
            Resource:
              - arn:aws:ecr:us-east-1:709825985650:repository/datagrok/*
              - !Sub arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
      ManagedPolicyName: !Sub ${AWS::StackName}ECSPolicy-${AWS::Region}

  DatagrokTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: {}
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - !Ref DatagrokECSPolicy

  DatagrokJupyterKernelGatewayService:
    Type: AWS::ECS::Service
    Properties:
      Cluster: !GetAtt CvmCluster.Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref CvmSecurityGroup
          Subnets:
            - !Ref DatagrokPrivateSubnet1
            - !Ref DatagrokPrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      Tags:
        - Key: datagrok.component
          Value: cvm
        - Key: datagrok.service
          Value: jupyter_kernel_gateway
      TaskDefinition: !Ref DatagrokJupyterKernelGatewayTaskDefinition

  DatagrokJupyterKernelGatewayTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Command:
            - !Sub ${AWS::Region}.compute.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Searchdomain
                - domain
              repo: !FindInMap
                - Images
                - Searchdomain
                - repo
              tag: !FindInMap
                - Images
                - Searchdomain
                - version
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: jkg
          MemoryReservation: 100
          ReadonlyRootFilesystem: true
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - JKG
                - domain
              repo: !FindInMap
                - Images
                - JKG
                - repo
              tag: !Ref JKGVersion
          Environment:
            - Name: GROK_PARAMETERS
              Value: !Sub
                - '{ "queueSettings":{ "amqpHost":"${amqpHost}", "amqpPort": 5672, "amqpUser":"guest", "amqpPassword":"${amqpPassword}", "pipeHost":"${pipeHost}", "pipeKey":"${grokPipeApiKey}" }}'
                - amqpHost: !Sub rabbit.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
                  pipeHost: !Sub pipe.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
                  amqpPassword: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref RabbitMQPassword
                  grokPipeApiKey: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:apikey}}'
                    - secret: !Ref GrokPipeApiKeySecret
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: jkg
          MemoryReservation: 2048

          #          ReadonlyRootFilesystem: true
          Name: jupyter_kernel_gateway
          PortMappings:
            - ContainerPort: 5005
              HostPort: 5005
              Protocol: tcp
            - ContainerPort: 8888
              HostPort: 8888
              Protocol: tcp
      Cpu: "1024"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}-cvm-jupyter_kernel_gateway
        - postfix: !Ref Postfix
      Memory: "3072"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      EphemeralStorage:
        SizeInGiB: 50

  DatagrokCloudMap:
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Properties:
      Description: !Sub ${AWS::StackName} Service Map for Datagrok
      Name: !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
      Vpc: !Ref DatagrokVPC

  DatagrokInsightsLogGroup:
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub
        - /aws/ecs/containerinsights/${cluster_name}/performance
        - cluster_name: !Ref DatagrokCluster
      RetentionInDays: 7

  DatagrokCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub
        - ${AWS::StackName}${postfix}
        - postfix: !Ref Postfix
      Tags:
        - Key: datagrok.component
          Value: datagrok
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  CvmInsightsLogGroup:
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub
        - /aws/ecs/containerinsights/${cluster_name}/performance
        - cluster_name: !Ref CvmCluster
      RetentionInDays: 1

  CvmCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub
        - ${AWS::StackName}${postfix}-cvm
        - postfix: !Ref Postfix
      Tags:
        - Key: datagrok.component
          Value: cvm
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  DatagrokService:
    Type: AWS::ECS::Service
    DependsOn:
      - DatagrokTCP80Listener
      - DatagrokTCP443Listener
      - DatagrokTCP8080IntListener
      - DatagrokS3
      - DatagrokDB
    Properties:
      Cluster: !GetAtt DatagrokCluster.Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: datagrok
          ContainerPort: 8080
          TargetGroupArn: !Ref DatagrokTCP8080TargetGroup
        - ContainerName: datagrok
          ContainerPort: 8080
          TargetGroupArn: !Ref DatagrokTCP8080IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref DatagrokSecurityGroup
          Subnets:
            - !Ref DatagrokPrivateSubnet1
            - !Ref DatagrokPrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn: !GetAtt DatagrokServiceDiscoveryEntry.Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: datagrok
      TaskDefinition: !Ref DatagrokTaskDefinition

  DatagrokServiceDiscoveryEntry:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok datagrok service discovery entry in Cloud Map
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: datagrok
      NamespaceId: !Ref DatagrokCloudMap

  DatagrokTCP443Listener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn: !Ref DatagrokTCP8080TargetGroup
          Type: forward
      LoadBalancerArn: !Ref DatagrokLoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref DatagrokArnSSLCertificate

  DatagrokTCP8080IntListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn: !Ref DatagrokTCP8080IntTargetGroup
          Type: forward
      LoadBalancerArn: !Ref DatagrokLoadBalancerInt
      Port: 8080
      Protocol: HTTP

  DatagrokTCP8080TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub
        - ${AWS::StackName}${postfix}
        - postfix: !Ref Postfix
      Port: 8080
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: ip
      VpcId: !Ref DatagrokVPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /api/admin/health
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5

  DatagrokTCP8080IntTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub
        - ${AWS::StackName}${postfix}-i
        - postfix: !Ref Postfix
      Port: 8080
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: ip
      VpcId: !Ref DatagrokVPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /api/admin/health
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5

  DatagrokTCP80Listener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - RedirectConfig:
            Port: "443"
            Protocol: HTTPS
            StatusCode: HTTP_301
          Type: redirect
      LoadBalancerArn: !Ref DatagrokLoadBalancer
      Port: 80
      Protocol: HTTP

  GrokConnectService:
    Type: AWS::ECS::Service
    DependsOn:
      - GrokConnectTCP1234IntListener
    Properties:
      Cluster: !GetAtt DatagrokCluster.Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: grok_connect
          ContainerPort: 1234
          TargetGroupArn: !Ref GrokConnectTCP1234IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref DatagrokSecurityGroup
          Subnets:
            - !Ref DatagrokPrivateSubnet1
            - !Ref DatagrokPrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn: !GetAtt GrokConnectServiceDiscoveryEntry.Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_connect
      TaskDefinition: !Ref GrokConnectTaskDefinition

  GrokConnectServiceDiscoveryEntry:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok grok_connect service discovery entry in Cloud Map
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_connect
      NamespaceId: !Ref DatagrokCloudMap

  GrokConnectTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Command:
            - !Sub ${AWS::Region}.compute.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Searchdomain
                - domain
              repo: !FindInMap
                - Images
                - Searchdomain
                - repo
              tag: !FindInMap
                - Images
                - Searchdomain
                - version
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_connect
          MemoryReservation: 100
          ReadonlyRootFilesystem: true
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Environment:
            - Name: GROK_CONNECT_PORT
              Value: 1234
            - Name: CONNECTION_POOL_MAXIMUM_SIZE
              Value: 50
            - Name: CONNECTION_POOL_IDLE_TIMEOUT
              Value: 300000
          Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - GrokConnect
                - domain
              repo: !FindInMap
                - Images
                - GrokConnect
                - repo
              tag: !Ref GrokConnectVersion
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_connect
          MemoryReservation: 1024
          ReadonlyRootFilesystem: true
          Name: grok_connect
          PortMappings:
            - ContainerPort: 1234
              HostPort: 1234
              Protocol: tcp
      Cpu: "1024"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}-grok_connect
        - postfix: !Ref Postfix
      Memory: "2048"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE

  GrokConnectTCP1234IntListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn: !Ref GrokConnectTCP1234IntTargetGroup
          Type: forward
      LoadBalancerArn: !Ref DatagrokLoadBalancerInt
      Port: 1234
      Protocol: HTTP

  GrokConnectTCP1234IntTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup

    #Grok_pipe
    Properties:
      Name: !Sub ${AWS::StackName}-gcon-i
      Port: 1234
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: ip
      VpcId: !Ref DatagrokVPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /health
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5

  GrokPipeService:
    Type: AWS::ECS::Service
    DependsOn:
      - GrokPipeTCP3000IntListener
    Properties:
      Cluster: !GetAtt DatagrokCluster.Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: grok_pipe
          ContainerPort: 3000
          TargetGroupArn: !Ref GrokPipeTCP3000IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref DatagrokSecurityGroup
          Subnets:
            - !Ref DatagrokPrivateSubnet1
            - !Ref DatagrokPrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn: !GetAtt GrokPipeServiceDiscoveryEntry.Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_pipe
      TaskDefinition: !Ref GrokPipeTaskDefinition

  GrokPipeServiceDiscoveryEntry:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok grok_pipe service discovery entry in Cloud Map
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_pipe
      NamespaceId: !Ref DatagrokCloudMap

  GrokPipeTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Command:
            - !Sub ${AWS::Region}.compute.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Searchdomain
                - domain
              repo: !FindInMap
                - Images
                - Searchdomain
                - repo
              tag: !FindInMap
                - Images
                - Searchdomain
                - version
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_pipe
          MemoryReservation: 100
          ReadonlyRootFilesystem: true
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - GrokPipe
                - domain
              repo: !FindInMap
                - Images
                - GrokPipe
                - repo
              tag: !Ref GrokPipeVersion
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_pipe
          MemoryReservation: 1024
          ReadonlyRootFilesystem: true
          Name: grok_pipe
          PortMappings:
            - ContainerPort: 3000
              HostPort: 3000
              Protocol: tcp
          Environment:
            - Name: API_KEY
              Value: !Sub
                - ${apiKey}
                - apiKey: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:apikey}}'
                    - secret: !Ref GrokPipeApiKeySecret
      Cpu: "1024"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}-grok_pipe
        - postfix: !Ref Postfix
      Memory: "2048"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE

  GrokPipeTCP3000IntListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn: !Ref GrokPipeTCP3000IntTargetGroup
          Type: forward
      LoadBalancerArn: !Ref DatagrokLoadBalancerInt
      Port: 3000
      Protocol: HTTP

  GrokPipeTCP3000IntTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${AWS::StackName}-gpipe-i
      Port: 3000
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: ip
      VpcId: !Ref DatagrokVPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /info
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5

  RabbitMQPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Automatically generated RabbitMQ password
      GenerateSecretString:
        SecretStringTemplate: '{"password": "password"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludeCharacters: '"@/\!#$%^&*()-_=+[]{}|;:,.<>?`~'

  GrokPipeApiKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub ${AWS::StackName}-GrokPipeApiKey
      Description: Automatically generated API key for Datagrok
      GenerateSecretString:
        SecretStringTemplate: '{"apikey": ""}'
        GenerateStringKey: apikey
        PasswordLength: 32
        ExcludeCharacters: '"@/\!#$%^&*()-_=+[]{}|;:,.<>?`~'

  RabbitmqService:
    Type: AWS::ECS::Service
    DependsOn:
      - RabbitmqTCP5672Listener
    Properties:
      Cluster: !GetAtt DatagrokCluster.Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: rabbitmq
          ContainerPort: 5672
          TargetGroupArn: !Ref RabbitmqTCP5672TargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref RabbitMQSecurityGroup
          Subnets:
            - !Ref DatagrokPrivateSubnet1
            - !Ref DatagrokPrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn: !GetAtt RabbitmqServiceDiscoveryEntry.Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: rabbitmq
      TaskDefinition: !Ref RabbitmqTaskDefinition

  RabbitmqServiceDiscoveryEntry:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok rabbitmq service discovery entry in Cloud Map
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: rabbitmq
      NamespaceId: !Ref DatagrokCloudMap

  RabbitmqTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Command:
            - !Sub ${AWS::Region}.compute.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Searchdomain
                - domain
              repo: !FindInMap
                - Images
                - Searchdomain
                - repo
              tag: !FindInMap
                - Images
                - Searchdomain
                - version
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: rabbitmq
          MemoryReservation: 100
          ReadonlyRootFilesystem: true
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Rabbitmq
                - domain
              repo: !FindInMap
                - Images
                - Rabbitmq
                - repo
              tag: !Ref RabbitmqVersion
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: rabbitmq
          MemoryReservation: 1024
          ReadonlyRootFilesystem: true
          Name: rabbitmq
          PortMappings:
            - ContainerPort: 5672
              HostPort: 5672
              Protocol: tcp
            - ContainerPort: 15672
              HostPort: 15672
              Protocol: tcp
          Environment:
            - Name: RABBITMQ_DEFAULT_USER
              Value: guest
            - Name: RABBITMQ_DEFAULT_PASS
              Value: !Sub
                - ${amqpPassword}
                - amqpPassword: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref RabbitMQPassword
      Cpu: "1024"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}-rabbitmq
        - postfix: !Ref Postfix
      Memory: "2048"
      EphemeralStorage:
        SizeInGiB: 21
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE

  RabbitMQSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${AWS::StackName} Datagrok Security Group
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      VpcId: !Ref DatagrokVPC
      SecurityGroupIngress:
        - Description: Allow AMQP traffic from VPC
          IpProtocol: tcp
          FromPort: 5672
          ToPort: 5672
          CidrIp: !Ref CIDR
        - Description: Allow RabbitMQ Management UI (HTTP 15672) from VPC
          IpProtocol: tcp
          FromPort: 15672
          ToPort: 15672
          CidrIp: !Ref CIDR
      SecurityGroupEgress:
        - Description: Allow all outbound traffic
          IpProtocol: "-1"
          CidrIp: 0.0.0.0/0

  RabbitmqTCP5672TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${AWS::StackName}-RabbitMQ-5672
      Port: 5672
      Protocol: TCP
      TargetType: ip
      VpcId: !Ref DatagrokVPC
      HealthCheckProtocol: TCP
      HealthCheckPort: 5672
      HealthCheckIntervalSeconds: 30
      HealthyThresholdCount: 3
      UnhealthyThresholdCount: 3

  RabbitmqNLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${AWS::StackName}-RabbitMQ-NLB
      Scheme: internal
      Type: network
      Subnets:
        - !Ref DatagrokPrivateSubnet1
        - !Ref DatagrokPrivateSubnet2
      SecurityGroups:
        - !Ref RabbitmqSecurityGroup

  RabbitmqTCP5672Listener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref RabbitmqNLB
      Protocol: TCP
      Port: 5672
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref RabbitmqTCP5672TargetGroup

  RabbitmqSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref DatagrokVPC
      GroupDescription: Security Group for RabbitMQ
      SecurityGroupIngress:
        - Description: !Sub ${AWS::StackName} Allow internal connections from Datagrok to Rabbitmq
          FromPort: 5672
          ToPort: 5672
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref DatagrokSecurityGroup
        - Description: !Sub ${AWS::StackName} Allow internal connections from CVM to Rabbitmq
          FromPort: 5672
          ToPort: 5672
          IpProtocol: TCP
          SourceSecurityGroupId: !Ref CvmSecurityGroup

  DatagrokDbUser:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin User First-login password
      GenerateSecretString:
        SecretStringTemplate: '{"user": "dg"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 32
        ExcludePunctuation: true

  DatagrokDbAdminUser:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin User First-login password
      GenerateSecretString:
        SecretStringTemplate: '{"user": "superuser"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 32
        ExcludePunctuation: true

  DatagrokAdminPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin user first-login password
      GenerateSecretString:
        SecretStringTemplate: '{"user": "admin"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 16
        ExcludePunctuation: true

  DatagrokAdminDevKey:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin user developer key
      GenerateSecretString:
        SecretStringTemplate: '{"user": "admin"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 24
        ExcludePunctuation: true

  DatagrokDB:
    DeletionPolicy: Snapshot
    UpdateReplacePolicy: Delete
    Type: AWS::RDS::DBInstance
    Properties:
      AllocatedStorage: "50"
      AllowMajorVersionUpgrade: false
      AutoMinorVersionUpgrade: true
      BackupRetentionPeriod: 3
      DBInstanceClass: db.t3.large
      DBInstanceIdentifier: !Sub
        - ${AWS::StackName}${postfix}-rds
        - postfix: !Ref Postfix
      DBName: datagrok
      DBSubnetGroupName: !Ref DatagrokDBSubnetGroup
      DeleteAutomatedBackups: true
      DeletionProtection: false
      Engine: postgres
      EngineVersion: "17"
      MasterUsername: !Sub
        - '{{resolve:secretsmanager:${secret}:SecretString:user}}'
        - secret: !Ref DatagrokDbAdminUser
      MasterUserPassword: !Sub
        - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
        - secret: !Ref DatagrokDbAdminUser
      MultiAZ: false
      Port: "5432"
      PubliclyAccessible: false
      StorageEncrypted: true
      Tags:
        - Key: datagrok.component
          Value: datagrok
      VPCSecurityGroups:
        - !Ref DatagrokDBSecurityGroup
      EnableIAMDatabaseAuthentication: true

  DatagrokS3:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: true
            ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      BucketName: !Sub
        - ${AWS::StackName}${postfix}-s3-${uuid}
        - postfix: !Ref Postfix
          uuid: !Select
            - 2
            - !Split
              - /
              - !Ref AWS::StackId
      ObjectLockEnabled: false
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: datagrok.component
          Value: datagrok

  DatagrokS3Policy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref DatagrokS3
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - !If
            - UseVPCEndpoint
            - Action:
                - s3:PutObject
                - s3:GetObject
                - s3:DeleteObject
              Condition:
                StringNotEquals:
                  aws:SourceVpce: !Ref DatagrokS3VPCEndpoint
                  aws:PrincipalArn:
                    - !Sub arn:aws:iam::${AWS::AccountId}:root
                    - !Ref DatagrokS3EmptyLambdaRole
              Effect: Deny
              Principal: '*'
              Resource:
                - !GetAtt DatagrokS3.Arn
                - !Sub
                  - ${bucket}/*
                  - bucket: !GetAtt DatagrokS3.Arn
            - !Ref AWS::NoValue
          - Principal: '*'
            Action: '*'
            Effect: Deny
            Resource:
              - !GetAtt DatagrokS3.Arn
              - !Sub
                - ${bucket}/*
                - bucket: !GetAtt DatagrokS3.Arn
            Condition:
              Bool:
                aws:SecureTransport: false

  DatagrokS3EmptyLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-s3-lambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}S3EmptyLambdaFunction-*:*
              - Action:
                  - s3:GetObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Effect: Allow
                Resource:
                  - !GetAtt DatagrokS3.Arn
                  - !Sub
                    - ${bucket}/*
                    - bucket: !GetAtt DatagrokS3.Arn

  DatagrokS3EmptyLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Empty S3 bucket on CFN deletion for Datagrok
      Code:
        ZipFile: |
          import boto3
          import cfnresponse


          def handler(event, context):
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  status = 0

                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          s3.Object(bucket.name, obj.key).delete()
                      status = 201

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Status': status})
              except Exception as e:
                  print(type(e).__name__, e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Exception': f"{type(e).__name__} {e}"})
      Handler: index.handler
      Runtime: python3.10
      Role: !GetAtt DatagrokS3EmptyLambdaRole.Arn
      MemorySize: 128
      Timeout: 600

  DatagrokS3EmptyLambdaFunctionDatagrokLogGroup:
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub
        - /aws/lambda/${function_name}
        - function_name: !Ref DatagrokS3EmptyLambdaFunction
      RetentionInDays: 1

  DatagrokS3Empty:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - DatagrokS3EmptyLambdaFunctionDatagrokLogGroup
    Properties:
      BucketName: !Ref DatagrokS3
      ServiceToken: !GetAtt DatagrokS3EmptyLambdaFunction.Arn

  DatagrokTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Command:
            - !Sub ${AWS::Region}.compute.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Searchdomain
                - domain
              repo: !FindInMap
                - Images
                - Searchdomain
                - repo
              tag: !FindInMap
                - Images
                - Searchdomain
                - version
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: datagrok
          MemoryReservation: 100
          ReadonlyRootFilesystem: true
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Environment:
            - Name: GROK_MODE
              Value: auto
            - Name: GROK_PARAMETERS
              Value: !Sub
                - '{ "amazonStorageRegion": "${AWS::Region}", "amazonStorageBucket": "${bucket}", "dbServer": "${dbServer}", "dbPort": "${dbPort}", "db": "datagrok", "dbLogin": "${dbLogin}", "dbPassword": "${dbPassword}", "dbAdminLogin": "${dbAdminLogin}", "dbAdminPassword": "${dbAdminPassword}", "dbSsl": true, "deployDemo": false, "deployTestDemo": false, "adminPassword": "${adminPassword}", "adminDevKey": "${adminDevKey}", "queueSettings":{ "amqpHost":"${amqpHost}", "amqpPort": 5672, "amqpUser":"guest", "amqpPassword":"${amqpPassword}", "pipeHost":"${pipeHost}", "pipeKey":"${grokPipeApiKey}" }, "dockerSettings":{ "grokSpawnerApiKey":"test-x-api-key", "grokSpawnerHost":"${grokSpawnerHost}", "grokSpawnerPort":8000, "imageBuildTimeoutMinutes":30, "proxyRequestTimeout":60000 }, "connectorsSettings":{ "dataframeParsingMode":"New Process", "externalDataFrameCompress":true, "grokConnectHost":"${grokConnectHost}", "grokConnectPort":1234, "localFileSystemAccess":false, "sambaSpaceEscape":"none", "sambaVersion":"3.0", "windowsSharesProxy":"" } }'
                - bucket: !Ref DatagrokS3
                  dbServer: !GetAtt DatagrokDB.Endpoint.Address
                  dbPort: !GetAtt DatagrokDB.Endpoint.Port
                  dbLogin: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:user}}'
                    - secret: !Ref DatagrokDbUser
                  dbPassword: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref DatagrokDbUser
                  dbAdminLogin: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:user}}'
                    - secret: !Ref DatagrokDbAdminUser
                  dbAdminPassword: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref DatagrokDbAdminUser
                  adminPassword: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref DatagrokAdminPassword
                  adminDevKey: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref DatagrokAdminDevKey
                  amqpHost: !Sub rabbit.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
                  grokConnectHost: !Sub grok_connect.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
                  grokSpawnerHost: !Sub grok_spawner.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
                  pipeHost: !Sub pipe.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
                  amqpPassword: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                    - secret: !Ref RabbitMQPassword
                  grokPipeApiKey: !Sub
                    - '{{resolve:secretsmanager:${secret}:SecretString:apikey}}'
                    - secret: !Ref GrokPipeApiKeySecret
          Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Datagrok
                - domain
              repo: !FindInMap
                - Images
                - Datagrok
                - repo
              tag: !Ref DatagrokVersion
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: datagrok
          MemoryReservation: 1024

          #          ReadonlyRootFilesystem: true
          Name: datagrok
          PortMappings:
            - ContainerPort: 8080
              HostPort: 8080
              Protocol: tcp
      Cpu: "2048"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}
        - postfix: !Ref Postfix
      Memory: "4096"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !Ref DatagrokTaskRole

  DatagrokPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok policy to access AWS resources
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - s3:PutObject
              - s3:GetObject
              - s3:DeleteObject
              - s3:ListBucket
            Condition: {}
            Effect: Allow
            Resource:
              - !GetAtt DatagrokS3.Arn
              - !Sub
                - ${bucket}/*
                - bucket: !GetAtt DatagrokS3.Arn
      ManagedPolicyName: !Sub ${AWS::StackName}S3Access-${AWS::Region}

  DatagrokTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: {}
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - !Ref DatagrokPolicy
        - !Ref DatagrokECSPolicy
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: datagrok

  DatagrokLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub
        - ${AWS::StackName}${postfix}
        - postfix: !Ref Postfix
      Scheme: !If
        - InternetIngressAccess
        - internet-facing
        - internal
      SecurityGroups:
        - !Ref DatagrokALBSecurityGroup
      Subnets: !If
        - InternetIngressAccess
        - - !Ref DatagrokPublicSubnet1
          - !Ref DatagrokPublicSubnet2
        - - !Ref DatagrokPrivateSubnet1
          - !Ref DatagrokPrivateSubnet2
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-alb
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      Type: application
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: "true"

  DatagrokLoadBalancerInt:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub
        - ${AWS::StackName}${postfix}-int
        - postfix: !Ref Postfix
      Scheme: internal
      SecurityGroups:
        - !Ref DatagrokALBIntSecurityGroup
      Subnets:
        - !Ref DatagrokPrivateSubnet1
        - !Ref DatagrokPrivateSubnet2
      Tags:
        - Key: Name
          Value: !Sub
            - ${AWS::StackName}${postfix}-alb-int
            - postfix: !Ref Postfix
        - Key: datagrok.component
          Value: datagrok
      Type: application
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: "true"

  DatagrokLogGroup:
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub
        - /ecs/${AWS::StackName}${postfix}-${AWS::Region}
        - postfix: !Ref Postfix
      RetentionInDays: 7

  DatagrokPrivateDNSZone:
    Type: AWS::Route53::HostedZone
    Properties:
      HostedZoneConfig:
        Comment: !Sub ${AWS::StackName} Private Datagrok Zone for internal routing
      Name: !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      VPCs:
        - VPCId: !Ref DatagrokVPC
          VPCRegion: !Ref AWS::Region

  DatagrokPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref DatagrokPrivateDNSZone
      Comment: !Sub ${AWS::StackName} Private Datagrok DNS for internal routing
      Name: !Sub datagrok.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt DatagrokLoadBalancerInt.CanonicalHostedZoneID
        DNSName: !GetAtt DatagrokLoadBalancerInt.DNSName

  GrokConnectPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref DatagrokPrivateDNSZone
      Comment: !Sub ${AWS::StackName} Private Datagrok grok connect DNS for internal routing
      Name: !Sub grok_connect.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt DatagrokLoadBalancerInt.CanonicalHostedZoneID
        DNSName: !GetAtt DatagrokLoadBalancerInt.DNSName

  GrokPipePrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref DatagrokPrivateDNSZone
      Comment: !Sub ${AWS::StackName} Private Datagrok grok pipe DNS for internal routing
      Name: !Sub pipe.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt DatagrokLoadBalancerInt.CanonicalHostedZoneID
        DNSName: !GetAtt DatagrokLoadBalancerInt.DNSName

  RabbitmqPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref DatagrokPrivateDNSZone
      Comment: !Sub ${AWS::StackName} Private Datagrok grok pipe DNS for internal routing
      Name: !Sub rabbit.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt RabbitmqNLB.CanonicalHostedZoneID
        DNSName: !GetAtt RabbitmqNLB.DNSName

  GrokSpawnerPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Grok Spawner policy to access AWS resources
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - ecs:ListTasks
            Condition:
              ArnEquals:
                ecs:cluster:
                  - !GetAtt DatagrokCluster.Arn
                  - !GetAtt CvmCluster.Arn
            Effect: Allow
            Resource: '*'
          - Action:
              - ecs:DescribeTaskDefinition
              - ecs:ListTaskDefinitions
              - ecs:DeregisterTaskDefinition
              - ecs:RegisterTaskDefinition
              - ec2:DescribeInstances
            Condition: {}
            Effect: Allow
            Resource: '*'
          - Action:
              - ecs:DescribeServices
              - ecs:UpdateService
              - ecs:DeleteService
              - ecs:ListServices
            Condition:
              ArnEquals:
                ecs:cluster:
                  - !GetAtt DatagrokCluster.Arn
                  - !GetAtt CvmCluster.Arn
            Effect: Allow
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref CvmCluster
          - Action:
              - ecs:ListContainerInstances
            Effect: Allow
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:cluster/${cluster_name}
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:cluster/${cluster_name}
                - cluster_name: !Ref CvmCluster
          - Action:
              - ecs:DescribeContainerInstances
            Effect: Allow
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:container-instance/${cluster_name}/*
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:container-instance/${cluster_name}/*
                - cluster_name: !Ref CvmCluster
          - Action:
              - ecs:CreateService
              - ecs:TagResource
            Condition:
              StringEquals:
                aws:RequestTag/caller:
                  - grok_spawner
              ArnEquals:
                ecs:cluster:
                  - !GetAtt DatagrokCluster.Arn
                  - !GetAtt CvmCluster.Arn
            Effect: Allow
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref CvmCluster
          - Action:
              - ecs:DescribeTasks
            Condition:
              ArnEquals:
                ecs:cluster:
                  - !GetAtt DatagrokCluster.Arn
                  - !GetAtt CvmCluster.Arn
            Effect: Allow
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:task/${cluster_name}/*
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:task/${cluster_name}/*
                - cluster_name: !Ref CvmCluster
          - Action:
              - logs:GetLogEvents
            Effect: Allow
            Resource: !Sub
              - ${log_group}
              - log_group: !GetAtt DatagrokLogGroup.Arn
          - Action:
              - ecs:DescribeClusters
            Effect: Allow
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref CvmCluster
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt DatagrokKanikoTaskRole.Arn
              - !GetAtt DatagrokTaskExecutionRole.Arn
      ManagedPolicyName: !Sub ${AWS::StackName}-GrokSpawner-${AWS::Region}

  GrokSpawnerECRPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Grok Spawner ECR policy to access AWS resources
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - ecr:GetAuthorizationToken
            Effect: Allow
            Resource: '*'
          - Action:
              - ecr:CreateRepository
            Condition:
              StringEquals:
                aws:RequestTag/builder:
                  - grok_spawner
            Effect: Allow
            Resource: '*'
          - Action:
              - ecr:TagResource
            Condition:
              StringEquals:
                aws:RequestTag/builder:
                  - grok_spawner
            Effect: Allow
            Resource: !Sub arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
          - Action:
              - ecr:DescribeRepositories
              - ecr:ListImages
            Effect: Allow
            Resource: !Sub arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
      ManagedPolicyName: !Sub ${AWS::StackName}-GrokSpawner-ECR-${AWS::Region}

  GrokSpawnerKanikoPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Grok Spawner ECR policy to access AWS resources
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - ecs:RunTask
            Effect: Allow
            Condition:
              ArnEquals:
                ecs:cluster:
                  - !GetAtt DatagrokCluster.Arn
                  - !GetAtt CvmCluster.Arn
            Resource: !Ref DatagrokKanikoTaskDefinition
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt DatagrokKanikoTaskRole.Arn
              - !GetAtt DatagrokTaskExecutionRole.Arn
          - Action:
              - s3:GetObject
              - s3:PutObject
              - s3:ListBucket
            Effect: Allow
            Resource:
              - !GetAtt DatagrokS3.Arn
              - !Sub
                - ${bucket}/dockerfiles/*
                - bucket: !GetAtt DatagrokS3.Arn
      ManagedPolicyName: !Sub ${AWS::StackName}-GrokSpawner-Kaniko-${AWS::Region}

  DatagrokSpawnerTagsPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Policy for tagging resources
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - ecs:TagResource
            Effect: Allow
            Condition:
              StringEquals:
                ecs:CreateAction:
                  - CreateService
                  - RegisterTaskDefinition
                  - UpdateService
            Resource:
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref DatagrokCluster
              - !Sub
                - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
                - cluster_name: !Ref CvmCluster
              - !Sub arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:task-definition/*

  DatagrokKanikoPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: !Sub ${AWS::StackName} Kaniko policy to access AWS resources
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action:
              - ecr:GetAuthorizationToken
            Effect: Allow
            Resource: '*'
          - Action:
              - ecr:CompleteLayerUpload
              - ecr:UploadLayerPart
              - ecr:InitiateLayerUpload
              - ecr:BatchCheckLayerAvailability
              - ecr:PutImage
              - ecr:TagResource
            Effect: Allow
            Resource: !Sub arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
          - Action:
              - ecr:BatchCheckLayerAvailability
              - ecr:BatchGetImage
            Effect: Allow
            Resource: !Sub arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
          - Action:
              - s3:GetObject
              - s3:ListBucket
            Effect: Allow
            Resource:
              - !GetAtt DatagrokS3.Arn
              - !Sub
                - ${bucket}/dockerfiles/*
                - bucket: !GetAtt DatagrokS3.Arn
      ManagedPolicyName: !Sub ${AWS::StackName}-Kaniko-${AWS::Region}

  GrokSpawnerTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: {}
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - !Ref GrokSpawnerPolicy
        - !Ref GrokSpawnerECRPolicy
        - !Ref GrokSpawnerKanikoPolicy
        - !Ref DatagrokECSPolicy
        - !Ref DatagrokSpawnerTagsPolicy
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_spawner

  DatagrokKanikoTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: {}
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - !Ref DatagrokKanikoPolicy
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_spawner

  GrokSpawnerService:
    Type: AWS::ECS::Service
    DependsOn:
      - DatagrokTCP8000IntListener
    Properties:
      Cluster: !GetAtt DatagrokCluster.Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: grok_spawner
          ContainerPort: 8000
          TargetGroupArn: !Ref DatagrokTCP8000IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref DatagrokSecurityGroup
          Subnets:
            - !Ref DatagrokPrivateSubnet1
            - !Ref DatagrokPrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn: !GetAtt GrokSpawnerServiceDiscoveryEntry.Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_spawner
      TaskDefinition: !Ref GrokSpawnerTaskDefinition

  GrokSpawnerServiceDiscoveryEntry:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Description: !Sub ${AWS::StackName} Datagrok grok_spawner service discovery entry in Cloud Map
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_spawner
      NamespaceId: !Ref DatagrokCloudMap

  GrokSpawnerTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Command:
            - !Sub ${AWS::Region}.compute.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - !Sub ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Searchdomain
                - domain
              repo: !FindInMap
                - Images
                - Searchdomain
                - repo
              tag: !FindInMap
                - Images
                - Searchdomain
                - version
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_spawner
          MemoryReservation: 100
          ReadonlyRootFilesystem: true
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - GrokSpawner
                - domain
              repo: !FindInMap
                - Images
                - GrokSpawner
                - repo
              tag: !Ref GrokSpawnerVersion
          Environment:
            - Name: GROK_SPAWNER_ENVIRONMENT
              Value: !Sub ${AWS::StackName}
            - Name: GROK_SPAWNER_DATAGROK_ECS__CLUSTER
              Value: !Ref DatagrokCluster
            - Name: GROK_SPAWNER_DATAGROK_ECS__CLUSTER_REGION
              Value: !Sub ${AWS::Region}
            - Name: GROK_SPAWNER_DATAGROK_ECS__LAUNCH_TYPE
              Value: EC2
            - Name: GROK_SPAWNER_DATAGROK_ECS__SUBNETS
              Value: !Sub
                - '["${s1}", "${s2}"]'
                - s1: !Ref DatagrokPrivateSubnet1
                  s2: !Ref DatagrokPrivateSubnet2
            - Name: GROK_SPAWNER_DATAGROK_ECS__SECURITY_GROUPS
              Value: !Sub
                - '["${s1}"]'
                - s1: !Ref DatagrokSecurityGroup
            - Name: GROK_SPAWNER_DATAGROK_ECS__KANIKO_S3_BUCKET
              Value: !Ref DatagrokS3
            - Name: GROK_SPAWNER_DATAGROK_ECS__KANIKO_TASK_DEFINITION
              Value: !Ref DatagrokKanikoTaskDefinition
            - Name: GROK_SPAWNER_DATAGROK_ECS__LOG_GROUP
              Value: !Sub
                - arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${logs}
                - logs: !Ref DatagrokLogGroup
            - Name: GROK_SPAWNER_CVM_ECS__CLUSTER
              Value: !Ref CvmCluster
            - Name: GROK_SPAWNER_CVM_ECS__CLUSTER_REGION
              Value: !Sub ${AWS::Region}
            - Name: GROK_SPAWNER_CVM_ECS__LAUNCH_TYPE
              Value: EC2
            - Name: GROK_SPAWNER_CVM_ECS__SUBNETS
              Value: !Sub
                - '["${s1}", "${s2}"]'
                - s1: !Ref DatagrokPrivateSubnet1
                  s2: !Ref DatagrokPrivateSubnet2
            - Name: GROK_SPAWNER_CVM_ECS__SECURITY_GROUPS
              Value: !Sub
                - '["${s1}"]'
                - s1: !Ref CvmSecurityGroup
            - Name: GROK_SPAWNER_CVM_ECS__KANIKO_S3_BUCKET
              Value: !Ref DatagrokS3
            - Name: GROK_SPAWNER_CVM_ECS__KANIKO_TASK_DEFINITION
              Value: !Ref DatagrokKanikoTaskDefinition
            - Name: GROK_SPAWNER_CVM_ECS__LOG_GROUP
              Value: !Sub
                - arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${logs}
                - logs: !Ref DatagrokLogGroup
            - Name: GROK_SPAWNER_DATAGROK_ECS__EXEC_ROLE
              Value: !Ref DatagrokTaskExecutionRole
            - Name: GROK_SPAWNER_CVM_ECS__EXEC_ROLE
              Value: !Ref DatagrokTaskExecutionRole
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_spawner
          MemoryReservation: 100

          #          ReadonlyRootFilesystem: true
          Name: grok_spawner
          PortMappings:
            - ContainerPort: 8000
              HostPort: 8000
              Protocol: tcp
      Cpu: "1024"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}-grok_spawner
        - postfix: !Ref Postfix
      Memory: "4096"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !Ref GrokSpawnerTaskRole

  DatagrokKanikoTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Essential: true
          Image: !Sub
            - ${domain}/${repo}:${tag}
            - domain: !FindInMap
                - Images
                - Kaniko
                - domain
              repo: !FindInMap
                - Images
                - Kaniko
                - repo
              tag: !FindInMap
                - Images
                - Kaniko
                - version
          LinuxParameters: {}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref DatagrokLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: grok_spawner_kaniko
          MemoryReservation: 100

          #          ReadonlyRootFilesystem: true
          Name: grok_spawner_kaniko
      Cpu: "1024"
      ExecutionRoleArn: !GetAtt DatagrokTaskExecutionRole.Arn
      Family: !Sub
        - ${AWS::StackName}${postfix}-grok_spawner_kaniko
        - postfix: !Ref Postfix
      Memory: "4096"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !Ref DatagrokKanikoTaskRole

  GrokSpawnerPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref DatagrokPrivateDNSZone
      Comment: !Sub ${AWS::StackName} Private Datagrok grok spawner DNS for internal routing
      Name: !Sub grok_spawner.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt DatagrokLoadBalancerInt.CanonicalHostedZoneID
        DNSName: !GetAtt DatagrokLoadBalancerInt.DNSName

  DatagrokTCP8000IntListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn: !Ref DatagrokTCP8000IntTargetGroup
          Type: forward
      LoadBalancerArn: !Ref DatagrokLoadBalancerInt
      Port: 8000
      Protocol: HTTP

  DatagrokTCP8000IntTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${AWS::StackName}-gs-i
      Port: 8000
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: ip
      VpcId: !Ref DatagrokVPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /info
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5

  GpuInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: {}
            Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
    Condition: GpuRequired

  GpuInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref GpuInstanceRole
    Condition: GpuRequired

  GpuInstance:
    Type: AWS::EC2::Instance
    Properties:
      IamInstanceProfile: !Ref GpuInstanceProfile
      ImageId: !Ref GpuAMI
      InstanceType: !Ref GpuInstanceType
      SecurityGroupIds:
        - !Ref CvmSecurityGroup
      SubnetId: !Ref DatagrokPrivateSubnet1
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-gpu-instance
      UserData: !Base64
        Fn::Sub:
          - |
            #!/bin/bash -xe
            echo "ECS_CLUSTER=${CvmCluster}" >> /etc/ecs/ecs.config
            echo "ECS_ENABLE_GPU_SUPPORT=true" >> /etc/ecs/ecs.config
            echo "ECS_IMAGE_PULL_BEHAVIOR=once" >> /etc/ecs/ecs.config
          - CvmCluster: !Ref CvmCluster
    Condition: GpuRequired

Outputs:
  DatagrokAdminPassword:
    Description: Admin password for first login
    Value: !Sub
      - https://${AWS::Region}.console.aws.amazon.com/secretsmanager/home?region=${AWS::Region}#!/secret?name=${secret}
      - secret: !Ref DatagrokAdminPassword
