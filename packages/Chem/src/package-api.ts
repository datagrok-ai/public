/**
This file is auto-generated by the grok api command.
If you notice any changes, please push them to the repository.
Do not edit this file manually.
*/
import * as grok from 'datagrok-api/grok';
import * as DG from 'datagrok-api/dg';


export namespace scripts {
  /**
  Calculates the distribution coefficient (logD) at a specified pH using pKa and logP.
  */
  export async function calculateLogD(table: DG.DataFrame , molecules: DG.Column , pH: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:CalculateLogD', { table, molecules, pH });
  }

  /**
  Calculates the octanol-water partition coefficient (logP) using RDKit's Crippen method.
  */
  export async function calculateLogP(table: DG.DataFrame , molecules: DG.Column ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:CalculateLogP', { table, molecules });
  }

  /**
  Predicts aqueous solubility (logS) using the AqSolPred consensus model.
  */
  export async function calculateLogS(table: DG.DataFrame , molecules: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:CalculateLogS', { table, molecules });
  }

  /**
  Calculates Isoelectric Point (pI) using various pKa datasets.
  */
  export async function calculatePI(table: DG.DataFrame , molecules: DG.Column , pI_mean: boolean , pI_IPC2_peptide: boolean , pI_IPC_peptide: boolean , pI_ProMoST: boolean , pI_Gauci: boolean , pI_Grimsley: boolean , pI_Thurlkill: boolean , pI_Lehninger: boolean , pI_Toseland: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:CalculatePI', { table, molecules, pI_mean, pI_IPC2_peptide, pI_IPC_peptide, pI_ProMoST, pI_Gauci, pI_Grimsley, pI_Thurlkill, pI_Lehninger, pI_Toseland });
  }

  /**
  Calculates acidic and basic pKa values, noting non-ionizable molecules.
  */
  export async function calculatePKa(table: DG.DataFrame , molecules: DG.Column , pKa_acidic_list: boolean , pKa_basic_list: boolean , pKa_strongest_acidic: boolean , pKa_strongest_basic: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:CalculatePKa', { table, molecules, pKa_acidic_list, pKa_basic_list, pKa_strongest_acidic, pKa_strongest_basic });
  }

  /**
  Standardizes the dataset
  */
  export async function curate(data: DG.DataFrame , molecules: DG.Column , kekulization: boolean , normalization: boolean , reionization: boolean , neutralization: boolean , tautomerization: boolean , mainFragment: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:Curate', { data, molecules, kekulization, normalization, reionization, neutralization, tautomerization, mainFragment });
  }

  export async function desc(smiles: string , df1: DG.DataFrame , selected: string , df2: DG.DataFrame ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:Desc', { smiles, df1, selected, df2 });
  }

  export async function findMCS(molecules: string , df: DG.DataFrame , exactAtomSearch: boolean , exactBondSearch: boolean ): Promise<string> {
    return await grok.functions.call('Chem:FindMCS', { molecules, df, exactAtomSearch, exactBondSearch });
  }

  export async function findRGroupsWithCore(molecules: string , df: DG.DataFrame , core: string , onlyMatchAtRGroups: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:FindRGroupsWithCore', { molecules, df, core, onlyMatchAtRGroups });
  }

  export async function findRGroups(molecules: string , df: DG.DataFrame , core: string , prefix: string ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:FindRGroups', { molecules, df, core, prefix });
  }

  /**
  RDKit-based script.
  */
  export async function chemistryGasteigerPartialCharges(mol: string , contours: number ): Promise<any> {
    return await grok.functions.call('Chem:ChemistryGasteigerPartialCharges', { mol, contours });
  }

  /**
  Generates multiple conformers for a molecule using RDKit
  */
  export async function generateConformers(molecule: string , num_conformers: number , optimize: boolean , rms_threshold: number , max_attempts: number , random_seed: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:GenerateConformers', { molecule, num_conformers, optimize, rms_threshold, max_attempts, random_seed });
  }

  export async function inchiToMol(id: string ): Promise<string> {
    return await grok.functions.call('Chem:InchiToMol', { id });
  }

  /**
  Generates the new dataset based on the given structure
  */
  export async function mutate(molecule: string , steps: number , randomize: boolean , maxRandomResults: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:Mutate', { molecule, steps, randomize, maxRandomResults });
  }

  /**
  generation scaffold tree from dataset
  */
  export async function generateScaffoldTree(data: DG.DataFrame , smilesColumn: string , ringCutoff: number , dischargeAndDeradicalize: boolean ): Promise<any> {
    return await grok.functions.call('Chem:GenerateScaffoldTree', { data, smilesColumn, ringCutoff, dischargeAndDeradicalize });
  }

  export async function smilesTo3DCoordinates(molecule: string ): Promise<string> {
    return await grok.functions.call('Chem:SmilesTo3DCoordinates', { molecule });
  }

  export async function amideReaction(amines: DG.DataFrame , amine_molecules: DG.Column , acids: DG.DataFrame , acid_molecules: DG.Column ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:AmideReaction', { amines, amine_molecules, acids, acid_molecules });
  }

  /**
  Implementation of the clustering algorithm published in: Butina JCICS 39 747-750 (1999)
  */
  export async function butinaMoleculesClustering(data: DG.DataFrame , molecules: DG.Column ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:ButinaMoleculesClustering', { data, molecules });
  }

  /**
  USRCAT - real-time ultrafast shape recognition with pharmacophoric constraints
  */
  export async function usrcat(data: DG.DataFrame , smiles: DG.Column ): Promise<any> {
    return await grok.functions.call('Chem:USRCAT', { data, smiles });
  }

  /**
  Finds undesireable molecules based on various criteria
  */
  export async function filterByCatalogs(data: DG.DataFrame , smiles: DG.Column , catalog: string ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:FilterByCatalogs', { data, smiles, catalog });
  }

  /**
  Generation of Murcko scaffolds from a molecule
  */
  export async function murckoScaffolds(data: DG.DataFrame , smiles: DG.Column ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:MurckoScaffolds', { data, smiles });
  }

  /**
  Similarity Maps Using Fingerprints, RDKit based
  */
  export async function similarityMapsUsingFingerprints(mol: string , refmol: string , radius: number ): Promise<{maxweight: number, simMap: any}> {
    return await grok.functions.call('Chem:SimilarityMapsUsingFingerprints', { mol, refmol, radius });
  }

  /**
  Chemical space using t-distributed Stochastic Neighbor Embedding
  */
  export async function chemicalSpaceUsingTSNE(data: DG.DataFrame , smiles: DG.Column , components: number , minClusterSize: number ): Promise<{spanningTree: any, linkageTree: any, chemSpace: any}> {
    return await grok.functions.call('Chem:ChemicalSpaceUsingTSNE', { data, smiles, components, minClusterSize });
  }

  /**
  Two component reaction
  */
  export async function twoComponentReaction(data1: DG.DataFrame , reactants1: DG.Column , data2: DG.DataFrame , reactants2: DG.Column , reaction: string , matrixExpansion: boolean , randomize: boolean , seed: number , maxRandomReactions: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:TwoComponentReaction', { data1, reactants1, data2, reactants2, reaction, matrixExpansion, randomize, seed, maxRandomReactions });
  }

  /**
  Chemical space using Uniform Manifold Approximation and Projection
  */
  export async function chemicalSpaceUsingUMAP(data: DG.DataFrame , smiles: DG.Column , neighbors: number , minClusterSize: number ): Promise<{spanningTree: any, linkageTree: any, chemSpace: any}> {
    return await grok.functions.call('Chem:ChemicalSpaceUsingUMAP', { data, smiles, neighbors, minClusterSize });
  }

  /**
  to be used in tests to ensure JKG is up and running
  */
  export async function testPythonRunning(x: number , y: number ): Promise<number> {
    return await grok.functions.call('Chem:TestPythonRunning', { x, y });
  }
}

export namespace funcs {
  export async function getRdKitModule(): Promise<any> {
    return await grok.functions.call('Chem:GetRdKitModule', {});
  }

  export async function getMolFileHandler(molString: string ): Promise<any> {
    return await grok.functions.call('Chem:GetMolFileHandler', { molString });
  }

  export async function init(): Promise<void> {
    return await grok.functions.call('Chem:Init', {});
  }

  export async function initChemAutostart(): Promise<void> {
    return await grok.functions.call('Chem:InitChemAutostart', {});
  }

  export async function chemTooltip(col: DG.Column ): Promise<any> {
    return await grok.functions.call('Chem:ChemTooltip', { col });
  }

  export async function scaffoldTreeViewer(): Promise<any> {
    return await grok.functions.call('Chem:ScaffoldTreeViewer', {});
  }

  /**
  RDKit-based substructure filter
  */
  export async function substructureFilter(): Promise<any> {
    return await grok.functions.call('Chem:SubstructureFilter', {});
  }

  export async function canvasMol(x: number , y: number , w: number , h: number , canvas: any , molString: string , scaffoldMolString: string , options?: any ): Promise<void> {
    return await grok.functions.call('Chem:CanvasMol', { x, y, w, h, canvas, molString, scaffoldMolString, options });
  }

  export async function drawMolecule(molStr: string , w?: number , h?: number , popupMenu?: boolean ): Promise<any> {
    return await grok.functions.call('Chem:DrawMolecule', { molStr, w, h, popupMenu });
  }

  export async function getCLogP(smiles: string ): Promise<number> {
    return await grok.functions.call('Chem:GetCLogP', { smiles });
  }

  export async function rdKitCellRenderer(): Promise<any> {
    return await grok.functions.call('Chem:RdKitCellRenderer', {});
  }

  export async function rdKitReactionRenderer(): Promise<any> {
    return await grok.functions.call('Chem:RdKitReactionRenderer', {});
  }

  export async function rdKitMixtureRenderer(): Promise<any> {
    return await grok.functions.call('Chem:RdKitMixtureRenderer', {});
  }

  export async function chemCellRenderer(): Promise<any> {
    return await grok.functions.call('Chem:ChemCellRenderer', {});
  }

  export async function getMorganFingerprints(molColumn: DG.Column ): Promise<DG.Column> {
    return await grok.functions.call('Chem:GetMorganFingerprints', { molColumn });
  }

  export async function getMorganFingerprint(molString: string ): Promise<any> {
    return await grok.functions.call('Chem:GetMorganFingerprint', { molString });
  }

  export async function getSimilarities(molStringsColumn: DG.Column , molString: string ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:GetSimilarities', { molStringsColumn, molString });
  }

  export async function getDiversities(molStringsColumn: DG.Column , limit: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:GetDiversities', { molStringsColumn, limit });
  }

  export async function findSimilar(molStringsColumn: DG.Column , molString: string , limit: number , cutoff: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:FindSimilar', { molStringsColumn, molString, limit, cutoff });
  }

  export async function searchSubstructure(molStringsColumn: DG.Column , molString: string , molBlockFailover: string ): Promise<DG.Column> {
    return await grok.functions.call('Chem:SearchSubstructure', { molStringsColumn, molString, molBlockFailover });
  }

  /**
  As SDF...
  */
  export async function saveAsSdf(): Promise<void> {
    return await grok.functions.call('Chem:SaveAsSdf', {});
  }

  export async function similaritySearchViewer(): Promise<any> {
    return await grok.functions.call('Chem:SimilaritySearchViewer', {});
  }

  export async function similaritySearchTopMenu(): Promise<void> {
    return await grok.functions.call('Chem:SimilaritySearchTopMenu', {});
  }

  export async function diversitySearchViewer(): Promise<any> {
    return await grok.functions.call('Chem:DiversitySearchViewer', {});
  }

  export async function diversitySearchTopMenu(): Promise<void> {
    return await grok.functions.call('Chem:DiversitySearchTopMenu', {});
  }

  export async function descriptorsDocker(): Promise<void> {
    return await grok.functions.call('Chem:DescriptorsDocker', {});
  }

  export async function calculateDescriptorsTransform(table: DG.DataFrame , molecules: DG.Column , selected: any ): Promise<void> {
    return await grok.functions.call('Chem:CalculateDescriptorsTransform', { table, molecules, selected });
  }

  export async function getDescriptors(molecules: DG.Column , selected: any ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:GetDescriptors', { molecules, selected });
  }

  export async function chemDescriptorsTree(): Promise<any> {
    return await grok.functions.call('Chem:ChemDescriptorsTree', {});
  }

  export async function getMapIdentifiers(): Promise<void> {
    return await grok.functions.call('Chem:GetMapIdentifiers', {});
  }

  export async function freeTextToSmiles(molfile: string ): Promise<string> {
    return await grok.functions.call('Chem:FreeTextToSmiles', { molfile });
  }

  export async function chemDescriptors(table: DG.DataFrame , molecules: DG.Column , descriptors: any ): Promise<void> {
    return await grok.functions.call('Chem:ChemDescriptors', { table, molecules, descriptors });
  }

  export async function searchSubstructureEditor(call: any ): Promise<void> {
    return await grok.functions.call('Chem:SearchSubstructureEditor', { call });
  }

  export async function substructureSearchTopMenu(molecules: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:SubstructureSearchTopMenu', { molecules });
  }

  /**
  Calculates most common substructures for each cluster
  */
  export async function clusterMCSTopMenu(table: DG.DataFrame , molCol: DG.Column , clusterCol: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:ClusterMCSTopMenu', { table, molCol, clusterCol });
  }

  /**
  Calculates most common substructures for each cluster
  */
  export async function performClusterMCS(molCol: DG.Column , clusterCol: DG.Column ): Promise<DG.Column> {
    return await grok.functions.call('Chem:PerformClusterMCS', { molCol, clusterCol });
  }

  export async function chemSpaceEditor(call: any ): Promise<void> {
    return await grok.functions.call('Chem:ChemSpaceEditor', { call });
  }

  export async function getFingerprints(col: DG.Column , _metric?: any , fingerprintType?: string ): Promise<any> {
    return await grok.functions.call('Chem:GetFingerprints', { col, _metric, fingerprintType });
  }

  /**
  Maps the dataset to 2D plot based on similarity
  */
  export async function chemSpaceTopMenu(table: DG.DataFrame , molecules: DG.Column , methodName: string , similarityMetric: string , plotEmbeddings: boolean , options?: any , preprocessingFunction?: any , clusterEmbeddings?: boolean , clusterMCS?: boolean ): Promise<any> {
    return await grok.functions.call('Chem:ChemSpaceTopMenu', { table, molecules, methodName, similarityMetric, plotEmbeddings, options, preprocessingFunction, clusterEmbeddings, clusterMCS });
  }

  export async function chemSpaceTransform(table: DG.DataFrame , molecules: DG.Column , methodName: string , similarityMetric: string , plotEmbeddings: boolean , options?: string , clusterEmbeddings?: boolean ): Promise<any> {
    return await grok.functions.call('Chem:ChemSpaceTransform', { table, molecules, methodName, similarityMetric, plotEmbeddings, options, clusterEmbeddings });
  }

  export async function getChemSpaceEmbeddings(col: string , methodName: string , similarityMetric: string , xAxis: string , yAxis: string , options?: any ): Promise<any> {
    return await grok.functions.call('Chem:GetChemSpaceEmbeddings', { col, methodName, similarityMetric, xAxis, yAxis, options });
  }

  export async function getChemSimilaritiesMatrix(dim: number , col: DG.Column , df: DG.DataFrame , colName: string , simArr: any ): Promise<any> {
    return await grok.functions.call('Chem:GetChemSimilaritiesMatrix', { dim, col, df, colName, simArr });
  }

  export async function elementalAnalysis(table: DG.DataFrame , molecules: DG.Column , radarViewer: boolean , radarGrid: boolean ): Promise<void> {
    return await grok.functions.call('Chem:ElementalAnalysis', { table, molecules, radarViewer, radarGrid });
  }

  export async function runElementalAnalysis(table: DG.DataFrame , molecules: DG.Column ): Promise<any> {
    return await grok.functions.call('Chem:RunElementalAnalysis', { table, molecules });
  }

  export async function rGroupsAnalysisMenu(): Promise<void> {
    return await grok.functions.call('Chem:RGroupsAnalysisMenu', {});
  }

  export async function rGroupDecomposition(df: DG.DataFrame , molColName: string , core: string , rGroupName: string , rGroupMatchingStrategy: string , onlyMatchAtRGroups?: boolean ): Promise<any> {
    return await grok.functions.call('Chem:RGroupDecomposition', { df, molColName, core, rGroupName, rGroupMatchingStrategy, onlyMatchAtRGroups });
  }

  export async function activityCliffsEditor(call: any ): Promise<void> {
    return await grok.functions.call('Chem:ActivityCliffsEditor', { call });
  }

  /**
  Detects pairs of molecules with similar structure and significant difference in any given property
  */
  export async function activityCliffs(table: DG.DataFrame , molecules: DG.Column , activities: DG.Column , similarity: number , methodName: string , similarityMetric: string , preprocessingFunction?: any , options?: any , isDemo?: boolean , isTest?: boolean ): Promise<void> {
    return await grok.functions.call('Chem:ActivityCliffs', { table, molecules, activities, similarity, methodName, similarityMetric, preprocessingFunction, options, isDemo, isTest });
  }

  export async function activityCliffsInitFunction(sp: any ): Promise<void> {
    return await grok.functions.call('Chem:ActivityCliffsInitFunction', { sp });
  }

  export async function activityCliffsTransform(table: DG.DataFrame , molecules: DG.Column , activities: DG.Column , similarity: number , methodName: string , similarityMetric: string , options?: string , isDemo?: boolean ): Promise<void> {
    return await grok.functions.call('Chem:ActivityCliffsTransform', { table, molecules, activities, similarity, methodName, similarityMetric, options, isDemo });
  }

  export async function addInchisTopMenu(table: DG.DataFrame , molecules: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:AddInchisTopMenu', { table, molecules });
  }

  export async function getInchis(molecules: DG.Column ): Promise<DG.Column> {
    return await grok.functions.call('Chem:GetInchis', { molecules });
  }

  export async function addInchisKeysTopMenu(table: DG.DataFrame , molecules: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:AddInchisKeysTopMenu', { table, molecules });
  }

  export async function getInchiKeys(molecules: DG.Column ): Promise<DG.Column> {
    return await grok.functions.call('Chem:GetInchiKeys', { molecules });
  }

  /**
  Highlights the fragments that could lead to potential chemical hazards
  */
  export async function structuralAlertsTopMenu(table: DG.DataFrame , molecules: DG.Column , pains: boolean , bms: boolean , sureChembl: boolean , mlsmr: boolean , dundee: boolean , inpharmatica: boolean , lint: boolean , glaxo: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:StructuralAlertsTopMenu', { table, molecules, pains, bms, sureChembl, mlsmr, dundee, inpharmatica, lint, glaxo });
  }

  export async function runStructuralAlerts(table: DG.DataFrame , molecules: DG.Column , pains: boolean , bms: boolean , sureChembl: boolean , mlsmr: boolean , dundee: boolean , inpharmatica: boolean , lint: boolean , glaxo: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:RunStructuralAlerts', { table, molecules, pains, bms, sureChembl, mlsmr, dundee, inpharmatica, lint, glaxo });
  }

  export async function runStructuralAlert(molecules: DG.Column , alert: string ): Promise<DG.Column> {
    return await grok.functions.call('Chem:RunStructuralAlert', { molecules, alert });
  }

  export async function molColumnPropertyPanel(molColumn: DG.Column ): Promise<any> {
    return await grok.functions.call('Chem:MolColumnPropertyPanel', { molColumn });
  }

  export async function molColumnHighlights(molColumn: DG.Column ): Promise<any> {
    return await grok.functions.call('Chem:MolColumnHighlights', { molColumn });
  }

  export async function descriptorsWidget(smiles: string ): Promise<any> {
    return await grok.functions.call('Chem:DescriptorsWidget', { smiles });
  }

  /**
  Drug Likeness score, with explanations on molecule fragments contributing to the score. OCL.
  */
  export async function drugLikeness(smiles: any ): Promise<any> {
    return await grok.functions.call('Chem:DrugLikeness', { smiles });
  }

  /**
  Basic molecule properties
  */
  export async function properties(smiles: any ): Promise<any> {
    return await grok.functions.call('Chem:Properties', { smiles });
  }

  /**
  Return chem property function
  */
  export async function getChemPropertyFunction(name: string ): Promise<any> {
    return await grok.functions.call('Chem:GetChemPropertyFunction', { name });
  }

  /**
  Screening drug candidates against structural alerts i.e. fragments associated to a toxicological response
  */
  export async function structuralAlerts(smiles: string ): Promise<any> {
    return await grok.functions.call('Chem:StructuralAlerts', { smiles });
  }

  export async function identifiers(smiles: string ): Promise<any> {
    return await grok.functions.call('Chem:Identifiers', { smiles });
  }

  /**
  3D molecule representation
  */
  export async function structure3D(molecule: string ): Promise<any> {
    return await grok.functions.call('Chem:Structure3D', { molecule });
  }

  /**
  2D molecule representation
  */
  export async function structure2d(molecule: string ): Promise<any> {
    return await grok.functions.call('Chem:Structure2d', { molecule });
  }

  /**
  Toxicity prediction. Calculated by openchemlib
  */
  export async function toxicity(smiles: any ): Promise<any> {
    return await grok.functions.call('Chem:Toxicity', { smiles });
  }

  export async function convertMoleculeNotation(molecule: DG.Column , targetNotation: string ): Promise<DG.Column> {
    return await grok.functions.call('Chem:ConvertMoleculeNotation', { molecule, targetNotation });
  }

  /**
  RDKit-based conversion for SMILES, SMARTS, InChi, Molfile V2000 and Molfile V3000
  */
  export async function convertMolNotation(molecule: string , sourceNotation: string , targetNotation: string ): Promise<string> {
    return await grok.functions.call('Chem:ConvertMolNotation', { molecule, sourceNotation, targetNotation });
  }

  export async function convertNotation(data: DG.DataFrame , molecules: DG.Column , targetNotation: string , overwrite: boolean , join: boolean ): Promise<DG.Column> {
    return await grok.functions.call('Chem:ConvertNotation', { data, molecules, targetNotation, overwrite, join });
  }

  export async function convertMolNotationAction(col: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:ConvertMolNotationAction', { col });
  }

  export async function convertMixtureToSmiles(col: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:ConvertMixtureToSmiles', { col });
  }

  /**
  Molecule
  */
  export async function editMoleculeCell(cell: any ): Promise<void> {
    return await grok.functions.call('Chem:EditMoleculeCell', { cell });
  }

  export async function openChemLibSketcher(): Promise<any> {
    return await grok.functions.call('Chem:OpenChemLibSketcher', {});
  }

  /**
  Opens SDF file
  */
  export async function importSdf(bytes: any ): Promise<any> {
    return await grok.functions.call('Chem:ImportSdf', { bytes });
  }

  /**
  Opens smi file
  */
  export async function importSmi(bytes: any ): Promise<any> {
    return await grok.functions.call('Chem:ImportSmi', { bytes });
  }

  /**
  Opens smi file
  */
  export async function importMol2(bytes: any ): Promise<any> {
    return await grok.functions.call('Chem:ImportMol2', { bytes });
  }

  /**
  Opens MOL file
  */
  export async function importMol(content: string ): Promise<any> {
    return await grok.functions.call('Chem:ImportMol', { content });
  }

  export async function oclCellRenderer(): Promise<any> {
    return await grok.functions.call('Chem:OclCellRenderer', {});
  }

  /**
  Sorts a molecular column by similarity
  */
  export async function sortBySimilarity(value: any ): Promise<void> {
    return await grok.functions.call('Chem:SortBySimilarity', { value });
  }

  /**
  Adds this structure as a substructure filter
  */
  export async function useAsSubstructureFilter(value: any ): Promise<void> {
    return await grok.functions.call('Chem:UseAsSubstructureFilter', { value });
  }

  /**
  Copies structure in different formats
  */
  export async function copyAsAction(value: any ): Promise<void> {
    return await grok.functions.call('Chem:CopyAsAction', { value });
  }

  /**
  Copies structure as smiles
  */
  export async function copyAsSmiles(value: any ): Promise<void> {
    return await grok.functions.call('Chem:CopyAsSmiles', { value });
  }

  /**
  Copies structure as molfile V2000
  */
  export async function copyAsMolfileV2000(value: any ): Promise<void> {
    return await grok.functions.call('Chem:CopyAsMolfileV2000', { value });
  }

  /**
  Copies structure as molfile V3000
  */
  export async function copyAsMolfileV3000(value: any ): Promise<void> {
    return await grok.functions.call('Chem:CopyAsMolfileV3000', { value });
  }

  /**
  Copies structure as smarts
  */
  export async function copyAsSmarts(value: any ): Promise<void> {
    return await grok.functions.call('Chem:CopyAsSmarts', { value });
  }

  /**
  Copies structure as Image
  */
  export async function copyAsImage(value: any ): Promise<void> {
    return await grok.functions.call('Chem:CopyAsImage', { value });
  }

  export async function isSmiles(s: string ): Promise<boolean> {
    return await grok.functions.call('Chem:IsSmiles', { s });
  }

  export async function isSmarts(s: string ): Promise<boolean> {
    return await grok.functions.call('Chem:IsSmarts', { s });
  }

  export async function detectSmiles(col: DG.Column , min: number ): Promise<void> {
    return await grok.functions.call('Chem:DetectSmiles', { col, min });
  }

  export async function callChemSimilaritySearch(df: DG.DataFrame , col: DG.Column , molecule: string , metricName: string , fingerprint: string , limit: number , minScore: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:CallChemSimilaritySearch', { df, col, molecule, metricName, fingerprint, limit, minScore });
  }

  export async function callChemDiversitySearch(col: DG.Column , metricName: string , fingerprint: string , limit: number ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:CallChemDiversitySearch', { col, metricName, fingerprint, limit });
  }

  export async function addChemPropertiesColumns(table: DG.DataFrame , molecules: DG.Column , MW: boolean , HBA: boolean , HBD: boolean , logP: boolean , logS: boolean , PSA: boolean , rotatableBonds: boolean , stereoCenters: boolean , moleculeCharge: boolean ): Promise<void> {
    return await grok.functions.call('Chem:AddChemPropertiesColumns', { table, molecules, MW, HBA, HBD, logP, logS, PSA, rotatableBonds, stereoCenters, moleculeCharge });
  }

  export async function getMolProperty(molecules: DG.Column , property: string ): Promise<DG.Column> {
    return await grok.functions.call('Chem:GetMolProperty', { molecules, property });
  }

  export async function addChemRisksColumns(table: DG.DataFrame , molecules: DG.Column , mutagenicity: boolean , tumorigenicity: boolean , irritatingEffects: boolean , reproductiveEffects: boolean ): Promise<void> {
    return await grok.functions.call('Chem:AddChemRisksColumns', { table, molecules, mutagenicity, tumorigenicity, irritatingEffects, reproductiveEffects });
  }

  export async function getToxicityRisks(molecules: DG.Column , risks: any ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:GetToxicityRisks', { molecules, risks });
  }

  /**
  Generates a hierarchical tree based on the scaffolds presented in dataset
  */
  export async function addScaffoldTree(): Promise<void> {
    return await grok.functions.call('Chem:AddScaffoldTree', {});
  }

  export async function mmpViewer(): Promise<any> {
    return await grok.functions.call('Chem:MmpViewer', {});
  }

  export async function mmpeditor(call: any ): Promise<void> {
    return await grok.functions.call('Chem:MMPEditor', { call });
  }

  export async function mmpAnalysis(table: DG.DataFrame , molecules: DG.Column , activities: string[] , diffTypes: any , scalings: any , fragmentCutoff: number ): Promise<void> {
    return await grok.functions.call('Chem:MmpAnalysis', { table, molecules, activities, diffTypes, scalings, fragmentCutoff });
  }

  /**
  Scaffold Tree filter
  */
  export async function scaffoldTreeFilter(): Promise<any> {
    return await grok.functions.call('Chem:ScaffoldTreeFilter', {});
  }

  export async function getScaffoldTree(data: DG.DataFrame , ringCutoff: number , dischargeAndDeradicalize: boolean ): Promise<string> {
    return await grok.functions.call('Chem:GetScaffoldTree', { data, ringCutoff, dischargeAndDeradicalize });
  }

  export async function removeDuplicates(molecules: any , molecule: string ): Promise<any> {
    return await grok.functions.call('Chem:RemoveDuplicates', { molecules, molecule });
  }

  /**
  Overview of Cheminformatics functionality
  */
  export async function demoChemOverview(): Promise<void> {
    return await grok.functions.call('Chem:DemoChemOverview', {});
  }

  /**
  Searching for most similar or diverse molecules in dataset
  */
  export async function demoSimilarityDiversitySearch(): Promise<void> {
    return await grok.functions.call('Chem:DemoSimilarityDiversitySearch', {});
  }

  /**
  Detect matched molecule pairs calculate the difference in activity values between them
  */
  export async function demoMMPA(): Promise<void> {
    return await grok.functions.call('Chem:DemoMMPA', {});
  }

  /**
  R Group Analysis including R-group decomposition and  visual analysis of the obtained R-groups
  */
  export async function demoRgroupAnalysis(): Promise<void> {
    return await grok.functions.call('Chem:DemoRgroupAnalysis', {});
  }

  /**
  Searching similar structures with significant activity difference
  */
  export async function demoMoleculeActivityCliffs(): Promise<void> {
    return await grok.functions.call('Chem:DemoMoleculeActivityCliffs', {});
  }

  /**
  Maps the dataset to 2D plot based on similarity
  */
  export async function demoChemicalSpace(): Promise<void> {
    return await grok.functions.call('Chem:DemoChemicalSpace', {});
  }

  /**
  Running scaffold analysis with hierarchical tree
  */
  export async function demoScaffold(): Promise<void> {
    return await grok.functions.call('Chem:DemoScaffold', {});
  }

  export async function namesToSmiles(data: DG.DataFrame , names: DG.Column ): Promise<void> {
    return await grok.functions.call('Chem:NamesToSmiles', { data, names });
  }

  export async function canonicalize(molecule: string ): Promise<string> {
    return await grok.functions.call('Chem:Canonicalize', { molecule });
  }

  export async function getMolecularFormula(molecule: string ): Promise<string> {
    return await grok.functions.call('Chem:GetMolecularFormula', { molecule });
  }

  export async function validateMolecule(s: string ): Promise<any> {
    return await grok.functions.call('Chem:ValidateMolecule', { s });
  }

  /**
  To be added
  */
  export async function trainChemprop(df: DG.DataFrame , predictColumn: DG.Column , dataset_type: string , metric: string , multiclass_num_classes: number , num_folds: number , data_seed: number , split_sizes: any , split_type: string , activation: string , atom_messages: boolean , message_bias: boolean , ensemble_size: number , message_hidden_dim: number , depth: number , dropout: number , ffn_hidden_dim: number , ffn_num_layers: number , epochs: number , batch_size: number , warmup_epochs: number , init_lr: number , max_lr: number , final_lr: number , no_descriptor_scaling: boolean ): Promise<any> {
    return await grok.functions.call('Chem:TrainChemprop', { df, predictColumn, dataset_type, metric, multiclass_num_classes, num_folds, data_seed, split_sizes, split_type, activation, atom_messages, message_bias, ensemble_size, message_hidden_dim, depth, dropout, ffn_hidden_dim, ffn_num_layers, epochs, batch_size, warmup_epochs, init_lr, max_lr, final_lr, no_descriptor_scaling });
  }

  export async function applyChemprop(df: DG.DataFrame , model: any ): Promise<DG.DataFrame> {
    return await grok.functions.call('Chem:ApplyChemprop', { df, model });
  }

  export async function isApplicableNN(df: DG.DataFrame , predictColumn: DG.Column ): Promise<boolean> {
    return await grok.functions.call('Chem:IsApplicableNN', { df, predictColumn });
  }

  export async function isInteractiveNN(df: DG.DataFrame , predictColumn: DG.Column ): Promise<boolean> {
    return await grok.functions.call('Chem:IsInteractiveNN', { df, predictColumn });
  }

  /**
  Generates the new dataset based on the given structure
  */
  export async function deprotect(table: DG.DataFrame , molecules: DG.Column , fragment: string ): Promise<void> {
    return await grok.functions.call('Chem:Deprotect', { table, molecules, fragment });
  }

  /**
  Beautifies the list of molecules and returns the list of beautified molecules
  */
  export async function beautifyMols(mols: any ): Promise<any> {
    return await grok.functions.call('Chem:BeautifyMols', { mols });
  }

  /**
  Converts the list of molecules to V3K format using OCL
  */
  export async function convertToV3KViaOCL(mols: any ): Promise<any> {
    return await grok.functions.call('Chem:ConvertToV3KViaOCL', { mols });
  }

  /**
  Calculates the MPO score for the column of molecules
  */
  export async function mpo(): Promise<void> {
    return await grok.functions.call('Chem:Mpo', {});
  }

  export async function mpoTransformFunction(df: DG.DataFrame , currentProperties: any ): Promise<void> {
    return await grok.functions.call('Chem:MpoTransformFunction', { df, currentProperties });
  }

  export async function mpoProfileEditor(file: DG.FileInfo ): Promise<DG.View> {
    return await grok.functions.call('Chem:MpoProfileEditor', { file });
  }

  export async function checkJsonMpoProfile(content: string ): Promise<boolean> {
    return await grok.functions.call('Chem:CheckJsonMpoProfile', { content });
  }

  export async function mixtureWidget(mixture: string ): Promise<any> {
    return await grok.functions.call('Chem:MixtureWidget', { mixture });
  }

  export async function mixtureTreeWidget(mixture: string ): Promise<any> {
    return await grok.functions.call('Chem:MixtureTreeWidget', { mixture });
  }

  /**
  Dynamically discovers and executes tagged biochemical calculators
  */
  export async function biochemPropsWidget(): Promise<void> {
    return await grok.functions.call('Chem:BiochemPropsWidget', {});
  }
}
