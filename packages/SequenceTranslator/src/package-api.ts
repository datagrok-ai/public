/**
This file is auto-generated by the grok api command.
If you notice any changes, please push them to the repository.
Do not edit this file manually.
*/
import * as grok from 'datagrok-api/grok';
import * as DG from 'datagrok-api/dg';


export namespace funcs {
  export async function oligoToolkitApp(): Promise<DG.View> {
    return await grok.functions.call('SequenceTranslator:OligoToolkitApp', {});
  }

  export async function init(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:Init', {});
  }

  export async function oligoTranslatorApp(): Promise<DG.View> {
    return await grok.functions.call('SequenceTranslator:OligoTranslatorApp', {});
  }

  export async function oligoPatternApp(): Promise<DG.View> {
    return await grok.functions.call('SequenceTranslator:OligoPatternApp', {});
  }

  export async function oligoStructureApp(): Promise<DG.View> {
    return await grok.functions.call('SequenceTranslator:OligoStructureApp', {});
  }

  export async function getTranslationHelper(): Promise<any> {
    return await grok.functions.call('SequenceTranslator:GetTranslationHelper', {});
  }

  export async function getCodeToWeightsMap(): Promise<any> {
    return await grok.functions.call('SequenceTranslator:GetCodeToWeightsMap', {});
  }

  export async function validateSequence(sequence: string ): Promise<boolean> {
    return await grok.functions.call('SequenceTranslator:ValidateSequence', { sequence });
  }

  export async function getMolfileFromGcrsSequence(sequence: string , invert: boolean ): Promise<string> {
    return await grok.functions.call('SequenceTranslator:GetMolfileFromGcrsSequence', { sequence, invert });
  }

  export async function linkStrands(strands: any ): Promise<string> {
    return await grok.functions.call('SequenceTranslator:LinkStrands', { strands });
  }

  /**
  Translate oligonucleotide sequences across various formats accepted by different synthesizers
  */
  export async function demoTranslateSequence(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:DemoTranslateSequence', {});
  }

  /**
  Design a modification pattern for an oligonucleotide sequence
  */
  export async function demoOligoPattern(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:DemoOligoPattern', {});
  }

  /**
  Visualize duplex and save SDF
  */
  export async function demoOligoStructure(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:DemoOligoStructure', {});
  }

  export async function translateOligonucleotideSequence(sequence: string , sourceFormat: string , targetFormat: string ): Promise<string> {
    return await grok.functions.call('SequenceTranslator:TranslateOligonucleotideSequence', { sequence, sourceFormat, targetFormat });
  }

  /**
  editor for Performing conversion of sequences in custom notation to molfiles
  */
  export async function polyToolConvertTopMenu(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:PolyToolConvertTopMenu', {});
  }

  export async function getPolyToolConvertEditor(call: any ): Promise<DG.Column> {
    return await grok.functions.call('SequenceTranslator:GetPolyToolConvertEditor', { call });
  }

  export async function polyToolConvert2(table: DG.DataFrame , seqCol: DG.Column , generateHelm: boolean , chiralityEngine: boolean , rules: any ): Promise<DG.Column> {
    return await grok.functions.call('SequenceTranslator:PolyToolConvert2', { table, seqCol, generateHelm, chiralityEngine, rules });
  }

  /**
  Dialog for configuring enumeration of a HELM sequence
  */
  export async function polyToolEnumerateHelmTopMenu(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:PolyToolEnumerateHelmTopMenu', {});
  }

  /**
  Perform enumeration of a molecule using different fragments at specified positions
  */
  export async function polyToolEnumerateChemTopMenu(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:PolyToolEnumerateChemTopMenu', {});
  }

  export async function polyToolColumnChoice(df: DG.DataFrame , macroMolecule: DG.Column ): Promise<void> {
    return await grok.functions.call('SequenceTranslator:PolyToolColumnChoice', { df, macroMolecule });
  }

  export async function createMonomerLibraryForPolyTool(file: DG.FileInfo ): Promise<void> {
    return await grok.functions.call('SequenceTranslator:CreateMonomerLibraryForPolyTool', { file });
  }

  export async function ptEnumeratorHelmApp(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:PtEnumeratorHelmApp', {});
  }

  export async function ptEnumeratorChemApp(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:PtEnumeratorChemApp', {});
  }

  export async function getPtHelmEnumeratorDialog(cell: any | null): Promise<void> {
    return await grok.functions.call('SequenceTranslator:GetPtHelmEnumeratorDialog', { cell });
  }

  export async function getPtChemEnumeratorDialog(cell: any | null): Promise<void> {
    return await grok.functions.call('SequenceTranslator:GetPtChemEnumeratorDialog', { cell });
  }

  /**
  Enumerate provided HELM sequence on provided positions with provided monomers and generates new table
  */
  export async function enumerateSingleHelmSequence(helmSequence: string , positions: any , monomerLists: any , toAtomicLevel: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('SequenceTranslator:EnumerateSingleHelmSequence', { helmSequence, positions, monomerLists, toAtomicLevel });
  }

  /**
  Enumerate provided HELM sequence on all positions with natural amino acids and generates new table. Generated table has sequence column called "Enumerated", and molecule column called "Molfile(Enumerated) if toAtomicLevel is set to true. Keywords: Optimize, enumerate, HELM optimization, Maximize Minimize property. When you want to optimize certain peptide using for example logS, set toAtomicLevel to true and use generated molecule column to calculate given property using chem package functions.
  */
  export async function enumerateSingleHelmSequenceWithNaturalAAs(helmSequence: string , toAtomicLevel: boolean ): Promise<DG.DataFrame> {
    return await grok.functions.call('SequenceTranslator:EnumerateSingleHelmSequenceWithNaturalAAs', { helmSequence, toAtomicLevel });
  }

  export async function getPolyToolCombineDialog(): Promise<void> {
    return await grok.functions.call('SequenceTranslator:GetPolyToolCombineDialog', {});
  }

  export async function applyNotationProviderForCyclized(col: DG.Column , separator: string ): Promise<void> {
    return await grok.functions.call('SequenceTranslator:ApplyNotationProviderForCyclized', { col, separator });
  }
}
