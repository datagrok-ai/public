/* eslint-disable max-len */
import * as DG from 'datagrok-api/dg';
import * as grok from 'datagrok-api/grok';
import * as ui from 'datagrok-api/ui';

function correctRGroups(smiles: string): string {
  const elementRGroupRegex = /\[R[1-9]\]/g;
  // replace all [R1] with [*:1]
  let correctedSmiles = smiles.replaceAll(elementRGroupRegex, (match) => {
    const rGroupNum = match[2];
    return `[*:${rGroupNum}]`;
  });

  // in some scenarios, rgroups can be written as [2*]
  const elementRGroupRegex2 = /\[\d\*\]/g;
  correctedSmiles = correctedSmiles.replaceAll(elementRGroupRegex2, (match) => {
    const rGroupNum = match[1];
    return `[*:${rGroupNum}]`;
  });

  // in some other scenarios, rgroups can be written as [1*:1] or [1*:0]
  const elementRGroupRegex3 = /\[\d\*\:\d\]/g;
  return correctedSmiles.replaceAll(elementRGroupRegex3, (match) => {
    const rGroupNum = match[1];
    return `[*:${rGroupNum}]`;
  });
}

function rgroupToRadicalForm(smiles: string): string {
  // here we are sure that all rgroups are in the form [*:1], [*:2], ..., [*:9]
  // replace all [*:1] with [C:1] to mark carbons
  return smiles.replaceAll(/\[\*\:\d\]/g, (match) => {
    const rGroupNum = match[3];
    return `[C:${rGroupNum}]`;
  });
}

function radicalToRgroupForm(smiles: string): string {
  // here we are sure that all marked carbons are in the form [C:1], [C:2], ..., [C:9]
  // replace all [C:1] with [*:1]
  return smiles.replaceAll(/\[C\:\d\]/g, (match) => {
    const rGroupNum = match[3];
    return `[*:${rGroupNum}]`;
  });
}

export type ReactionEditorProps = {
    resultMonomerName: string,
    firstReactantSmiles: string,
    secondReactantSmiles: string,
    productSmiles: string,
    firstMonomers: string[],
    secondMonomers: string[],
    code: number,
    rowIndex?: number,
}

export function getReactionEditor(onOk: (props: ReactionEditorProps) => void, preset?: ReactionEditorProps) {
  // preset smiles are in radical form, need to convert to rgroup form
  const firstReactant = preset?.firstReactantSmiles ? radicalToRgroupForm(preset.firstReactantSmiles) : '[*:1]C';
  const secondReactant = preset?.secondReactantSmiles ? radicalToRgroupForm(preset.secondReactantSmiles) : '[*:2]C';
  const product = preset?.productSmiles ? radicalToRgroupForm(preset.productSmiles) : '[*:1]CC[*:2]';
  const code = preset?.code;
  const firstMonomers = preset?.firstMonomers ?? [];
  const secondMonomers = preset?.secondMonomers ?? [];
  const resultMonomerName = preset?.resultMonomerName ?? '';

  const codeInput = ui.input.int('Code', {value: code, nullable: false, showPlusMinus: false, showSlider: false, tooltipText: 'Reaction code'});
  const firstMonomersInput = ui.input.string('First monomers', {value: firstMonomers.join(','), nullable: false, tooltipText: 'Comma-separated list of monomers for the first reactant'});
  const secondMonomersInput = ui.input.string('Second monomers', {value: secondMonomers.join(','), nullable: false, tooltipText: 'Comma-separated list of monomers for the second reactant'});
  const resultMonomerNameInput = ui.input.string('Result monomer name', {value: resultMonomerName, nullable: false, tooltipText: 'Name of the resulting pseudo-monomer generated by the reaction of the two reactants'});

  const firstReactantInput = ui.input.molecule('First reactant', {value: firstReactant, nullable: false, tooltipText: 'Reactant fragment of first monomer(s). Use numbered R groups in correspondence with the rest of the molecule.'});
  const secondReactantInput = ui.input.molecule('Second reactant', {value: secondReactant, nullable: false, tooltipText: 'Reactant fragment of second monomer(s). Use numbered R groups in correspondence with the rest of the molecule.'});
  const productInput = ui.input.molecule('Product', {value: product, nullable: false, tooltipText: 'Product fragment of the resulting monomer from the reaction of the two reactants. Use numbered R groups in correspondence with the reactants.'});

  const validate = () => {
    if (!firstReactantInput || !secondReactantInput || !productInput)
      return 'Inputs not initialized yet';
    const firstSmiles = rgroupToRadicalForm(correctRGroups(grok.chem.convert(firstReactantInput.value ?? '', grok.chem.Notation.Unknown, grok.chem.Notation.Smiles)));
    const secondSmiles = rgroupToRadicalForm(correctRGroups(grok.chem.convert(secondReactantInput.value ?? '', grok.chem.Notation.Unknown, grok.chem.Notation.Smiles)));
    const productSmiles = rgroupToRadicalForm(correctRGroups(grok.chem.convert(productInput.value ?? '', grok.chem.Notation.Unknown, grok.chem.Notation.Smiles)));
    if (!firstSmiles || !secondSmiles || !productSmiles)
      return 'First/Second Reactants and Product must all be set';
    if (firstSmiles.indexOf('[C:1]') == -1)
      return 'First Reactant must contain R1-group';
    if (secondSmiles.indexOf('[C:2]') == -1)
      return 'Second Reactant must contain R2-group';
    if (productSmiles.indexOf('[C:1]') == -1 || productSmiles.indexOf('[C:2]') == -1)
      return 'Product must contain R1- and R2-groups';
    return null;
  };
  firstReactantInput.addValidator(validate);
  secondReactantInput.addValidator(validate);
  productInput.addValidator(validate);
  const dialog = ui.dialog(preset ? 'Edit Reaction Rule' : 'Add Reaction Rule')
    .add(codeInput)
    .add(resultMonomerNameInput)
    .add(firstMonomersInput)
    .add(secondMonomersInput)
    .add(firstReactantInput)
    .add(secondReactantInput)
    .add(productInput);
  dialog.addButton('Save', () => {
    const validationError = validate();
    if (validationError != null) {
      grok.shell.warning(validationError);
      return;
    }
    const firstSmiles = rgroupToRadicalForm(correctRGroups(grok.chem.convert(firstReactantInput.value ?? '', grok.chem.Notation.Unknown, grok.chem.Notation.Smiles)));
    const secondSmiles = rgroupToRadicalForm(correctRGroups(grok.chem.convert(secondReactantInput.value ?? '', grok.chem.Notation.Unknown, grok.chem.Notation.Smiles)));
    const productSmiles = rgroupToRadicalForm(correctRGroups(grok.chem.convert(productInput.value ?? '', grok.chem.Notation.Unknown, grok.chem.Notation.Smiles)));
    onOk({
      code: codeInput.value!,
      resultMonomerName: resultMonomerNameInput.value,
      firstMonomers: firstMonomersInput.value.split(',').map((s) => s.trim()).filter((s) => s.length > 0),
      secondMonomers: secondMonomersInput.value.split(',').map((s) => s.trim()).filter((s) => s.length > 0),
      firstReactantSmiles: firstSmiles,
      secondReactantSmiles: secondSmiles,
      productSmiles: productSmiles,
      rowIndex: preset?.rowIndex});
    dialog.close();
  });
  dialog.show();
}
