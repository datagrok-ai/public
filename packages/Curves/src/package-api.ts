/**
This file is auto-generated by the grok api command.
If you notice any changes, please push them to the repository.
Do not edit this file manually.
*/
import * as grok from 'datagrok-api/grok';
import * as DG from 'datagrok-api/dg';


export namespace scripts {
  /**
  Calculates Minimum Significant Ratio (MSR) for compounds based on IC50 values, run dates, assay names, and target entities.
  */
  export async function calculateMSR(table: DG.DataFrame , ic50Column: DG.Column , compoundIdColumn: DG.Column , runDateColumn: DG.Column , assayNameColumn: DG.Column , targetEntityColumn: DG.Column ): Promise<DG.DataFrame> {
    return await grok.functions.call('Curves:CalculateMSR', { table, ic50Column, compoundIdColumn, runDateColumn, assayNameColumn, targetEntityColumn });
  }
}

export namespace funcs {
  export async function fitChartCellRenderer(): Promise<any> {
    return await grok.functions.call('Curves:FitChartCellRenderer', {});
  }

  /**
  A viewer that superimposes multiple in-cell curves on one chart
  */
  export async function multiCurveViewer(): Promise<any> {
    return await grok.functions.call('Curves:MultiCurveViewer', {});
  }

  /**
  Curve fitting is the process of constructing a curve, or mathematical function, that has the best fit to a series of data points
  */
  export async function curveFitDemo(): Promise<void> {
    return await grok.functions.call('Curves:CurveFitDemo', {});
  }

  export async function initCurves(): Promise<void> {
    return await grok.functions.call('Curves:InitCurves', {});
  }

  export async function dataToCurves(df: DG.DataFrame , concentrationCol: DG.Column , readoutCol: DG.Column , batchIDCol: DG.Column , assayCol: DG.Column , runIDCol: DG.Column , compoundIDCol: DG.Column , targetEntityCol: DG.Column , excludeOutliersCol: DG.Column | null, parentTable: DG.DataFrame | null, fitParamColumns: any | null, reportedIC50Column: string | null, reportedQualifiedIC50Column: string | null, experimentIDColumn: string | null, qualifierColumn: string | null, additionalColumns: any | null, wellLevelJoinCol: string | null, parentLevelJoinCol: string | null, wellLevelAdditionalColumns?: any | null): Promise<DG.DataFrame> {
    return await grok.functions.call('Curves:DataToCurves', { df, concentrationCol, readoutCol, batchIDCol, assayCol, runIDCol, compoundIDCol, targetEntityCol, excludeOutliersCol, parentTable, fitParamColumns, reportedIC50Column, reportedQualifiedIC50Column, experimentIDColumn, qualifierColumn, additionalColumns, wellLevelJoinCol, parentLevelJoinCol, wellLevelAdditionalColumns });
  }

  export async function dataToCurvesTopMenu(): Promise<any> {
    return await grok.functions.call('Curves:DataToCurvesTopMenu', {});
  }

  export async function addStatisticsColumn(table: DG.DataFrame , colName: string , propName: string , seriesNumber: number ): Promise<DG.Column> {
    return await grok.functions.call('Curves:AddStatisticsColumn', { table, colName, propName, seriesNumber });
  }

  export async function addAggrStatisticsColumn(table: DG.DataFrame , colName: string , propName: string , aggrType: string ): Promise<DG.Column> {
    return await grok.functions.call('Curves:AddAggrStatisticsColumn', { table, colName, propName, aggrType });
  }

  export async function rawPNGRenderer(): Promise<any> {
    return await grok.functions.call('Curves:RawPNGRenderer', {});
  }
}
