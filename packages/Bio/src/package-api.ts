/**
This file is auto-generated by the grok api command.
If you notice any changes, please push them to the repository.
Do not edit this file manually.
*/
import * as grok from 'datagrok-api/grok';
import * as DG from 'datagrok-api/dg';


export namespace scripts {
  export async function embed(molecule: string ): Promise<string> {
    return await grok.functions.call('Bio:Embed', { molecule });
  }

  /**
  Create the model peptides/DNA sequences with peptides data
  */
  export async function sequenceGenerator(clusters: number , num_sequences: number , alphabet_key: string , motif_length: number , max_variants_position: number , random_length: number , dispersion: number , activity_range: number , cliff_probability: number , cliff_strength: number , cliff_strength_dispersion: number , assay_noise_levels: string , assay_scales: string , disable_negatives: boolean , fasta_separator: string | null, helm_library_file: DG.FileInfo | null, helm_connection_mode: string ): Promise<DG.DataFrame> {
    return await grok.functions.call('Bio:SequenceGenerator', { clusters, num_sequences, alphabet_key, motif_length, max_variants_position, random_length, dispersion, activity_range, cliff_probability, cliff_strength, cliff_strength_dispersion, assay_noise_levels, assay_scales, disable_negatives, fasta_separator, helm_library_file, helm_connection_mode });
  }
}

export namespace funcs {
  export async function test1(): Promise<any> {
    return await grok.functions.call('Bio:Test1', {});
  }

  /**
  Returns an instance of the monomer library helper
  */
  export async function getMonomerLibHelper(): Promise<any> {
    return await grok.functions.call('Bio:GetMonomerLibHelper', {});
  }

  export async function initBio(): Promise<void> {
    return await grok.functions.call('Bio:InitBio', {});
  }

  export async function sequenceTooltip(col: DG.Column ): Promise<any> {
    return await grok.functions.call('Bio:SequenceTooltip', { col });
  }

  export async function standardiseMonomerLibrary(library: string ): Promise<string> {
    return await grok.functions.call('Bio:StandardiseMonomerLibrary', { library });
  }

  /**
  Matches molecules in a column with monomers from the selected library(s)
  */
  export async function matchWithMonomerLibrary(table: DG.DataFrame , molecules: DG.Column , polymerType: string ): Promise<void> {
    return await grok.functions.call('Bio:MatchWithMonomerLibrary', { table, molecules, polymerType });
  }

  export async function getBioLib(): Promise<any> {
    return await grok.functions.call('Bio:GetBioLib', {});
  }

  export async function getSeqHandler(sequence: DG.Column ): Promise<any> {
    return await grok.functions.call('Bio:GetSeqHandler', { sequence });
  }

  /**
  Creates a new column with sequences of the region between start and end
  */
  export async function getRegionPanel(seqCol: DG.Column ): Promise<any> {
    return await grok.functions.call('Bio:GetRegionPanel', { seqCol });
  }

  export async function libraryPanel(seqColumn: DG.Column ): Promise<any> {
    return await grok.functions.call('Bio:LibraryPanel', { seqColumn });
  }

  export async function getRegionEditor(call: any ): Promise<void> {
    return await grok.functions.call('Bio:GetRegionEditor', { call });
  }

  export async function splitToMonomersEditor(call: any ): Promise<void> {
    return await grok.functions.call('Bio:SplitToMonomersEditor', { call });
  }

  export async function sequenceSpaceEditor(call: any ): Promise<void> {
    return await grok.functions.call('Bio:SequenceSpaceEditor', { call });
  }

  export async function seqActivityCliffsEditor(call: any ): Promise<void> {
    return await grok.functions.call('Bio:SeqActivityCliffsEditor', { call });
  }

  export async function customSequenceCellRenderer(): Promise<any> {
    return await grok.functions.call('Bio:CustomSequenceCellRenderer', {});
  }

  export async function fastaSequenceCellRenderer(): Promise<any> {
    return await grok.functions.call('Bio:FastaSequenceCellRenderer', {});
  }

  export async function separatorSequenceCellRenderer(): Promise<any> {
    return await grok.functions.call('Bio:SeparatorSequenceCellRenderer', {});
  }

  export async function bilnSequenceCellRenderer(): Promise<any> {
    return await grok.functions.call('Bio:BilnSequenceCellRenderer', {});
  }

  export async function refineNotationProviderForBiln(col: DG.Column , stats: any , separator?: string | null): Promise<boolean> {
    return await grok.functions.call('Bio:RefineNotationProviderForBiln', { col, stats, separator });
  }

  export async function macroMolColumnPropertyPanel(molColumn: DG.Column ): Promise<any> {
    return await grok.functions.call('Bio:MacroMolColumnPropertyPanel', { molColumn });
  }

  export async function compositionAnalysisWidget(sequence: any ): Promise<any> {
    return await grok.functions.call('Bio:CompositionAnalysisWidget', { sequence });
  }

  export async function macromoleculeDifferenceCellRenderer(): Promise<any> {
    return await grok.functions.call('Bio:MacromoleculeDifferenceCellRenderer', {});
  }

  export async function sequenceAlignment(alignType: string , alignTable: string , gap: number , seq1: string , seq2: string ): Promise<any> {
    return await grok.functions.call('Bio:SequenceAlignment', { alignType, alignTable, gap, seq1, seq2 });
  }

  /**
  WebLogo
  */
  export async function webLogoViewer(): Promise<any> {
    return await grok.functions.call('Bio:WebLogoViewer', {});
  }

  /**
  V-Domain regions viewer
  */
  export async function vdRegionsViewer(): Promise<any> {
    return await grok.functions.call('Bio:VdRegionsViewer', {});
  }

  /**
  Gets a new column with sequences of the region between start and end
  */
  export async function getRegion(sequence: DG.Column , start?: string , end?: string , name?: string ): Promise<DG.Column> {
    return await grok.functions.call('Bio:GetRegion', { sequence, start, end, name });
  }

  /**
  Get sequences for a region specified from a Macromolecule
  */
  export async function getRegionTopMenu(table: DG.DataFrame , sequence: DG.Column , start?: string , end?: string , name?: string ): Promise<void> {
    return await grok.functions.call('Bio:GetRegionTopMenu', { table, sequence, start, end, name });
  }

  /**
  Detects pairs of molecules with similar structure and significant difference in any given property
  */
  export async function activityCliffs(table: DG.DataFrame , molecules: string , activities: DG.Column , similarity: number , methodName: string , similarityMetric: string , preprocessingFunction: any , options?: any , demo?: boolean ): Promise<void> {
    return await grok.functions.call('Bio:ActivityCliffs', { table, molecules, activities, similarity, methodName, similarityMetric, preprocessingFunction, options, demo });
  }

  export async function macromoleculePreprocessingFunction(col: DG.Column , metric: string , gapOpen?: number , gapExtend?: number , fingerprintType?: string ): Promise<any> {
    return await grok.functions.call('Bio:MacromoleculePreprocessingFunction', { col, metric, gapOpen, gapExtend, fingerprintType });
  }

  export async function helmPreprocessingFunction(col: DG.Column , _metric: string ): Promise<any> {
    return await grok.functions.call('Bio:HelmPreprocessingFunction', { col, _metric });
  }

  /**
  Creates 2D sequence space with projected sequences by pairwise distance
  */
  export async function sequenceSpaceTopMenu(table: DG.DataFrame , molecules: DG.Column , methodName: string , similarityMetric: string , plotEmbeddings: boolean , preprocessingFunction?: any , options?: any , clusterEmbeddings?: boolean , isDemo?: boolean ): Promise<void> {
    return await grok.functions.call('Bio:SequenceSpaceTopMenu', { table, molecules, methodName, similarityMetric, plotEmbeddings, preprocessingFunction, options, clusterEmbeddings, isDemo });
  }

  /**
  Converts sequences to molblocks
  */
  export async function toAtomicLevel(table: DG.DataFrame , seqCol: DG.Column , nonlinear: boolean , highlight: boolean ): Promise<void> {
    return await grok.functions.call('Bio:ToAtomicLevel', { table, seqCol, nonlinear, highlight });
  }

  export async function toAtomicLevelAction(seqCol: DG.Column ): Promise<void> {
    return await grok.functions.call('Bio:ToAtomicLevelAction', { seqCol });
  }

  export async function toAtomicLevelPanel(sequence: any ): Promise<any> {
    return await grok.functions.call('Bio:ToAtomicLevelPanel', { sequence });
  }

  export async function sequence3dStructureWidget(sequence: any ): Promise<any> {
    return await grok.functions.call('Bio:Sequence3dStructureWidget', { sequence });
  }

  /**
  Performs multiple sequence alignment
  */
  export async function multipleSequenceAlignmentDialog(): Promise<void> {
    return await grok.functions.call('Bio:MultipleSequenceAlignmentDialog', {});
  }

  /**
  Multiple sequence alignment
  */
  export async function alignSequences(sequenceCol: DG.Column , clustersCol: DG.Column , options?: any ): Promise<DG.Column> {
    return await grok.functions.call('Bio:AlignSequences', { sequenceCol, clustersCol, options });
  }

  /**
  Visualizes sequence composition on a WebLogo plot
  */
  export async function compositionAnalysis(): Promise<any> {
    return await grok.functions.call('Bio:CompositionAnalysis', {});
  }

  /**
  Opens FASTA file
  */
  export async function importFasta(fileContent: string ): Promise<any> {
    return await grok.functions.call('Bio:ImportFasta', { fileContent });
  }

  /**
  Opens Bam file
  */
  export async function importBam(fileContent: string ): Promise<any> {
    return await grok.functions.call('Bio:ImportBam', { fileContent });
  }

  export async function convertDialog(): Promise<void> {
    return await grok.functions.call('Bio:ConvertDialog', {});
  }

  export async function convertColumnAction(col: DG.Column ): Promise<void> {
    return await grok.functions.call('Bio:ConvertColumnAction', { col });
  }

  export async function monomerCellRenderer(): Promise<any> {
    return await grok.functions.call('Bio:MonomerCellRenderer', {});
  }

  export async function testDetectMacromolecule(path: string ): Promise<DG.DataFrame> {
    return await grok.functions.call('Bio:TestDetectMacromolecule', { path });
  }

  export async function splitToMonomersTopMenu(table: DG.DataFrame , sequence: DG.Column ): Promise<DG.DataFrame> {
    return await grok.functions.call('Bio:SplitToMonomersTopMenu', { table, sequence });
  }

  export async function getHelmMonomers(sequence: DG.Column ): Promise<any> {
    return await grok.functions.call('Bio:GetHelmMonomers', { sequence });
  }

  export async function similaritySearchViewer(): Promise<any> {
    return await grok.functions.call('Bio:SimilaritySearchViewer', {});
  }

  /**
  Finds similar sequences
  */
  export async function similaritySearchTopMenu(): Promise<any> {
    return await grok.functions.call('Bio:SimilaritySearchTopMenu', {});
  }

  export async function diversitySearchViewer(): Promise<any> {
    return await grok.functions.call('Bio:DiversitySearchViewer', {});
  }

  /**
  Finds the most diverse sequences
  */
  export async function diversitySearchTopMenu(): Promise<any> {
    return await grok.functions.call('Bio:DiversitySearchTopMenu', {});
  }

  export async function searchSubsequenceEditor(call: any ): Promise<void> {
    return await grok.functions.call('Bio:SearchSubsequenceEditor', { call });
  }

  export async function subsequenceSearchTopMenu(macromolecules: DG.Column ): Promise<void> {
    return await grok.functions.call('Bio:SubsequenceSearchTopMenu', { macromolecules });
  }

  /**
  Adds a column with fraction of matching monomers
  */
  export async function sequenceIdentityScoring(table: DG.DataFrame , macromolecule: DG.Column , reference: string ): Promise<DG.Column> {
    return await grok.functions.call('Bio:SequenceIdentityScoring', { table, macromolecule, reference });
  }

  /**
  Adds a column with similarity scores, calculated as sum of monomer fingerprint similarities
  */
  export async function sequenceSimilarityScoring(table: DG.DataFrame , macromolecule: DG.Column , reference: string ): Promise<DG.Column> {
    return await grok.functions.call('Bio:SequenceSimilarityScoring', { table, macromolecule, reference });
  }

  /**
  Manage HELM monomer libraries
  */
  export async function manageMonomerLibraries(): Promise<void> {
    return await grok.functions.call('Bio:ManageMonomerLibraries', {});
  }

  export async function manageLibrariesView(): Promise<void> {
    return await grok.functions.call('Bio:ManageLibrariesView', {});
  }

  /**
  Edit and create monomers
  */
  export async function manageMonomersView(): Promise<void> {
    return await grok.functions.call('Bio:ManageMonomersView', {});
  }

  export async function manageMonomerLibrariesView(): Promise<DG.View> {
    return await grok.functions.call('Bio:ManageMonomerLibrariesView', {});
  }

  export async function manageMonomerLibrariesViewTreeBrowser(treeNode: any ): Promise<void> {
    return await grok.functions.call('Bio:ManageMonomerLibrariesViewTreeBrowser', { treeNode });
  }

  /**
  As FASTA...
  */
  export async function saveAsFasta(): Promise<void> {
    return await grok.functions.call('Bio:SaveAsFasta', {});
  }

  /**
  Substructure filter for macromolecules
  */
  export async function bioSubstructureFilter(): Promise<any> {
    return await grok.functions.call('Bio:BioSubstructureFilter', {});
  }

  /**
  Substructure filter for Helm package tests
  */
  export async function bioSubstructureFilterTest(): Promise<any> {
    return await grok.functions.call('Bio:BioSubstructureFilterTest', {});
  }

  export async function webLogoLargeApp(): Promise<void> {
    return await grok.functions.call('Bio:WebLogoLargeApp', {});
  }

  export async function webLogoAggApp(): Promise<void> {
    return await grok.functions.call('Bio:WebLogoAggApp', {});
  }

  export async function getRegionApp(): Promise<void> {
    return await grok.functions.call('Bio:GetRegionApp', {});
  }

  export async function getRegionHelmApp(): Promise<void> {
    return await grok.functions.call('Bio:GetRegionHelmApp', {});
  }

  export async function longSeqTableSeparator(): Promise<void> {
    return await grok.functions.call('Bio:LongSeqTableSeparator', {});
  }

  export async function longSeqTableFasta(): Promise<void> {
    return await grok.functions.call('Bio:LongSeqTableFasta', {});
  }

  export async function longSeqTableHelm(): Promise<void> {
    return await grok.functions.call('Bio:LongSeqTableHelm', {});
  }

  export async function addCopyMenu(cell: any , menu: any ): Promise<void> {
    return await grok.functions.call('Bio:AddCopyMenu', { cell, menu });
  }

  /**
  Sequence similarity tracking and evaluation dataset diversity
  */
  export async function demoBioSimilarityDiversity(): Promise<void> {
    return await grok.functions.call('Bio:DemoBioSimilarityDiversity', {});
  }

  /**
  Exploring sequence space of Macromolecules, comparison with hierarchical clustering results
  */
  export async function demoBioSequenceSpace(): Promise<void> {
    return await grok.functions.call('Bio:DemoBioSequenceSpace', {});
  }

  /**
  Activity Cliffs analysis on Macromolecules data
  */
  export async function demoBioActivityCliffs(): Promise<void> {
    return await grok.functions.call('Bio:DemoBioActivityCliffs', {});
  }

  /**
  Atomic level structure of Macromolecules
  */
  export async function demoBioAtomicLevel(): Promise<void> {
    return await grok.functions.call('Bio:DemoBioAtomicLevel', {});
  }

  export async function sdfToJsonLib(table: DG.DataFrame ): Promise<void> {
    return await grok.functions.call('Bio:SdfToJsonLib', { table });
  }

  /**
  Converts a `Macromolecule` sequence to its atomic level `Molecule` representation
  */
  export async function seq2atomic(seq: string , nonlinear: boolean ): Promise<string> {
    return await grok.functions.call('Bio:Seq2atomic', { seq, nonlinear });
  }

  /**
  Gets identity to a reference sequence
  */
  export async function seqIdentity(seq: string , ref: string ): Promise<number> {
    return await grok.functions.call('Bio:SeqIdentity', { seq, ref });
  }

  export async function detectMacromoleculeProbe(file: DG.FileInfo , colName: string , probeCount: number ): Promise<void> {
    return await grok.functions.call('Bio:DetectMacromoleculeProbe', { file, colName, probeCount });
  }

  export async function getSeqHelper(): Promise<any> {
    return await grok.functions.call('Bio:GetSeqHelper', {});
  }

  export async function getMolFromHelm(df: DG.DataFrame , helmCol: DG.Column , chiralityEngine: boolean ): Promise<DG.Column> {
    return await grok.functions.call('Bio:GetMolFromHelm', { df, helmCol, chiralityEngine });
  }
}
