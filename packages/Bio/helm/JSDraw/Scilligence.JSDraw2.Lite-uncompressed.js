//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

DEBUG = {
    enable: false,
    clear: function () {
        if (DEBUG.enable)
            document.getElementById("DEBUG").value = '';
    },
    print: function (s) {
        if (DEBUG.enable) {
            var console = document.getElementById("DEBUG");
            console.value += s + "\n";
        }
    }
};


/**
* scilligence namespace (scil is an alias name)
* @namespace scilligence
*/
scilligence = { _base: function () { } };
oln = scilligence;
scil = scilligence;

/**
* scilligence.apply is a tool function to append new properties to a dictionary object
* <pre>
* <b>Example:</b>
*    var person = { firstname: "Tony", lastname: "Yuan" };
*    scilligence.apply(person, { company: "Scilligence" });
* </pre>
* @function {function} scilligence.apply
*/
scilligence.overwrite = scilligence.apply = function (dest, atts, defaults) {
    if (defaults)
        scilligence.apply(dest, defaults);

    if (dest && atts && typeof atts == 'object') {
        for (var k in atts)
            dest[k] = atts[k];
    }
    return dest;
};

scilligence.apply(scilligence, {
    /**
    * scilligence.extend is a tool function to do OO programming in Javascript
    * <pre>
    * <b>Example:</b>
    *    // parent class, here scilligence._base is empty class
    *    Person = scilligence.extend(scilligence._base, {
    *        constructor: function(firstname, lastname) {
    *            this.firstname = firstname;
    *            this.lastname = lastname;
    *        },
    *
    *        getFullname: function() {
    *            return this.lastname + ", " + this.firstname;
    *        }
    *    });
    *
    *    // sub class
    *    Employee = scilligence.extend(Person, {
    *        constructor: function (firstname, lastname, employeeid) {
    *            this.superclass().constructor(firstname, lastname);
    *            this.employeeid = employeeid;
    *        },
    *
    *        getEmployeeID: function () {
    *            return this.employeeid;
    *        }
    *    });
    *    
    *    // define static method
    *    scilligence.apply(Employee, {
    *        kCompany: "Scilligence", // static property
    *
    *        getEmployNo: function (id) { // static method
    *            return "SCI-" + id;
    *        }
    *    }
    *
    *    // create an Employee object
    *    var e = new Employee("Tony", "Yuan", 192);
    *    var s = e.getFullname();
    * </pre>
    * @function {function} scilligence.extend
    */
    extend: function () {
        var io = function (atts) { for (var k in atts) this[k] = atts[k]; };
        var oc = Object.prototype.constructor;
        return function (sb, sp, overrides) {
            if (typeof sp == 'object') {
                overrides = sp;
                sp = sb;
                sb = overrides.constructor != oc ? overrides.constructor : function () { sp.apply(this, arguments); };
            }
            var F = function () { };
            var spp = sp.prototype;
            F.prototype = spp;
            var sbp = sb.prototype = new F();
            sbp.constructor = sb;
            sb.superclass = spp;
            if (spp.constructor == oc)
                spp.constructor = sp;
            sb.override = function (atts) { scilligence.override(sb, atts); };
            sbp.superclass = sbp.supr = (function () { return spp; });
            sbp.override = io;
            scilligence.override(sb, overrides);
            sb.extend = function (atts) { return scilligence.extend(sb, atts); };
            return sb;
        };
    } (),

    override: function (origclass, overrides) {
        if (overrides) {
            var p = origclass.prototype;
            scilligence.apply(p, overrides);
            if (document.all != null && overrides.hasOwnProperty('toString'))
                p.toString = overrides.toString;
        }
    },

    clone: function (src) {
        if (src == null)
            return null;

        if (src.length != null)
            return src.concat([]);

        var dest = {};
        scil.apply(dest, src);
        return dest;
    },

    cloneArray: function (src) {
        if (src == null)
            return null;

        if (src.length != null) {
            var ret = [];
            for (var i = 0; i < src.length; ++i) {
                if (typeof src[i] == "object")
                    ret[i] = scil.clone(src[i]);
                else
                    ret[i] = src[i];
            }
            return ret;
        }

        var dest = {};
        scil.apply(dest, src);
        return dest;
    },

    byId: function (id) {
        return document.getElementById(id);
    },

    connect: function (element, event, callback) {
        if (element == null || event == null || event == "" || callback == null)
            return;

        if (element.addEventListener != null)
            element.addEventListener(event.substr(2), function (e) { callback(e, element); });
        else if (element.attachEvent != null)
            element.attachEvent(event, function (e) { callback(e, element); });
        else
            dojo.connect(element, event, function (e) { callback(e, element); });
    }
});

scilligence.ready = dojo.ready;
scilligence.onload = dojo.addOnLoad;


/*
scilligence.getGeoLocation = function () {
    var p = null;
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function (position) { scilligence.geolocation = { x: position.coords.latitude, y: position.coords.longitude} });
    }
};
scilligence.getGeoLocation();
*/
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

// http://msdn.microsoft.com/en-us/library/cc288325(v=vs.85).aspx
function getIEVersion() {
    //    if (window.navigator.appName == "Netscape" || window.navigator.appVersion.indexOf("Edge/") > 0) {
    //        var s = window.navigator.appVersion;
    //        s = s.substr(s.indexOf("Edge/") + 5);
    //        var p = s.indexOf('.');
    //        return parseInt(s.substr(0, p));
    //    }
    if (window.navigator.appName != "Microsoft Internet Explorer" && window.navigator.appName.indexOf("MSAppHost") < 0 && !(window.navigator.appVersion.indexOf("Trident") > 0 && document.documentMode >= 11))
        return false;
    return document.documentMode == null ? (document.compatMode == "CSS1Compat" ? 7 : 6) : document.documentMode;
};

var __ieversion = getIEVersion();

var __ieAppVersion = __ieversion ? (window.postMessage ? (window.performance ? 9 : 8) : 7) : null;
if (__ieversion) {
    var silverlight = typeof (JSDraw2_disablesilverlight) == "undefined" || !JSDraw2_disablesilverlight ? "silverlight," : "";
    if (dojo.version.major <= 1 && dojo.version.minor < 7)
        dojo.config.gfxRenderer = silverlight + "vml";
    else if (__ieversion < 9)
        dojo.config.gfxRenderer = silverlight + "vml,svg";
}

dojo.require("dojo.io.script");
dojo.require("dojo.io.iframe");
dojo.require("dojox.gfx");
dojo.require("dojox.gfx.utils");
dojo.require("dojo.window");

if (typeof (__JSDraw2_TouchMol) == "undefined") {
    dojo.require("dojox.charting.Chart2D");
    dojo.require("dojox.charting.axis2d.Default");
    dojo.require("dojox.charting.plot2d.Default");
    dojo.require("dojox.charting.themes.Wetland");
}
if (!(dojo.version.major <= 1 && dojo.version.minor <= 6))
    dojo.require("dojox.storage.LocalStorageProvider");

// Canvas on Android 2.x; dojo 1.7 won't need it
if (dojo.version.major <= 1 && dojo.version.minor < 7) {
    scil.onload(function () {
        dojox.gfx.Text.prototype._renderShape = function (/* Object */ctx) {
            var s = this.shape;
            ctx.save();
            ctx.fillStyle = s.fillStyle;
            ctx.strokeStyle = s.fillStyle;
            ctx.font = s.fontStyle;
            ctx.textAlign = s.align;
            ctx.fillText(s.text, s.x, s.y);
            ctx.restore();
            ctx.stroke();
        };
    });
}

scilligence.suggestInstallSilverlight = function () {
    if (dojox.gfx.renderer == "vml") {
        if (confirm("JSDraw2.Editor runs much faster with Silverlight in IE 6,7,8.  Do you want to install Silvelight now?"))
            window.open("http://www.silverlight.net/downloads");
    }
};

function _isHtml5() {
    var ie = __ieversion;
    if (ie)
        return ie >= 9;
    else
        return document.doctype != null && document.doctype.name != null && document.doctype.name.toLowerCase() == "html"
};
function getAndroidVersion() {
    var s = window.navigator.userAgent;
    var p = s.indexOf("Android");
    if (p < 0)
        return false;
    s = s.substr(p + 8);
    p = s.indexOf(';');
    s = s.substr(0, p);
    p = s.indexOf('.');
    if (p > 0)
        s = s.substr(0, p);
    return isNaN(s) ? true : parseFloat(s);
};
function getiOSVersion() {
    var s = window.navigator.userAgent;
    var p = s.indexOf("iPad");
    if (p < 0)
        p = s.indexOf("iPhone");
    if (p < 0)
        return false;
    var p = s.indexOf('OS', p + 4);
    if (p < 0)
        return true;
    s = s.substr(p + 3);
    p = s.indexOf('_');
    s = s.substr(0, p);
    p = s.indexOf('.');
    if (p > 0)
        s = s.substr(0, p);
    return isNaN(s) ? true : parseInt(s);
};

/**
* Utils class - provides variety of tool functions
* @class scilligence.Utils
*/
scilligence.Utils = {
    __xcode: 10,
    isIE: __ieversion,
    isIE8Lower: __ieversion && __ieversion < 9,
    nativemode: window.navigator.appName.indexOf("MSAppHost") >= 0,
    isHtml5: _isHtml5(),
    isFirefox: navigator.userAgent.indexOf('Firefox') >= 0,
    isOpera: navigator.userAgent.indexOf('Opera') >= 0,
    isChrome: navigator.userAgent.indexOf('Chrome') >= 0,
    isEdge: navigator.userAgent.indexOf('Edge/') >= 0,
    isLinux: navigator.userAgent.indexOf('Linux') >= 0,
    isUbuntu: navigator.userAgent.indexOf('Ubuntu') >= 0,
    isIpad: getiOSVersion(),
    isAndroid: getAndroidVersion(),
    isTouch: navigator.userAgent.indexOf('iPad') >= 0 || navigator.userAgent.indexOf('iPhone') >= 0 || navigator.userAgent.indexOf('Android') >= 0,
    isSilverlight: null,
    lastTouchTm: 0,
    buttonWidth: 160,

    getTopWindow: function () {
        var w = window;
        while (w.parent != null && w.parent != w)
            w = w.parent;
        return w;
    },

    isRightButton: function (e) {
        if (e == null)
            return;

        if (e.which)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            return e.which == 3;
        else if ("button" in e)  // IE, Opera 
            return e.button == 2;
        return false;
    },

    isTouchDblClick: function (e) {
        var tm = new Date().getTime();
        var d = tm - scil.Utils.lastTouchTm;
        scil.Utils.lastTouchTm = tm;
        return e.touches.length == 1 && d <= 500;
    },

    /**
    * Check if a html element has a parent
    * @function {static} hasAnsestor
    * @param {DOM} obj - to be checked child
    * @param {DOM} parent
    * @returns a number
    */
    hasAnsestor: function (obj, parent) {
        if (parent == null || obj == null)
            return false;

        while (obj != null) {
            if (obj.parentNode == parent)
                return true;
            obj = obj.parentNode;
        }
        return false;
    },

    /**
    * Round a number with specific decimal
    * @function {static} round
    * @param {number} val - a number to be rounded
    * @param {number} n - the number of decimal
    * @returns a number
    */
    round: function (val, n) {
        return scil.Math.round(val, n);
    },

    /**
    * Round a number to significant digits
    * @function {static} roundToSignificantDigits
    * @param {number} d - a number to be converted
    * @param {number} digits
    * @returns a number
    */
    roundToSignificantDigits: function (d, digits) {
        if (d == 0 || isNaN(d))
            return d;

        var scale = Math.pow(10, Math.floor(this.log10(Math.abs(d))) + 1);
        return scale * this.round(d / scale, digits);
    },

    log10: function (val) {
        return Math.log(val) / Math.LN10;
    },

    /**
    * Round a number as string
    * @function {static} roundStr
    * @param {number} val - a number to be converted
    * @param {number} n - the number of decimal
    * @param {number} padding
    * @returns a string
    */
    roundStr: function (val, n, padding) {
        if (val == null || isNaN(val))
            return "";
        else if (val == 0)
            return "0";

        var d = Math.pow(10, n);
        var s = (Math.round(val * d) / d) + "";
        if (s == "0" && val != 0 || n > 0 && (Math.abs(val) < 1 / d || val < 1 && s.length < (val + "").length)) { //I#9297
            var e = Math.floor(this.log10(val));
            if (e < 1) {
                var ret = this.roundStr(val * Math.pow(10, -e), n, padding) + "e" + e;
                return parseFloat(ret) == parseFloat(s) ? s : ret;
            }
        }

        if (padding == false || n <= 0)
            return s;

        var p = s.indexOf('.');
        if (p < 0) {
            s += ".";
            p = s.length - 1;
        }

        var m = s.length - 1 - p;
        for (var i = m; i < n; ++i)
            s += "0";
        return s;
    },

    /**
    * Convert a number into a formatted string
    * @function {static} num2str
    * @param {number} val - a number to be converted
    * @param {number} n - the number of decimal
    * @param {string} unit - the unit of the number
    * @returns a string
    */
    num2str: function (val, n, unit, padding) {
        if (val == null || !isFinite(val) || isNaN(val))
            return "";

        if (unit == null)
            return this.roundStr(val, n, padding);
        else if (unit == "%")
            return this.roundStr(val * 100, n, padding) + unit;

        if (unit == "L" || unit == "l") {
            //val /= 1000;
            unit = unit.toUpperCase();
        }

        if (Math.abs(val) >= 1000)
            return this.roundStr(val / 1000, n, padding) + " " + this._convertUnit(unit, 1000);
        if (Math.abs(val) >= 1)
            return this.roundStr(val, n, padding) + " " + this._convertUnit(unit, 1);

        val *= 1000;
        if (Math.abs(val) >= 1)
            return this.roundStr(val, n, padding) + " " + this._convertUnit(unit, 0.001);

        val *= 1000;
        return this.roundStr(val, n, padding) + " " + this._convertUnit(unit, 0.000001);
    },

    _convertUnit: function (unit, scale) {
        switch (scale) {
            case 1:
                if (unit == "g/L")
                    return "mg/mL";
                else if (unit == "U/L")
                    return "mU/mL";
                else
                    return unit;
            case 1000:
                if (unit == "g/L")
                    return "g/mL";
                else if (unit == "U/L")
                    return "U/mL";
                else
                    return "k" + unit;
            case 0.001:
                if (unit == "g/L" || unit == "mg/mL")
                    return "mg/L";
                else if (unit == "U/L" || unit == "mU/mL")
                    return "mU/L";
                else
                    return "m" + unit;
            case 0.000001:
                if (unit == "g/L" || unit == "mg/mL")
                    return "ug/L";
                else if (unit == "U/L" || unit == "mU/mL")
                    return "uU/L";
                else
                    return "u" + unit;
        }
    },

    disabledcontextmenus: [],
    disableContextMenu: function (element, doc) {
        if (element != null && scil.Utils.indexOf(this.disabledcontextmenus, element) < 0)
            this.disabledcontextmenus.push(element);

        if (doc == null)
            doc = document;

        if (doc.body.__contextmenudisabled)
            return;

        doc.body.__contextmenudisabled = true;
        doc.body.oncontextmenu = function (e) {
            if (e == null)
                e = event;

            var src = e.target || e.srcElement;
            var list = scil.Utils.disabledcontextmenus;
            for (var i = 0; i < list.length; ++i) {
                if (src == list[i] || scil.Utils.isChildOf(src, list[i]))
                    return false;
            }

            if (src.parentNode != null && JSDraw2.Editor.get(src.parentNode.id) != null ||
                src.firstChild != null && src.firstChild.getAttribute != null && src.firstChild.getAttribute("jspopupmenu") == "1") {
                if (e.preventDefault != null)
                    e.preventDefault();
                return false;
            }

            if (scil.ContextMenu.isFromContextMenu(src)) {
                if (e.preventDefault != null)
                    e.preventDefault();
                return false;
            }

            // fix context menu problem on Safari
            var div = scil.Utils.getParent(src, "div");
            if (div != null && JSDraw2.Editor.get(div.id) != null) {
                if (e.preventDefault != null)
                    e.preventDefault();
                return false;
            }
        };
    },

    serviceAvailable: function () {
        return typeof JSDrawServices != "undefined" && typeof JSDrawServices.url != "undefined" && JSDrawServices.url != null;
    },

    /**
    * evaluate a javascript expression
    * @function {static} eval
    * @param {string} s - javascript expression
    * @returns javascript object
    */
    eval: function (s) {
        if (s == "" || typeof (s) != "string")
            return null;

        try {
            eval("var s=" + s);
            return s;
        }
        catch (e) {
        }

        return null;
    },

    /**
    * Evaluation if an object is true.  true, 1, on, yes will be true
    * @function {static} isFalse
    * @param {object} s - the input object
    * @returns true or false
    */
    isTrue: function (s) {
        s = (s + "").toLowerCase();
        return s == "1" || s == "true" || s == "yes" || s == "on";
    },

    /**
    * Evaluation if an object is false.  false, 0, off, no will be false
    * @function {static} isFalse
    * @param {object} s - the input object
    * @returns true or false
    */
    isFalse: function (s) {
        s = (s + "").toLowerCase();
        return s == "0" || s == "false" || s == "no" || s == "off";
    },

    isAttTrue: function (e, att) {
        var s = e.getAttribute(att) + "";
        return s == "" || this.isTrue(s);
    },

    isAttFalse: function (e, att) {
        var s = e.getAttribute(att) + "";
        return s == "0" || s.toLowerCase() == "false";
    },

    /**
    * Convert a number into a formatted string
    * @function {static} formatStr
    * @param {number} v - a number to be converted
    * @param {number} w - total width the result string
    * @param {number} d - the number of demical
    * @returns a string
    */
    formatStr: function (v, w, d) {
        var s = v == null ? "" : v.toFixed(d) + "";
        return scil.Utils.padLeft(s, w, ' ');
    },

    /**
    * Generate a GUID
    * @function {static} uuid
    * @returns a string
    */
    // http://www.broofa.com/2008/09/javascript-uuid-function/
    uuid: function () {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = [];
        var i;
        var radix = chars.length;

        // rfc4122, version 4 form
        var r;

        // rfc4122 requires these characters
        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
        uuid[14] = '4';

        // Fill in random data.  At i==19 set the high bits of clock sequence as
        // per rfc4122, sec. 4.1.5
        for (i = 0; i < 36; i++) {
            if (!uuid[i]) {
                r = 0 | Math.random() * 16;
                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
            }
        }

        return uuid.join('').toLowerCase();
    },

    /**
    * Append chars to a string
    * @function {static} padLeft
    * @param {string} s - the input string
    * @param {number} n - total width of result string
    * @param {char} c - the character to be appended
    * @returns a string
    */
    padLeft: function (s, n, c) {
        var s1 = '';
        for (var i = (s + "").length; i < n; ++i)
            s1 += (c == null ? ' ' : c);
        return s1 + s;
    },

    /**
    * Insert chars at the beginning of a string
    * @function {static} padRight
    * @param {string} s - the input string
    * @param {number} n - total width of result string
    * @param {char} c - the character to be inserted
    * @returns a string
    */
    padRight: function (s, n, c) {
        var s1 = '';
        for (var i = s.length; i < n; ++i)
            s1 += (c == null ? ' ' : c);
        return s + s1;
    },

    /**
    * Evaluate if a string ends with another sub-string
    * @function {static} endswith
    * @param {string} s - the input string
    * @param {string} token - the sub-string to be tested
    * @returns true or false
    */
    endswith: function (s, token, casesensitive) {
        if (s == null || token == null || s.length < token.length)
            return false;
        var t = s.substr(s.length - token.length, token.length);
        if (casesensitive)
            return t == token;
        else
            return t.toLowerCase() == token.toLowerCase();
    },

    /**
    * Evaluate if a string starts with another sub-string
    * @function {static} endswith
    * @param {string} s - the input string
    * @param {string} token - the sub-string to be tested
    * @returns true or false
    */
    startswith: function (s, token, casesensitive) {
        if (s == null || token == null || s.length < token.length)
            return false;
        var t = s.substr(0, token.length);
        if (casesensitive)
            return t == token;
        else
            return t.toLowerCase() == token.toLowerCase();
    },

    /**
    * Trim a string
    * @function {static} ltrim
    * @param {string} s - the input string
    * @returns a string
    */
    trim: function (s) {
        return s == null ? null : s.replace(/^[\s|\t\r\n]+|[\s|\t\r\n]+$/g, "");
    },

    /**
    * Trim the left spaces of a string
    * @function {static} trim
    * @param {string} s - the input string
    * @returns a string
    */
    ltrim: function (s) {
        return s == null ? null : s.replace(/^[\s|\t\r\n]+/, "");
    },

    /**
    * Trim the right spaces of a string
    * @function {static} rtrim
    * @param {string} s - the input string
    * @returns a string
    */
    rtrim: function (s) {
        return s == null ? null : s.replace(/[\s|\t\r\n]+$/, "");
    },

    isFixedPosition: function (e) {
        while (e != null) {
            if (e.style != null && e.style.position == "fixed")
                return true;
            e = e.parentNode;
        }
        return false;
    },

    getOffset: function (e, scroll) {
        var d = scil.Utils.scrollOffset();
        var p = new JSDraw2.Point(0, 0);
        var e2 = e;
        while (e != null) {
            if (e.offsetLeft > 0 || e.offsetTop > 0)
                p.offset(e.offsetLeft, e.offsetTop);

            if (this.isIE && (e.scrollLeft > 0 || e.scrollTop > 0))
                p.offset(e.scrollLeft, e.scrollTop);

            if (scil.Utils.isIE) {
                if (e.scrollTop > 0 || e.scrollLeft > 0) {
                    p.offset(-e.scrollLeft, -e.scrollTop);
                }
            }

            e = e.offsetParent;
        }

        var fixed = false;
        while (e2 != null) {
            if (e2.style != null && e2.style.position == "fixed") {
                fixed = true;
                break;
            }
            e2 = e2.parentNode;
        }

        //if (__ieversion && __ieAppVersion < 8)
        //    p.offset(d.x, d.y);

        if (scroll != false && !fixed)
            p.offset(-d.x, -d.y);
        if (fixed)
            p.fixedposition = true;
        return p;
    },

    getScrollOffset: function (e) {
        var p = new JSDraw2.Point(0, 0);
        while (e != null) {
            if (e.scrollLeft > 0 || e.scrollTop > 0)
                p.offset(e.scrollLeft, e.scrollTop);
            e = e.offsetParent;
        }
        return p;
    },

    scrollOffset: function () {
        var iebody = (document.compatMode && document.compatMode != "BackCompat") ? document.documentElement : document.body;

        var x = scil.Utils.isIE ? iebody.scrollLeft : pageXOffset;
        var y = scil.Utils.isIE ? iebody.scrollTop : pageYOffset;

        return new JSDraw2.Point(x, y);
    },

    scriptUrl: function () {
        if (this._scripturl != null)
            return this._scripturl;
        if (JSDraw2.defaultoptions.imagebase != null)
            this._scripturl = JSDraw2.defaultoptions.imagebase;
        if (this._scripturl != null)
            return this._scripturl;

        var list = document.getElementsByTagName("script");
        for (var i = 0; i < list.length; i++) {
            var e = list[i];
            if (e.tagName == "SCRIPT") {
                var s = e.getAttribute('src');
                if (s == null || s.length == 0)
                    continue;

                var p = s.lastIndexOf('/');
                var path = p < 0 ? '' : scil.Utils.trim(s.substr(0, p + 1));
                var file = scil.Utils.trim(p < 0 ? s : s.substr(p + 1)).toLowerCase();
                p = file.indexOf('?');
                if (p > 0)
                    file = file.substr(0, p);

                if (this.startswith(file, "scilligence.jsdraw2.") && this.endswith(file, ".js")) {
                    if (scil.Utils.startswith(path, "http://") || scil.Utils.startswith(path, "https://") || scil.Utils.startswith(path, "//"))
                        return this._scripturl = path;

                    if (scil.Utils.startswith(path, '/'))
                        return this._scripturl = document.location.protocol + "//" + document.location.host + path;

                    var url = document.location + "";
                    p = url.indexOf('?');
                    if (p > 0)
                        url = url.substr(0, p);

                    p = url.lastIndexOf('/');
                    return this._scripturl = url.substr(0, p + 1) + path;
                }
                else if (file == "jsdraw.core.js") {
                    return this._scripturl = path + "../";
                }
            }
        }

        return null;
    },

    _imgBase: function () {
        return scil.Utils.scriptUrl();
    },

    imgSrc: function (button, wrapasinurl) {
        var s = scil.Utils._imgBase() + button;
        if (wrapasinurl)
            s = "url(" + s + ")";
        return s;
    },

    imgTag: function (b, label, extra) {
        return "<img" + (extra == null ? "" : " " + extra) + " src='" + this.imgSrc("img/" + b) + "'>" + (label == null ? "" : label);
    },

    styleRect: function (e) {
        return new JSDraw2.Rect(scil.Utils.parsePixel(e.style.left),
            scil.Utils.parsePixel(e.style.top),
            scil.Utils.parsePixel(e.style.width),
            scil.Utils.parsePixel(e.style.height));
    },

    parsePixel: function (s, defaultvalue) {
        if (s == null)
            return null;
        if (!scil.Utils.endswith(s, "px"))
            return defaultvalue;

        s = s.substr(0, s.length - 2);
        return isNaN(s) ? defaultvalue : parseInt(s);
    },

    /**
    * Clone an array
    * @function {static} cloneArray
    * @param {array} ar - the array to be cloned
    * @returns a new array
    */
    cloneArray: function (ar) {
        var r = [];
        this.mergeArray(r, ar);
        return r;
    },

    /**
    * Merge two arrays
    * @function {static} mergeArray
    * @param {array} dest - the destination array to be merged to
    * @param {array} src - the source arrays to be merged from
    * @returns null
    */
    mergeArray: function (dest, src) {
        for (var i = 0; i < src.length; ++i)
            dest.push(src[i]);
    },

    /**
    * Find the index of an item in an array
    * @function {static} mergeArray
    * @param {array} ar - the array to be searched
    * @param {object} i - the item to be searched
    * @returns the index if succeeded; -1 if failed
    */
    fingArrayIndex: function (ar, i) {
        for (var k = 0; k < ar.length; ++k) {
            if (ar[k] == i)
                return k;
        }
        return -1;
    },

    getFunctionName: function (f) {
        if (typeof f == "function") {
            var fName = (f + "").match(/function\s*([\w\$]*)\s*\(/);
            if (fName !== null)
                return fName[1];
        }

        return null;
    },

    splitCsvRow: function (s) {
        if (s == null || s == "\r" || s == "")
            return;

        if (s.substr(s.length - 1) == "\r")
            s = s.substr(0, s.length - 1);

        var ret = [];

        var inquote = false;
        var v = "";
        for (var i = 0; i < s.length; ++i) {
            var c = s.substr(i, 1);
            if (c == '\"') {
                if (!inquote) {
                    if (v == "")
                        inquote = true;
                    else
                        v += c;
                }
                else {
                    if (i < s.length - 1) {
                        var c1 = s.substr(i + 1, 1);
                        if (c1 == '\"') {
                            v += c;
                            ++i;
                        }
                        else if (c1 == ',') {
                            ret.push(v);
                            v = "";
                            inquote = false;
                            ++i;
                        }
                        else {
                            v += c;
                        }
                    }
                    else {
                        inquote = false;
                    }
                }
            }
            else if (c == ',') {
                if (inquote) {
                    v += c;
                }
                else {
                    ret.push(v);
                    v = "";
                }
            }
        }

        ret.push(v);

        return ret;
    },

    escCsvValue: function (v) {
        if (v == null)
            return "";
        if (typeof (v) != "string")
            v = v + "";
        if (v.indexOf(',') >= 0 || v.indexOf('\"') >= 0 || v.indexOf('\r') >= 0 || v.indexOf('\n') >= 0)
            v = '\"' + v.replace(/[\"]/g, "\"\"").replace(/\r\n/g, "") + '\"';
        return v;
    },

    /**
    * Unescape an xml value
    * @function {static} unescXmlValue
    * @param {object} v - the input string
    * @returns a string
    */
    unescXmlValue: function (v) {
        if (v == null)
            return '';
        return v.replace(/&lt;/gi, "<").replace(/&gt;/gi, ">").replace(/&#xA;/gi, "\n").replace(/&apos;/g, "'").replace(/&quot;/g, "\"").replace(/&amp;/gi, "&");
    },

    /**
    * Escape the object as the xml value
    * @function {static} escXmlValue
    * @param {object} v - the input object
    * @param {bool} trim - indicate if trim the spaces
    * @returns a string
    */
    escXmlValue: function (v, trim) {
        if (v == null)
            return '';

        if (typeof (v) != "string")
            v = v + "";

        if (trim)
            v = scil.Utils.trim(v);
        return v.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;").replace(/\n/g, "&#xA;").replace(/'/g, "&apos;").replace(/"/g, "&quot;");
    },

    escUrlData: function (s) {
        if (s == null)
            return s;

        var ret = "";
        for (var i = 0; i < s.length; ++i) {
            var c = s.charCodeAt(i);
            var s1 = s.substr(i, 1);
            if (c > 255)
                ret += s1;
            else if (s1 == "+")
                ret += "%2b";
            else
                ret += escape(s1);
        }

        return ret;
    },

    escFileName: function (s) {
        if (s == null)
            return s;

        var ret = "";
        for (var i = 0; i < s.length; ++i) {
            var c = s.substr(i, 1);
            if (s.charCodeAt(i) > 255 || /[a-z|0-9|_| |\-|\(|\)|\{|\}|\[|\]|\.]/ig.test(c))
                ret += c;
            else
                ret += '_';
        }
        return ret;
    },

    getFirstChild: function (parent, tag) {
        if (parent == null)
            return null;
        for (var i = 0; i < parent.childNodes.length; ++i) {
            if (parent.childNodes[i].tagName == tag)
                return parent.childNodes[i];
        }
        return null;
    },

    /**
    * Parse an xml string
    * @function {static} parseXml
    * @param {string} xml - input xml string
    * @returns a XML document object
    */
    parseXml: function (xml) {
        var ret = this.parseXml2(xml);
        if (ret != null && ret.succeeded)
            return ret.doc;
        return null;
    },

    parseXml2: function (xml) {
        if (xml == null)
            return null;

        xml = this.trim(xml);
        if (xml.length < 10 || xml.substr(0, 1) != "<" || xml.substr(xml.length - 1, 1) != ">")
            return null;

        var succeeded = false;
        var error = null;
        var doc = null;
        try {
            xml = xml.replace(/&nbsp;/g, " "); // I#12324
            if (window.DOMParser) {
                doc = new DOMParser().parseFromString(xml, "text/xml");
            }
            else // Internet Explorer
            {
                doc = new ActiveXObject("Microsoft.XMLDOM");
                doc.async = "false";
                doc.loadXML(xml);
            }
            succeeded = true;
        }
        catch (e) {
            error = e.message;
        }

        return { succeeded: succeeded, error: error, doc: doc };
    },

    xquery: function (e, path, returnone) {
        if (e == null || path == null || path == "")
            return null;

        var ret = null;
        var list = path.split('/');
        for (var i = 0; i < list.length; ++i) {
            var s = list[i];
            if (s == "")
                continue;

            var tag = s.replace(/[\[]@[a-z]+[0-9|a-z]{0,9}='[^\']+'[\]]$/, "");
            s = s.substr(tag.length + 2, s.length - (tag.length + 3));

            var key = null;
            var val = null;
            var p = s.indexOf('=');
            if (p > 0) {
                key = s.substr(0, p);
                p += 2;
                val = s.substr(p, s.length - p - 1);
            }

            var e2 = null;
            for (var k = 0; k < e.childNodes.length; ++k) {
                var c = e.childNodes[k];
                if (c.tagName == tag) {
                    if (key == null || c.getAttribute(key) == val)
                        e2 = c;
                }

                if (e2 != null) {
                    if (i == list.length - 1) {
                        if (returnone)
                            return e2;

                        if (ret == null)
                            ret = [e2];
                        else
                            ret.push(e2);
                    }
                    else {
                        e2 = c;
                        break;
                    }
                }
            }

            if (ret != null)
                return ret;
            if (e2 == null)
                return null;
            else
                e = e2;
        }
        return null;
    },

    /**
    * Parse an json string
    * @function {static} parseJson
    * @param {string} s - input json string
    * @returns a javascript object
    */
    parseJson: function (s) {
        return this.eval(s);
    },

    /**
    * Test if a string contains a word
    * @function {static} containsWord
    * @param {string} str - the string to be tested
    * @param {string} word - the word to be tested
    * @param {bool} ignorecase - indicate if ignoring cases or not
    * @returns true of false
    */
    containsWord: function (str, word, ignorecase) {
        if (str == null || word == null || str == "" || word == "")
            return false;
        if (ignorecase)
            word = word.toLowerCase();
        var words = str.toLowerCase().split(/\W+/);
        for (var i = 0; i < words.length; ++i) {
            if (words[i] == word)
                return true;
        }
        return false;
    },

    /**
    * Show message dialog.<br>
    * For Windows 8 metro Apps, and Office Apps, standard alert() function is not allowed.  alert2() can be an alternative.
    * @function {static} alert2
    * @param {string} message - message body
    * @param {string} caption - dialog caption
    * @param {function()} callback - callback function
    * @param {string} iconurl - image url of the dialog icon
    * @param {number} width - dialog width
    * @returns null
    */
    alert2: function (message, caption, callback, iconurl, width) {
        if (scil.Utils.alertdlg == null) {
            var tbody = scil.Utils.createTable();
            var tr = scil.Utils.createElement(tbody, "tr");
            var img = scil.Utils.createElement(scil.Utils.createElement(tr, "td", null, { verticalAlign: "top" }), "img", null, { height: "50px", width: "50px" });
            var td = scil.Utils.createElement(tr, "td", null, { textAlign: "center" });
            var msg = scil.Utils.createElement(td, "div", null, { padding: "10px", textAlign: "left", maxWidth: "800px", maxHeight: "400px", overflow: "auto", color: "#000" });
            //if (scil.Utils.isIE)
            //    msg.style.height = "expression(clientHeight>360 ? '360px' : 'auto')";
            var ok = scil.Utils.createElement(td, "button", scil.Utils.imgTag("tick.gif", this.res("OK")), { width: "80px" });

            scil.Utils.alertdlg = new JSDraw2.Dialog("Attention", tbody.parentNode);
            scil.Utils.alertdlg.msg = msg;
            scil.Utils.alertdlg.img = img;

            dojo.connect(ok, "onclick", function (e) { var d = scil.Utils.alertdlg; if (d.callback != null) d.callback(); d.hide(); e.preventDefault(); });
        }

        if (iconurl == null || iconurl == "")
            iconurl = scil.Utils.imgSrc("img/information.gif");
        else if (!scil.Utils.startswith(iconurl, "http:"))
            iconurl = scil.Utils.imgSrc("img/" + iconurl + ".gif");
        scil.Utils.alertdlg.show(caption);
        scil.Utils.alertdlg.callback = callback;
        scil.Utils.alertdlg.msg.innerHTML = message == null ? '' : "<div style='margin:0;max-width:800px;'>" + message + "</div>";
        scil.Utils.alertdlg.img.src = iconurl;

        scil.Utils.alertdlg.moveCenter();
    },

    /**
    * Show confirm dialog.<br>
    * For Windows 8 metro Apps, and Office Apps, standard confirm() function is not allowed.  confirm() can be an alternative.
    * @function {static} confirm
    * @param {string} message - message body
    * @param {function(string status)} callback - callback function. status value: true, false, 'cancel'
    * @param {bool} cancelbtn - indicate if it shows Cancel button or not
    * @param {string} caption - dialog caption
    * @returns null
    */
    confirm: function (message, callback, cancelbtn, caption, owner) {
        if (scil.Utils.confirmdlg == null) {
            var tbody = scil.Utils.createTable();
            var tr = scil.Utils.createElement(tbody, "tr");
            scil.Utils.createElement(tr, "td", "<img style='width:50px;height:50px;' src='" + scil.Utils.imgSrc("img/question.gif") + "'>", { verticalAlign: "top" });
            var td = scil.Utils.createElement(tr, "td", null, { textAlign: "center" });
            var msg = scil.Utils.createElement(td, "div", null, { padding: "10px", textAlign: "left", maxHeight: "360px", color: "black" });
            //if (scil.Utils.isIE)
            //    msg.style.height = "expression(clientHeight>360 ? '360px' : 'auto')";
            var yes = scil.Utils.createElement(td, "button", this.res("Yes"), { width: "80px" });
            var no = scil.Utils.createElement(td, "button", this.res("No"), { width: "80px" });
            var cancel = scil.Utils.createElement(td, "button", this.res("Cancel"), { width: "80px" });

            scil.Utils.confirmdlg = new JSDraw2.Dialog(this.res("Attention"), tbody.parentNode);
            scil.Utils.confirmdlg.msg = msg;
            scil.Utils.confirmdlg.cancel = cancel;

            dojo.connect(yes, "onclick", function (e) { var d = scil.Utils.confirmdlg; d.hide(); e.preventDefault(); if (d.callback != null) d.callback(true); });
            dojo.connect(no, "onclick", function (e) { var d = scil.Utils.confirmdlg; d.hide(); e.preventDefault(); if (d.callback != null) d.callback(false); });
            dojo.connect(cancel, "onclick", function (e) { var d = scil.Utils.confirmdlg; d.hide(); e.preventDefault(); if (d.callback != null) d.callback('cancel'); });
        }

        scil.Utils.confirmdlg.show();
        scil.Utils.confirmdlg.callback = callback;
        scil.Utils.confirmdlg.cancel.style.display = cancelbtn ? '' : "none";
        scil.Utils.confirmdlg.msg.innerHTML = message == null ? '' : "<pre style='margin:0'>" + message + "</pre>";
        scil.Utils.confirmdlg.hide(true);
        scil.Utils.confirmdlg.show(caption, null, null, null, owner);
    },

    /**
    * A simple version confirm dialog, only showing Yes, No button
    * @function {static} confirmYes
    * @param {string} message - message body
    * @param {function()} callback - callback function.
    * @returns null
    */
    confirmYes: function (message, callback, owner) {
        scil.Utils.confirm(message, function (f) { if (f) callback(); }, null, null, owner);
    },

    /**
    * Show prompt dialog, and ask to input a string<br>
    * For Windows 8 metro Apps, and Office Apps, standard prompt() function is not allowed.  This prompt() can be an alternative.
    * @function {static} prompt2
    * @param {string} caption - dialog caption
    * @param {string} message - message body
    * @param {string} defaultvalue - default value in the input box
    * @param {string} button - the button label
    * @param {function()} callback - callback function.
    * @param {string} iconurl - the url of dialog icon
    * @param {bool} zindex - zIndex of the dialog
    * @param {bool} multiline - indicate if showing multiline input box
    * @param {number} height
    * @returns null
    */
    prompt2: function (options) {
        return this.prompt(options.caption, options.message, options.defaultvalue, options.button,
            options.callback, options.iconurl, options.zindex, options.multiline, options.autosuggesturl, options.owner,
            options.maxlength, options.height);
    },

    /**
    * Show prompt dialog, and ask to input a string<br>
    * For Windows 8 metro Apps, and Office Apps, standard prompt() function is not allowed.  This prompt() can be an alternative.
    * @function {static} prompt
    * @param {string} caption - dialog caption
    * @param {string} message - message body
    * @param {string} defaultval - default value in the input box
    * @param {string} btn - the button label
    * @param {function()} callback - callback function.
    * @param {string} iconurl - the url of dialog icon
    * @param {bool} zindex - zIndex of the dialog
    * @param {bool} multiline - indicate if showing multiline input box
    * @returns null
    */
    prompt: function (caption, message, defaultval, btn, callback, iconurl, zindex, multiline, autosuggesturl, owner, maxlength, height) {
        if (scil.Utils.promptdlg == null) {
            var tbody = scil.Utils.createTable();
            var tr = scil.Utils.createElement(tbody, "tr");
            var icon = scil.Utils.createElement(scil.Utils.createElement(tr, "td"), "div", null, { width: "50px" });
            var td = scil.Utils.createElement(tr, "td");
            var msg = scil.Utils.createElement(td, "div", null, { color: "black" });

            var div = scil.Utils.createElement(td, "div");
            var input = scil.Utils.createElement(div, "input", null, { width: "360px", display: "none" });
            input.setAttribute("x-webkit-speech", "on");
            var textarea = scil.Utils.createElement(div, "textarea", null, { width: "360px", display: "none" });

            var div = scil.Utils.createElement(td, "div", null, { textAlign: "center", paddingTop: "5px" });
            var button = scil.Utils.createElement(div, "button", btn, { width: scil.Utils.buttonWidth + "px" });

            var dlg = scil.Utils.promptdlg = new JSDraw2.Dialog(this.res("Message"), tbody.parentNode);
            dlg.icon = icon;
            dlg.msg = msg;
            dlg.input = input;
            dlg.textarea = textarea;
            dlg.button = button;

            var fn = function (e) { var d = dlg; d.hide(); if (d.callback != null) d.callback(d.input.style.display == "none" ? d.textarea.value : d.input.value, d.input.style.display == "none" ? d.textarea : d.input); if (e.preventDefault != null) e.preventDefault(); };
            dojo.connect(dlg.input, "onkeydown", function (e) { if (e.keyCode == 13) { fn(e); } });
            dojo.connect(button, "onclick", fn);

            dlg.auto = new scil.AutoComplete(input, null);
        }

        var dlg = scil.Utils.promptdlg;

        dlg.input.style.display = multiline ? "none" : "";
        dlg.textarea.style.display = multiline ? "" : "none";
        dlg.input.setAttribute("maxlength", maxlength > 0 ? maxlength : "");

        if (height > 0) {
            dlg.input.style.height = height + "px";
            dlg.textarea.style.height = height + "px";
        }
        else {
            dlg.input.style.height = "";
            dlg.textarea.style.height = "";
        }

        dlg.auto.url = autosuggesturl;
        dlg.auto.disabled = autosuggesturl == null || autosuggesturl == "";

        dlg.show(caption, zindex);
        if (iconurl == null) {
            dlg.icon.innerHTML = "&nbsp;";
        }
        else {
            dlg.icon.innerHTML = "<img style='width:50px;height:50px;' src='" + iconurl + "'>";
            dlg.icon.style.display = "";
        }

        dlg.msg.innerHTML = message == null ? '' : message;
        dlg.button.innerHTML = btn == null ? this.res("OK") : this.res(btn);
        (multiline ? dlg.textarea : dlg.input).value = defaultval == null ? '' : defaultval;
        dlg.callback = callback;

        dlg.hide(true);
        dlg.show2({ owner: owner });
        (multiline ? dlg.textarea : dlg.input).select();
        (multiline ? dlg.textarea : dlg.input).focus();
    },

    /**
    * Create a Cookie
    * @function {static} createCookie
    * @param {string} name - the cookie's name
    * @param {string} value - the value of the cookie
    * @param {number} days - total days that the cookie will expire
    * @returns null
    */
    createCookie: function (name, value, days, ignoreStore) {
        if (!ignoreStore) {
            var store = dojox.storage == null || dojox.storage.LocalStorageProvider == null ? null : new dojox.storage.LocalStorageProvider();
            if (store != null && store.isAvailable()) {
                store.initialize();
                store.put(name, value);
                return;
            }
        }

        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        document.cookie = name + "=" + escape(value) + expires + "; path=/";
    },

    /**
    * Read a Cookie
    * @function {static} readCookie
    * @param {string} name - the cookie's name
    * @returns the value of the cookie as a string
    */
    readCookie: function (name, ignoreStore) {
        if (!ignoreStore) {
            var store = dojox.storage == null || dojox.storage.LocalStorageProvider == null ? null : new dojox.storage.LocalStorageProvider();
            if (store != null && store.isAvailable()) {
                store.initialize();
                return store.get(name);
            }
        }

        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ')
                c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0)
                return unescape(c.substring(nameEQ.length, c.length));
        }
        return null;
    },

    /**
    * Erase a Cookie
    * @function {static} eraseCookie
    * @param {string} name - the cookie's name
    * @returns null
    */
    eraseCookie: function (name) {
        if (dojox.storage != null && dojox.storage.LocalStorageProvider != null) {
            var store = new dojox.storage.LocalStorageProvider();
            if (store.isAvailable()) {
                store.initialize();
                store.remove(name);
            }
        }

        this.createCookie(name, "", -1);
    },

    /**
    * Format file size
    * @function {static} formatFilesize
    * @param {number} s - file size
    * @returns a string
    */
    formatFilesize: function (filesize) {
        if (!(filesize > 0))
            return "";

        if (filesize / 1000 < 1)
            return filesize + "Bytes";
        filesize = filesize / 1000;
        if (filesize / 1000 < 1)
            return Math.round(filesize * 10) / 10 + "KB";
        filesize = filesize / 1000;
        if (filesize / 1000 < 1)
            return Math.round(filesize * 10) / 10 + "MB";
        filesize = filesize / 1000;
        if (filesize / 1000 < 1)
            return Math.round(filesize * 10) / 10 + "GB";
        filesize = filesize / 1024;
        return Math.round(filesize * 10) / 10 + "TB";
    },

    today: function () {
        return scil.Utils.trunc2date(new Date());
    },

    trunc2date: function (d) {
        return d == null ? null : new Date(d.getFullYear(), d.getMonth(), d.getDate());
    },

    time: function (tm) {
        if (tm == null)
            return new Date();

        var t = null;
        if (typeof (tm) == "string") {
            if (/^[0-9]+$/.test(tm)) {
                tm = parseInt(tm);
            }
            else {
                var ss = tm.split('-');
                if (ss.length == 3) {
                    var y = parseInt(ss[0]);
                    var m = ss[1].length == 3 ? this._parseMonth(ss[1]) : (parseInt(ss[1]) - 1);
                    var d = parseInt(ss[2]);

                    if (y > 0 && m >= 0 && m < 12 && d > 0 && d <= 31)
                        return new Date(y, m, d);
                }
            }
        }
        if (t == null)
            t = new Date(tm);

        // If tm is a string, like 2015-04-30, the time is UTC time.  Convert it into local time.
        var offset = t.getTimezoneOffset();
        if (isNaN(offset))
            offset = 0;
        return new Date(t.getTime() + offset * 60000);
    },

    _months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    _weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],

    weekday: function (dt) {
        return this._weekdays[dt.getDay()];
    },

    _parseMonth: function (s) {
        if (s == null || s.length != 3)
            return -1;
        s = s.substr(0, 1).toUpperCase() + s.substr(1).toLowerCase();
        return scil.Utils.indexOf(this._months, s);
    },

    isnull: function (s, defaultvalue) {
        return this.isNullOrEmpty(s) ? defaultvalue : s;
    },

    iif: function(condition, yes, no) {
        return condition ? yes : no;
    },

    formatTime: function (tm, format) {
        if (tm == 0)
            return "";
        if (tm == null)
            tm = new Date();
        if (typeof tm != "object")
            tm = scil.Utils.time(tm);

        if (JSDraw2.timezoneoffet > 0)
            tm = new Date(tm.getTime() + JSDraw2.timezoneoffet * 60 * 60 * 1000);

        // date part
        var s = format;
        if (scil.Utils.isNullOrEmpty(s))
            s = "yyyy-mmm-dd";

        s = s.replace("yyyy", tm.getFullYear())
            .replace("yy", (tm.getFullYear() + "").substr(2))
            .replace("mmm", scil.Utils._months[tm.getMonth()])
            .replace("mm", scil.Utils.padLeft(tm.getMonth() + 1, 2, '0'))
            .replace("dd", scil.Utils.padLeft(tm.getDate(), 2, '0'));

        // time part
        var h12 = s.indexOf("hh") >= 0;
        var h = tm.getHours();
        s = s.replace("hh", this.padLeft(h % 12, 2, '0'))
            .replace("HH", this.padLeft(h, 2, '0'))
            .replace("MM", this.padLeft(tm.getMinutes(), 2, '0'))
            .replace("SS", this.padLeft(tm.getSeconds(), 2, '0'))
            .replace("ss", this.padLeft(tm.getSeconds(), 2, '0'));
        if (h12)
            s += h >= 12 ? "PM" : "AM";

        return s;
    },

    /**
    * Convert a date number into visible date string
    * @function {static} dateStr
    * @param {number} tm - the number of time
    * @param {bool} classic - if classic is true, it won't show Today, Yesterday etc.
    * @returns a string
    */
    dateStr: function (input, classic, format) {
        if (scil.Utils.isNullOrEmpty(input) || input == 0)
            return "";
        var tp = typeof (input);
        if (!(tp == "object" || tp == "number" || tp == "string"))
            return "";
        var tm = input;
        if (tp != "object") {
            tm = scil.Utils.time(tm);
            if (tm == null)
                return "";
        }

        var days = (scil.Utils.today().getTime() - scil.Utils.trunc2date(tm).getTime()) / 1000 / 60 / 60 / 24;

        var ret = null;
        if (classic == null)
            classic = JSDraw2.config.classicdate; // I#13091
        if (!classic) {
            if (days == 0)
                ret = JSDraw2.Language.res("Today");
            else if (days == 1)
                ret = JSDraw2.Language.res("Yesterday");
        }

        if (ret == null) {
            if (scil.Utils.isNullOrEmpty(format)) {
                format = JSDraw2.defaultoptions.dateformat;
                if (scil.Utils.isNullOrEmpty(format))
                    format = "yyyy-mmm-dd";
            }

            // if the input is 2014-04-08, this is to fix the timezone issue
            if (typeof (input) == "string")
                tm = new Date(tm);

            ret = scil.Utils.formatTime(tm, format);
        }

        return ret;
    },

    /**
    * Convert a time number into visible time string
    * @function {static} timeStr
    * @param {number} tm - the number of time
    * @param {bool} classic - if classic is true, it won't show Today, Yesterday etc.
    * @returns a string
    */
    timeStr: function (tm, classic, timefmt) {
        if (scil.Utils.isNullOrEmpty(tm) || tm == 0)
            return "";

        if (typeof (tm) == "string") {
            if (tm == "new")
                return "<span style='color:red'>" + JSDraw2.Language.res("New") + "</span>";
            else
                return tm;
        }

        if (tm == null)
            return "";
        if (typeof tm != "object")
            tm = scil.Utils.time(tm);

        var s = timefmt != null ? timefmt : JSDraw2.defaultoptions.timeformat;
        if (scil.Utils.isNullOrEmpty(s))
            s = "HH:MM";

        return scil.Utils.dateStr(tm, classic) + " " + scil.Utils.formatTime(tm, s);
    },

    /**
    * Create a Button
    * @function {static} createButton
    * @param {string or DOM} parent - the parent of the new element.  The parent can be set to null, so it won't have a parent
    * @param {dictionary} button - { caption: string, onclick: function }
    * @returns the new button
    */
    createButton: function (parent, button, lang) {
        if (typeof parent == "string")
            parent = dojo.byId(parent);

        if (button == null)
            return;
        if (typeof (button) == "string") {
            this.createElement(parent, "span", button);
            return;
        }

        var s = (lang == null ? scil.Lang : lang).res(button.caption || button.label);
        var title = scil.Lang.res(button.title);

        if (button.src == null && button.iconurl != null)
            button.src = button.iconurl;
        if (button.title == null && button.tooltips != null)
            button.title = button.tooltips;

        var a = null;
        if (button.type == "b") {
            var tbody = scil.Utils.createTable(parent, 0, 0, { float: button.float == null ? "left" : button.float, textAlign: "center", margin: 0, borderRadius: "2px" });
            a = tbody.parentNode;
            if (button.id != null)
                a.setAttribute("id", button.id);
            scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", "<img src='" + button.src + "'" + (button.imgheight > 0 ? " height='" + button.imgheight + "'" : "") + ">", { padding: "3px 12px 0 12px" });
            scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", s, { color: "#fff", fontSize: "60%" });
        }
        else {
            if (s == null && (button.src || button.icon) != null) {
                a = this.createElement(parent, "img", null, { width: button.width, cursor: "pointer", verticalAlign: "middle" }, { src: (button.src || button.icon), title: button.title, id: button.id });
            }
            else {
                if (button.src != null)
                    s = "<img style='vertical-align:middle' src='" + button.src + "'" + (button.imgheight > 0 ? " height='" + button.imgheight + "'" : "") + ">" + s;

                if (button.type == "a")
                    a = this.createElement(parent, button.tagname != null ? button.tagname : (s == "" || s == null ? "span" : "u"), s, { width: button.width, cursor: "pointer", background: button.background, whiteSpace: "nowrap" }, { title: title, id: button.id });
                else
                    a = this.createElement(parent, "button", s, { width: button.width, background: button.background, padding: button.padding }, { title: title, id: button.id });
            }
        }

        if (button.items != null) {
            if (a.tagName == "IMG" || a.tagName == "U") {
                var b = this.createElement(parent, "span", null);
                b.appendChild(a);
                a = b;
            }
        }

        var hc = button.highlightcolor == null ? JSDraw2.Skin.menu.highlightcolor : button.highlightcolor;
        var c = button.color == null ? (button.type == "b" ? "" : JSDraw2.Skin.menu.color) : button.color;
        a.style.color = c;
        if (button.type == "b") {
            scil.connect(a, "onmouseover", function () { a.style.background = hc; });
            scil.connect(a, "onmouseout", function () { a.style.background = c; });
        }
        else {
            scil.connect(a, "onmouseover", function () { a.style.color = hc; });
            scil.connect(a, "onmouseout", function () { a.style.color = c; });
        }

        if (button.items != null) {
            if (button.callback == null) {
                button.callback = function (cmd) {
                    if (button.onclick != null) {
                        button.onclick(cmd);
                    }
                    else {
                        for (var i = 0; i < button.items.length; ++i) {
                            if (button.items[i].label == cmd && button.items[i].url != null) {
                                if (button.items[i].target == null)
                                    window.location = button.items[i].url;
                                else
                                    window.open(button.items[i].url, button.items[i].target);
                            }
                        }
                    }
                };
            }
            new scil.DropdownButton(a, button);
        }
        else {
            if (button.onclick != null)
                dojo.connect(a, "onclick", function (e) { button.onclick(e); });
            else if (button.url)
                dojo.connect(a, "onclick", function () { if (button.target == null) window.location = button.url; else window.open(button.url, button.target); });
        }

        if (button.key != null)
            a.setAttribute("key", button.key);

        return a;
    },

    /**
    * Create a HTML element.
    * <pre>
    * <b>Example:</b>
    *    var div = scil.Utils.createElement(document.body, "div", 
    *       "&lt;" + "a href='javascript:alert(99)'&gt;test&lt;/a" + "&gt;", {textAlign:'center'}, {class: 'myclass'});
    * </pre>
    * @function {static} createElement
    * @param {DOM} parent - the parent of the new element.  The parent can be set to null, so it won't have a parent
    * @param {string} tag - the name of the new element
    * @param {string} html - the innerHTML of the new element
    * @param {dictionary} styles - styles of the new element
    * @param {dictionary} attributes - attributes of the new element, such as the name, id, class etc.
    * @param {onclick} function
    * @returns the new HTML element
    */
    createElement: function (parent, tag, html, styles, attributes, onclick) {
        if (typeof (parent) == "string")
            parent = scil.byId(parent);

        if (attributes != null && attributes.title != null)
            attributes.title = this.res(attributes.title);

        var e = null;
        tag = tag.toLowerCase();
        if (tag == "checkbox" || tag == "radio" || tag == "password" || tag == "hidden" || tag == "file" || tag == "image") {
            if (scil.Utils.isIE8Lower) {
                var att = attributes != null && attributes["name"] != null ? " name='" + attributes["name"] + "'" : "";
                e = document.createElement("<input type='" + tag + "'" + att + ">");
            }
            else {
                e = document.createElement("input");
                e.type = tag;
            }
        }
        else {
            e = document.createElement(tag);
        }

        if (parent != null)
            parent.appendChild(e);

        if (html != null) {
            if (tag == "radio" || tag == "checkbox")
                this.createElement(parent, "span", html);
            else
                e.innerHTML = html;
        }

        if (styles != null) {
            for (var k in styles) {
                var v = styles[k];
                if (v == null)
                    continue;

                if ((k == "width" || k == "height" || k == "padding" || k == "margin") && typeof (v) == "number")
                    v = v + "px";

                e.style[k] = v;
            }
        }

        if (attributes != null) {
            for (var k in attributes) {
                if (attributes[k] != null)
                    e.setAttribute(k, attributes[k]);
            }
        }

        if (onclick != null)
            dojo.connect(e, "onclick", function (event) { onclick(event, e); });

        return e;
    },

    //    /**
    //    * Download a file from the same site.  It won't work to download cross-site contents.
    //    * <pre>
    //    * <b>Example:</b>
    //    *    scil.Utils.downloadFile("data/m.mol", function(data) { alert(data); });
    //    * </pre>
    //    * @function {static} downloadFile
    //    * @param {string} url - url of the file
    //    * @param {function} callback - function(data) {}
    //    */
    //    downloadFile: function (url, callback) {
    //        var iframe = scil.Utils.createElement(document.body, "iframe", null, { width: 1, height: 1, display: "none" },
    //            { frameBorder: 0, src: url });

    //        scil.connect(iframe, "onload", function () {
    //            var doc = null;
    //            if (iframe.contentDocument != null)
    //                doc = iframe.contentDocument;
    //            else if (iframe.contentWindow != null)
    //                doc = iframe.contentWindow.document;
    //            var body = doc == null ? null : doc.body;

    //            var data;
    //            if (body == null && doc.documentElement != null)
    //                data = new XMLSerializer().serializeToString(doc);
    //            else
    //                data = scil.Utils.getInnerText(body);

    //            iframe.parentNode.removeChild(iframe);
    //            if (callback != null)
    //                callback(data, url);
    //        });
    //    },

    /**
    * Create a HTML table element
    * @function {static} createTable
    * @param {DOM} parent - the parent of the new table.  The parent can be set to null, so it won't have a parent
    * @param {number} cellspacing - the cell spacing in pixel
    * @param {number} cellpadding - the cell padding in pixel
    * @param {dictionary} styles - styles of the new element
    * @param {number} border - the border width of the table
    * @returns the new HTML element
    */
    createTable: function (parent, cellspacing, cellpadding, styles, border) {
        var table = this.createElement(parent, "table", null, styles);
        if (cellspacing != null)
            table.cellSpacing = cellspacing;
        if (cellpadding != null)
            table.cellPadding = cellpadding;
        if (border >= 0)
            table.border = border;
        return this.createElement(table, "tbody");
    },

    /**
    * Create a HTML table element
    * @function {static} createTable
    * @param {DOM} parent - the parent of the new table.  The parent can be set to null, so it won't have a parent
    * @param {dict} styles - styles of the new element
    * @param {dict} attributes - attributes
    * @returns the new HTML element
    */
    createTable2: function (parent, styles, attributes) {
        var table = this.createElement(parent, "table", null, styles, attributes);
        return this.createElement(table, "tbody");
    },

    createTR: function (parent, styles) {
        return scil.Utils.createElement(parent, "tr", styles);
    },

    createTD: function (parent, styles) {
        if (parent.tagName != "TR")
            parent = this.createTR(parent);
        return scil.Utils.createElement(parent, "td", styles);
    },

    createCenterBox: function (parent, border) {
        var t = this.createTable(parent, 0, 0, null, border);
        t.parentNode.setAttribute("align", "center");
        var tr = this.createElement(t, "tr");
        var td = this.createElement(tr, "td", null, { textAlign: "left" });
        return td;
    },

    createSelect: function (parent, items, value, sortitems, styles) {
        var sel = this.createElement(parent, "select", null, styles);
        this.listOptions(sel, items, value, false, sortitems);
        return sel;
    },

    /**
    * Specify items of a SELECT element
    * @function {static} listOptions
    * @param {DOM} select - the destination SELECT element
    * @param {array or dictionary} items - items to be added
    * @param {string} val - the value of the selected item
    * @param {bool} removeall - indicate if removing all existing items before adding new items
    * @param {bool} sortitems - indicate if sorting items before adding them
    * @returns null
    */
    listOptions: function (select, items, val, removeall, sortitems) {
        if (removeall)
            this.removeAll(select);
        if (items == null)
            return;

        if (items.length != null) {
            if (sortitems)
                items.sort();
            for (var i = 0; i < items.length; ++i) {
                var s = items[i];
                var opt = this.createElement(select, "option", s, null, { value: s });
                if (s == val)
                    opt.setAttribute("selected", "selected");
            }
        }
        else {
            var ss = {};
            var list = [];
            for (var k in items) {
                ss[items[k]] = k;
                list.push(items[k]);
            }
            if (sortitems)
                list.sort();

            for (var i = 0; i < list.length; ++i) {
                var v = list[i];
                var k = ss[v];
                var opt = this.createElement(select, "option", v, null, { value: k });
                if (k == val)
                    opt.setAttribute("selected", "selected");
            }
        }
    },

    /**
    * Select an item in a SELECT element based on a value
    * @function {static} selectOption
    * @param {DOM} select - the destination SELECT element
    * @param {string} val - the value of the selected item
    * @returns null
    */
    selectOption: function (select, val, ignorecase) {
        if (select == null)
            return;

        for (var i = 0; i < select.options.length; ++i) {
            var opt = select.options[i];
            if (this.isEqualStr(opt.value, val + "", ignorecase) || typeof (val) == "boolean" && (val == true && scil.Utils.isTrue(opt.value) || val == false && scil.Utils.isFalse(opt.value))) {
                select.selectedIndex = i;
                return;
            }
        }
        select.selectedIndex = -1;
    },

    isEqualStr: function (s1, s2, ignorecase) {
        if (s1 == null && s2 == null)
            return true;
        if (s1 == null || s2 == null)
            return false;

        if (ignorecase)
            return s1.toLowerCase() == s2.toLowerCase();
        return s1 == s2;
    },

    /**
    * Remove all child elements
    * @function {static} removeAll
    * @param {DOM} parent - the parent HTML element
    * @returns null
    */
    removeAll: function (parent) {
        if (parent == null || parent.childNodes == null)
            return;
        for (var i = parent.childNodes.length - 1; i >= 0; --i)
            parent.removeChild(parent.childNodes[i]);
    },

    /**
    * Get the first parent element with a given tag name
    * @function {static} getParent
    * @param {DOM} obj - the start HTML element
    * @param {string} tag - the element tag name to be searched
    * @returns the first parent element
    */
    getParent: function (obj, tag) {
        tag = tag.toUpperCase();
        while (obj != null) {
            if (obj.tagName != null && obj.tagName.toUpperCase() == tag)
                return obj;
            obj = obj.parentNode;
        }
        return obj;
    },

    /**
    * Test if an element is a child of a parent
    * @function {static} testParent
    * @param {DOM} obj - the child HTML element to be tested
    * @param {DOM} parent - the parent element to be tested
    * @returns true or false
    */
    testParent: function (obj, parent) {
        if (obj == null || parent == null)
            return false;
        while (obj != null) {
            if (obj.parentNode == parent)
                return true;
            obj = obj.parentNode;
        }
        return false;
    },

    /**
    * Find the first child of a given tag name
    * @function {static} firstElement
    * @param {DOM} parent - the parent element to be tested
    * @param {string} tag - the tag name to be searched
    * @returns the child HTML element
    */
    firstElement: function (parent, tag) {
        if (parent == null)
            return null;
        for (var i = 0; i < parent.childNodes.length; ++i) {
            var c = parent.childNodes[i];
            if (tag == null && c.nodeName != '#text' || tag != null && c.nodeName == tag)
                return c;
        }
        return null;
    },

    arrayContainsArray: function (superset, subset) {
        for (var i = 0; i < subset.length; ++i) {
            if (this.indexOf(superset, subset[i]) < 0)
                return false;
        }
        return true;
    },

    indexOf: function (list, a, ignorecase) {
        if (list == null)
            return -1;

        if (ignorecase && typeof (a) == "string")
            a = a.toLowerCase();
        else if (typeof (a) != "string")
            ignorecase = false;

        for (var i = 0; i < list.length; ++i) {
            var s = list[i];
            if (ignorecase)
                s = s.toLowerCase();
            if (s == a)
                return i;
        }
        return -1;
    },

    delFromArray: function (list, a) {
        var n = 0;
        for (var i = list.length - 1; i >= 0; --i) {
            if (list[i] == a) {
                list.splice(i, 1);
                ++n;
            }
        }
        return n;
    },

    /**
    * Post data to a url
    * @function {static} post
    * @param {string} url - the destination url to to be posted to
    * @param {dictionary} args - the data to be posted
    * @param {string} target - the target frame
    * @returns null
    */
    post: function (url, args, target) {
        if (this.form == null)
            this.form = scil.Utils.createElement(document.body, "form", null, { display: "none" });

        scil.Utils.removeAll(this.form);
        for (var k in args) {
            var f = scil.Utils.createElement(this.form, "textarea");
            f.name = k;
            f.value = args[k];
        }

        this.form.target = target;
        this.form.method = "post";
        this.form.action = url;
        this.form.submit();
    },

    postIframe: function (url, args) {
        if (this.postform == null)
            this.postform = scil.Utils.createElement(document.body, "form", null, { display: "none" });

        dojo.io.iframe.send({
            url: url,
            form: this.form,
            method: "POST",
            content: args,
            timeoutSeconds: 5,
            preventCache: true,
            handleAs: "text",
            error: function (data) { },
            handle: function (data) { }
        });
    },

    alert: function (s) {
        if (scil.Utils.isNullOrEmpty(s))
            return;
        if (s.length > 1000)
            s = s.substr(0, 1000) + "...";
        if (scil.Utils.nativemode) {
            this.alert2(s, "JSDraw2.Editor Message");
        }
        else {
            alert(s);
        }
    },

    /**
    * Download data from a url
    * @function {static} download
    * @param {string} url - the destination url
    * @param {function} callback - the callback function
    * @returns null
    */
    download: function (url, callback) {
        if (url.indexOf('?') > 0)
            url += "&__tm=" + new Date().getTime();
        else
            url += "?__tm=" + new Date().getTime();
        if (scil.Utils.startswith(url, "http://")) {
            var jsonpArgs = {
                url: url,
                callbackParamName: "callback",
                load: callback,
                error: function (error) { alert(error); }
            };
            dojo.io.script.get(jsonpArgs);
        }
        else {
            var xhrArgs = {
                url: url,
                handleAs: "text",
                load: callback,
                error: function (error) { /*alert(error);*/ }
            };
            dojo.xhrGet(xhrArgs);
        }
    },

    /**
    * Perform an Ajax call
    * <pre>
    * <b>Example:</b>
    *    var callback = function(ret) {
    *        alert(ret.message);
    *    };
    *    scilligence.ajax("/path/ajax.ashx", callback, { username: "tom", password: "123" });
    * </pre>
    * @function {static} ajax
    * @param {string} url - the destination url
    * @param {function(dictionary)} callback - the callback function
    * @param {dictionary} params - data to be sent
    * @returns null
    */
    ajax: function (url, callback, params, opts) {
        if (opts == null)
            opts = {};

        var xhrArgs = {
            url: url,
            sync: opts.sync,
            handleAs: "text",
            content: scil.Utils.stupidTomcatBug(params),
            timeout: opts.timeout,
            error: function (data) {
                if (opts.showprogress)
                    scil.Progress.hide();

                if (opts.onError != null)
                    opts.onError(data);
                else
                    scil.Utils.alert(data.message);
            },
            load: function (data) {
                if (opts.showprogress)
                    scil.Progress.hide();

                scil.Utils.ajaxCallback(data, callback, opts.onError, opts.ignoresucceedcheck);
                if (scil.User != null && scil.User.onAjax != null)
                    scil.User.onAjax();
            }
        };

        if (opts.showprogress)
            scil.Progress.show((opts.caption == null ? "Loading ..." : opts.caption), false, (opts.message == null ? "Communicating with the server ..." : opts.message), false);

        if (scil.Utils.onajaxcall != null)
            scil.Utils.onajaxcall(xhrArgs, opts);

        if (opts.headers != null)
            xhrArgs.headers = opts.headers;

        switch (opts.verb) {
            case "delete":
            case "del":
                dojo.xhrDelete(xhrArgs);
                break;
            case "put":
                dojo.xhrPut(xhrArgs);
                break;
            case "get":
                dojo.xhrGet(xhrArgs);
                break;
            default:
                dojo.xhrPost(xhrArgs);
                break;
        }
    },

    stupidTomcatBug: function (params) {
        return params;
    },

    ajaxwait: function (url, params) {
        var ret = null;
        var fun = function (r) { ret = r; };
        this.ajax(url, fun, params, { sync: true });
        return ret;
    },

    /**
    * Perform an JSONP call
    * <pre>
    * <b>Example:</b>
    *    var callback = function(ret) {
    *        alert(ret.message);
    *    };
    *    scilligence.ajax("http://otherserver/path/ajax.ashx", callback, { username: "tom", password: "123" });
    *
    *    // cross domain call to post large data
    *    var url = "http://server/jsdraw/service.aspx?cmd=";
    *    var jsd = JSDraw.get("div1");
    *    scil.Utils.jsonp(url + "jsdraw2img", function (ret) {
    *        alert(ret.src);
    *    }, { jsdraw: jsd.getXml() }, { xdomainurl: url + "xdomain.postdata" });
    * </pre>
    * @function {static} jsonp
    * @param {string} url - the destination url
    * @param {function} callback - the callback function
    * @param {dictionary} params - data to be sent
    * @returns null
    */
    jsonp: function (url, callback, params, opts) {
        if (opts == null)
            opts = {};

        if (params == null)
            params = { wrapper: "jsonp" };
        else
            params.wrapper = "jsonp";

        if (scil.Utils.startswith(url, "//")) {
            var s = (window.location + "").toLowerCase();
            if (scil.Utils.startswith(s, "https:"))
                url = "https:" + url;
            else
                url = "http:" + url;
        }

        var p = url.indexOf('?');
        if (p < 0)
            url += "?";
        else
            url += "&";
        url += "__jsdraw_timestamp__=" + new Date().getTime();

        if (opts.showprogress)
            scil.Progress.show((opts.caption == null ? "Loading ..." : opts.caption), false, (opts.message == null ? "Communicating with the server ..." : opts.message), false);

        if (opts.xdomainurl != null) {
            scil.Utils.postXdomainData(opts.xdomainurl, function (xfilename) {
                scil.Utils.jsonp(url, function (ret) {
                    if (opts.showprogress)
                        scil.Progress.hide();

                    if (callback != null)
                        callback(ret);
                }, { _xfilename: xfilename });
            }, params);
        }
        else {
            var jsonpArgs = {
                url: url,
                callbackParamName: "callback",
                content: scil.Utils.stupidTomcatBug(params),
                error: function (data) {
                    if (opts.showprogress)
                        scil.Progress.hide();

                    if (opts.onError != null)
                        opts.onError(data);
                    else
                        scil.Utils.alert(data.message);
                },
                load: function (data) {
                    if (opts.showprogress)
                        scil.Progress.hide();

                    scil.Utils.ajaxCallback(data, callback, opts.onError, opts.ignoresucceedcheck);
                }
            };

            if (scil.Utils.onjsonpcall != null)
                scil.Utils.onjsonpcall(jsonpArgs);

            dojo.io.script.get(jsonpArgs);
        }
    },

    getZindex: function (e) {
        while (e != null) {
            if (e.style != null && e.style.zIndex != "" && e.style.zIndex != null)
                return parseInt(e.style.zIndex);
            e = e.parentNode;
        }
        return 1;
    },

    onAjaxCallback: null,
    ajaxCallback: function (data, callback, onError, ignoresucceedcheck) {
        var ret = null;
        switch (typeof (data)) {
            case "string":
                try {
                    if (data == "") {
                        ret = null;
                    }
                    else {
                        eval("var o=" + data);
                        ret = o;
                    }
                }
                catch (e) {
                    scil.Utils.alert("Error when parsing Ajax results:\n" + e.message + "\n" + data);
                    return;
                }
                break;
            case "object":
                ret = data;
                break;
            default:
                scil.Utils.alert("Unknown return format");
                break;
        }

        if (scil.Utils.onAjaxCallback != null) {
            if (scil.Utils.onAjaxCallback(ret))
                return;
        }

        if (ignoresucceedcheck == true) {
            if (callback != null)
                callback(ret);
        }
        else if (ret.succeed) {
            if (callback != null)
                callback(ret.ret);
        }
        else {
            if (scil.User != null && scil.User.needLogin != null && scil.User.needLogin(ret))
                return;

            if (onError != null) {
                onError(ret);
            }
            else {
                if (ret.errcode == "None")
                    scil.Utils.alert(ret.error);
                else
                    scil.Utils.alert("[" + (ret.errcode == null ? "ERROR" : ret.errcode) + "]: " + ret.error);
            }
        }
    },

    ajaxUploadFile: function (form, url, params, callback) {
        if (params == null)
            params = {};
        if (url.toLowerCase().indexOf("wrapper=textarea") < 0) {
            var p = url.indexOf('?');
            if (p > 0)
                url += "&wrapper=textarea";
            else
                url += "?wrapper=textarea";
        }

        // I#12036
        if (scil.Utils.___ajaxUploadFile == null) {
            dojo.config.dojoBlankHtmlUrl = scil.Utils.imgSrc("blank.html");
            dojo.io.iframe.send({
                url: dojo.config.dojoBlankHtmlUrl,
                form: form,
                method: "get",
                content: params,
                timeoutSeconds: 60,
                preventCache: true,
                handleAs: "text"
            });
            scil.Utils.___ajaxUploadFile == true;
        }

        dojo.io.iframe.send({
            url: url,
            form: form,
            method: "post",
            content: params,
            timeoutSeconds: 60,
            preventCache: true,
            handleAs: "text",
            error: function (data) {
                scil.Progress.hide();
                scil.Utils.alert(data.message);
            },
            handle: function (data) {
                scil.Progress.hide();
                scil.Utils.ajaxCallback(data, callback);
            }
        });

        scil.Progress.show("Uploading", false, "Communicating with the server ...", false);
    },

    ajaxPostFile: function (form, url, params, callback) {
        if (params == null)
            params = {};
        if (url.toLowerCase().indexOf("wrapper=textarea") < 0) {
            var p = url.indexOf('?');
            if (p > 0)
                url += "&wrapper=textarea";
            else
                url += "?wrapper=textarea";
        }
        dojo.io.iframe.send({
            url: url,
            form: form,
            method: "post",
            content: params,
            timeoutSeconds: 5,
            preventCache: true,
            handleAs: "text",
            //error: function (data) { scil.Utils.alert(data.message); },
            handle: function (data) { if (callback != null) callback(data); }
        });
    },

    res: function (s) {
        return JSDraw2.Language.res(s);
    },

    UploadFileDlg: scilligence.extend(scilligence._base, {
        callback: null,
        url: null,
        params: null,
        msg: null,
        checkfiles: null,
        dlg: null,
        btn: null,
        tbody: null,
        files: [],

        constructor: function (multiple) {
            var div = JsUtils.createElement(null, "div", "<form method='post' enctype='multipart/form-data'></form>");
            this.form = div.firstChild;
            this.tbody = JsUtils.createTable(this.form, null, null, { margin: "6px", width: "350px" }, { align: "center" });
            var tr = JsUtils.createElement(this.tbody, "tr");
            this.msg = JsUtils.createElement(tr, "td");
            this.msg.colSpan = 2;

            if (multiple != null && multiple == true)
                multiple = 5;

            var n = 1;
            if (multiple && scil.Utils.isIE && scil.Utils.isIE < 10)
                var n = multiple > 1 ? multiple : 5;

            var args = { size: 26, name: "file" };
            if (multiple && n == 1)
                args.multiple = "multiple";

            for (var i = 0; i < n; ++i) {
                tr = JsUtils.createElement(this.tbody, "tr");
                JsUtils.createElement(tr, "td", scil.Utils.res("File") + ":");
                this.files[i] = JsUtils.createElement(JsUtils.createElement(tr, "td"), "file", null, null, args);
            }

            if (scil.MobileData != null) {
                var me = this;
                tr = JsUtils.createElement(this.tbody, "tr");
                JsUtils.createElement(tr, "td", "<div style='white-space:nowrap'>" + scil.Utils.res("From Mobile") + ":</div>", null, { valign: "top" });
                var td2 = JsUtils.createElement(tr, "td");
                this.mobileimages = JsUtils.createElement(td2, "hidden", null, null, { name: "mobileimages" });
                scil.Utils.createButton(td2, { label: "Show", type: "a", onclick: function () { me.showImageList(); } });
                this.imagelistdiv = JsUtils.createElement(td2, "div", null, { display: "none" });
                this.imagelist = scil.MobileData.createImageList(this.imagelistdiv, multiple);
            }

            tr = JsUtils.createElement(this.tbody, "tr", null, { display: "none" });
            JsUtils.createElement(tr, "td", "Password:");
            JsUtils.createElement(JsUtils.createElement(tr, "td"), "password", null, null, { name: "jsdraw.upload.password" });
            this.passwordRow = tr;

            JsUtils.createElement(JsUtils.createElement(this.tbody, "tr"), "td", "&nbsp;");

            tr = JsUtils.createElement(this.tbody, "tr");
            JsUtils.createElement(tr, "td");
            this.btn = JsUtils.createElement(scil.Utils.createElement(tr, "td"), "button", "<img src='" + scil.App.imgSmall("submit.png") + "' />" + scil.Utils.res("Upload"));

            this.dlg = new JSDraw2.Dialog("Upload File", div);
        },

        showImageList: function () {
            if (this.imagelistdiv.style.display == "none") {
                this.imagelistdiv.style.display = "";
                scil.MobileData.listImages(this.imagelist, this.params);
            }
            else {
                this.imagelistdiv.style.display = "none";
            }
        },

        show: function (caption, message, url, callback, params, showpassword, postonly, checkfiles) {
            this.dlg.show(caption);
            this.postonly = postonly;
            this.checkfiles = checkfiles;
            if (this.imagelistdiv != null) {
                this.imagelistdiv.style.display = "none";
                this.imagelist.clear();
            }

            var me = this;
            if (this.btn != null) {
                dojo.connect(this.btn, "onclick", function (e) { me.show2(); e.preventDefault(); });
                this.btn = null;
            }

            this.callback = function (ret) {
                if (callback != null)
                    callback(ret);
                me.dlg.hide();
            };
            this.url = url;
            this.params = params;
            this.form.reset();
            this.passwordRow.style.display = showpassword ? "" : "none";
            this.msg.innerHTML = message;
        },

        show2: function () {
            if (this.mobileimages != null)
                this.mobileimages.value = scil.MobileData.getSelectedImages(this.imagelist);

            if (this.postonly) {
                var filename = this.files[0].value;
                var p = filename.lastIndexOf('\\');
                if (p > 0)
                    filename = filename.substr(p + 1);
                var id = new Date().getTime();
                var args = this.params == null ? {} : scil.clone(this.params);
                args._xfilename = id + "_" + filename;

                var me = this;
                scil.Utils.ajaxPostFile(this.form, this.url, args, function () { me.callback(args._xfilename); });
            }
            else {
                var me = this;
                if (this.checkfiles) {
                    var list = [];
                    var files = this.files[0].files;
                    for (var i = 0; i < files.length; ++i)
                        list.push(files[i].name);
                    this.checkfiles(list, function (overwrite) {
                        var args = scil.clone(me.params);
                        args.overwrite = overwrite;
                        scil.Utils.ajaxUploadFile(me.form, me.url, args, me.callback);
                    });
                }
                else {
                    scil.Utils.ajaxUploadFile(me.form, me.url, me.params, me.callback);
                }
            }
        }
    }),

    postXdomainData: function (url, callback, data) {
        var id = new Date().getTime();
        var args = scil.clone(data);
        if (args == null)
            args = {};
        args._xfilename = id;

        if (this.xdomainform == null)
            this.xdomainform = scil.Utils.createElement(document.body, "form", null, { display: "none" });
        scil.Utils.ajaxPostFile(this.xdomainform, url, args, function () { if (callback != null) callback(args._xfilename); });
    },

    /**
    * Upload a file with Ajax
    * <pre>
    * <b>Example:</b>
    *    var callback = function(ret) { alert(ret.message); };
    *    scil.Utils.uploadFile("Uploade File", "Please upload attachments", "/uploade.aspx", callback, { project: "HIV" });
    * </pre>
    * @function {static} uploadFile
    * @param {string} caption - the caption of uploading dialog
    * @param {string} message - the message body of uploading dialog
    * @param {string} url - the destination url
    * @param {function} callback - the callback function
    * @param {dictionary} params - data to be sent
    * @param {bool} chk - reserved
    * @param {bool} multiple - data to be sent
    * @param {string} showpassword
    * @param {bool} postonly
    * @returns null
    */
    uploadfileDlg: null,
    uploadfileDlg2: null,
    uploadFile: function (caption, message, url, callback, params, chk, multiple, showpassword, postonly, checkfiles) {
        if (multiple) {
            if (this.uploadfileDlg2 == null)
                this.uploadfileDlg2 = new scil.Utils.UploadFileDlg(true);
            this.uploadfileDlg2.show(caption, message, url, callback, params, showpassword, postonly, checkfiles);
            this.uploadfileDlg2.check = chk;
        }
        else {
            if (this.uploadfileDlg == null)
                this.uploadfileDlg = new scil.Utils.UploadFileDlg();
            this.uploadfileDlg.show(caption, message, url, callback, params, showpassword, postonly, checkfiles);
            this.uploadfileDlg.check = chk;
        }
    },

    uploadFile2: function () {
        var dlg = this.uploadfileDlg;
        var params = dlg.params;
        scil.Utils.ajaxUploadFile(this.uploadfileDlg.form, dlg.url, params == null ? {} : params, dlg.callback);
    },

    ie2touches: function (e) {
        var list = e.getPointerList();
        var touches = [];
        for (var i = 0; i < list.length; ++i)
            touches.push({ pointerId: list[i].pointerId, clientX: list[i].clientX, clientY: list[i].clientY, target: e.target, button: e.button });
        touches.sort(function (a, b) { return a.pointerId - b.pointerId; });
        e.touches = touches;
        return e;
    },

    getScreenSize: function (win) {
        if (win == null)
            win = window;
        var scrollRoot = win.document.documentElement || win.document.body;
        var uiWindow = win.document.parentWindow || win.document.defaultView;
        return {
            w: uiWindow.innerWidth || scrollRoot.clientWidth,
            h: uiWindow.innerHeight || scrollRoot.clientHeight
        };
    },

    /**
    * Convert a JSON object into a string
    * @function {static} uploadFile
    * @param {dictionary} v - the input jsop object
    * @returns a string
    */
    json2str: function (v, readable, restrict) {
        var quot = restrict ? "\"" : "'";

        if (v == null)
            return "null";
        if (typeof (v) == "number")
            return v;
        if (typeof (v) == "boolean")
            return v ? "true" : "false";
        if (typeof (v) == "string") {
            var s = v.replace(/\r/g, "\\r").replace(/\n/g, "\\n");
            if (quot == "\"")
                s = s.replace(/\"/g, "\\\"");
            else
                s = s.replace(/\'/g, "\\'");
            return quot + s + quot;
        }
        if (typeof (v) == "object") {
            if (v.length != null) { // array
                var s = (readable ? "[ " : "[");
                for (var i = 0; i < v.length; ++i)
                    s += (i > 0 ? (readable ? ", " : ",") : "") + this.json2str(v[i], readable, restrict);
                s += (readable ? " ]" : "]");
                return s;
            }
            else {
                var s = (readable ? "{ " : "{");
                var j = 0;
                for (var k in v) {
                    if (k == null || k == '' || v[k] == null || k.substr(0, 1) == '_')
                        continue;

                    if (++j > 1) {
                        if (s.substr(s.length - 1, 1) == "}")
                            s += (readable ? ",\r\n" : ",");
                        else
                            s += (readable ? ", " : ",");
                    }

                    if (!restrict && /^[a-z|_]+[0-9|a-z|_]{0,1000}$/.test(k))
                        s += k;
                    else
                        s += quot + k + quot;
                    s += (readable ? ": " : ":") + this.json2str(v[k], readable, restrict);
                }
                s += (readable ? " }" : "}");
                return s;
            }
        }
        return "null";
    },

    getMaxZindex: function () {
        var z1 = this.getMaxZindex2("div");
        var z2 = this.getMaxZindex2("iframe");
        var z3 = this.getMaxZindex2("table");
        return Math.max(Math.max(z1, z2), z3);
    },

    getMaxZindex2: function (tag) {
        // I#11869
        var zindex = document.body.className == "mce-fullscreen" ? 101 : 1;
        var list = document.getElementsByTagName(tag);
        for (var i = 0; i < list.length; ++i) {
            if (list[i].style == null || list[i].style.display == "none")
                continue;
            var z = list[i].style.zIndex;
            if (z != null && z != "") {
                var k = parseInt(z);
                if (k > zindex)
                    zindex = k;
            }
        }
        return zindex;
    },

    isAllParentVisible: function (e) {
        if (e == null)
            return false;

        while (e != null && e.style != null) {
            if (e.style.display == "none")
                return false;
            e = e.parentNode;
        }
        return true;
    },

    /**
    * Convert an XML object into JSON object
    * @function {static} xml2Json
    * @param {XMLElement} parent - the parent XML element
    * @param {string} tag - the xml tag name to be looked up
    * @returns an array of object
    */
    xml2Json: function (parent, tag) {
        if (parent == null)
            return null;
        var list = parent.getElementsByTagName(tag);
        if (list == null || list.length == 0)
            return null;

        var ret = [];
        for (var i = 0; i < list.length; ++i) {
            var e = list[i];
            var item = { _e: e };
            for (var k = 0; k < e.attributes.length; ++k) {
                var at = e.attributes[k];
                item[at.name] = at.value;
            }
            ret.push(item);
        }

        return ret;
    },

    /**
    * Convert a JSON oject array into an xml string
    * @function {static} jsonList2Xml
    * @param {array} list - the input array of objects
    * @param {string} tag - the xml tag name to be wrapped in xml
    * @returns a string
    */
    jsonList2Xml: function (list, tag) {
        if (list == null)
            return "";

        var s = "";
        for (var i = 0; i < list.length; ++i)
            s += this.json2Xml(list[i], tag);
        return s;
    },

    /**
    * Convert a JSON oject into an xml string
    * @function {static} json2Xml
    * @param {dictionary} dict - the input object
    * @param {string} tag - the xml tag name to be wrapped in xml
    * @param {string} innerXml - the inner xml to be placed in the xml element
    * @returns a string
    */
    json2Xml: function (dict, tag, innerXml) {
        if (dict == null)
            return "";

        var s = "<" + tag;
        for (var k in dict) {
            var v = dict[k];
            if (v == null || typeof (v) == "string" && v == "")
                continue;
            var type = typeof (v);
            if (type != "object" && type != "function")
                s += " " + k + "=\"" + scil.Utils.escXmlValue(dict[k]) + "\"";
        }
        if (innerXml != null && innerXml != "")
            s += ">" + innerXml + "</" + tag + ">";
        else
            s += "/>";
        return s;
    },

    /**
    * Merge two arrays
    * @function {static} joinArray
    * @param {array} list1 - the first array
    * @param {array} list2 - the second array
    * @returns a new array
    */
    joinArray: function (list1, list2) {
        if (list1 == null && list2 == null)
            return null;
        else if (list1 == null)
            return list2;
        else if (list2 == null)
            return list1;

        var ret = [];
        if (typeof list1 == "string" || list1.length == null) {
            ret.push(list1);
        }
        else {
            for (var i = 0; i < list1.length; ++i)
                ret.push(list1[i]);
        }
        if (typeof list2 == "string" || list2.length == null) {
            ret.push(list2);
        }
        else {
            for (var i = 0; i < list2.length; ++i)
                ret.push(list2[i]);
        }

        return ret;
    },

    /**
    * Get inner xml of an xml element
    * @function {static} getInnerXml
    * @param {XmlElement} element
    * @returns a string
    */
    getInnerXml: function (e) {
        if (e == null)
            return;

        if (e.documentElement != null)
            e = e.documentElement;

        if (e.innerXML)
            return e.innerXML;

        if (e.xml)
            return e.xml;

        if (typeof XMLSerializer != "undefined") {
            var s = "";
            for (var i = 0; i < e.childNodes.length; ++i)
                s += (new XMLSerializer()).serializeToString(e.childNodes[i]);
            return s;
        }

        return null;
    },

    getInnerText: function (e) {
        if (e == null)
            return;

        if (e != null && e.documentElement != null)
            e = e.documentElement;
        return scil.Utils.trim(e.innerText || e.textContent || e.text);
    },

    getChildXmlElements: function (e, tag) {
        if (e != null && e.documentElement != null)
            e = e.documentElement;
        if (e == null)
            return null;

        var ret = [];
        for (var i = 0; i < e.childNodes.length; ++i) {
            if (e.childNodes[i].tagName == tag)
                ret.push(e.childNodes[i]);
        }
        return ret;
    },

    num2letter: function (i, lowercase) {
        var s = "";
        while (i > 0) {
            var c = (i - 1) % 26;
            s = String.fromCharCode(c + (lowercase ? 97 : 65)) + s;
            i = (i - c - 1) / 26;
        }
        return s;
    },

    isImg: function (ext) {
        return ext == "gif" || ext == "png" || ext == "jpg" || ext == "jpeg" || ext == "tif" || ext == "tiff" || ext == "bmp";
    },

    isOfficeFile: function (ext) {
        return ext == "doc" || ext == "docx" || ext == "rtf" || ext == "ppt" || ext == "pptx" || ext == "xls" || ext == "xlsx";
    },

    isPDF: function (ext) {
        return ext == "pdf";
    },

    isSpectraFile: function (ext) {
        return ext == "jdx";
    },

    isChemFile: function (ext) {
        return ext == "cdx" || ext == "cdxml" || ext == "jsd" || ext == "jsdraw" || ext == "mol" || ext == "sdf" || ext == "mol2" || ext == "cml" ||
        ext == "skc" || ext == "tgf" || ext == "mrv" || ext == "rxn" || ext == "rdf" || ext == "helm" || ext == "xhelm";
    },

    getFileExt: function (filename) {
        if (filename == null)
            return null;
        var p = filename == null ? -1 : filename.lastIndexOf('.');
        if (p <= 0)
            return null;
        return filename.substr(p + 1);
    },

    isChildOf: function (e, parent) {
        if (parent == null || e == null)
            return false;

        while (e != null) {
            if (e.parentNode == parent)
                return true;
            e = e.parentNode;
        }
        return false;
    },

    getElements: function (parent, name, ignorecase) {
        var ret = [];
        if (parent != null && parent.childNodes != null) {
            for (var i = 0; i < parent.childNodes.length; ++i) {
                var a = parent.childNodes[i];
                if (name == null || a.tagName == name || ignorecase && a.tagName != null && name != null && a.tagName.toLowerCase() == name.toLowerCase())
                    ret.push(a);
            }
        }
        return ret;
    },

    getFirstElement: function (parent, name) {
        var ret = [];
        if (parent != null && parent.childNodes != null) {
            for (var i = 0; i < parent.childNodes.length; ++i) {
                var a = parent.childNodes[i];
                if (name == null && a.tagName != null || name != null && a.tagName == name)
                    return a;
            }
        }
        return null;
    },

    parseIndex: function (s) {
        if (s == null)
            return null;
        var s2 = s.replace(/[0-9]+$/, "");
        if (s2 == s)
            return { prefix: s2, index: null };
        return { prefix: s2, index: parseInt(s.substr(s2.length)) };
    },

    removeArrayItem: function (list, item) {
        var p = scil.Utils.indexOf(list, item);
        if (p < 0)
            return false;
        list.splice(p, 1);
        return true;
    },

    removeArrayItems: function (list, items) {
        var n = 0;
        for (var i = 0; i < items.length; ++i)
            if (this.removeArrayItem(list, items[i]))
                ++n;
        return n;
    },

    moveToScreen: function (x, y, e, left) {
        var d = dojo.window.getBox();
        if (x + e.offsetWidth > d.l + d.w) {
            if (left != null)
                x = left - e.offsetWidth;
            else
                x = d.l + d.w - e.offsetWidth;
        }
        if (x < 0)
            x = 0;

        if (y + e.offsetHeight > d.t + d.h)
            y = d.t + d.h - e.offsetHeight;
        if (y < 0)
            y = 0;

        e.style.left = x + "px";
        e.style.top = y + "px";
    },

    unselectable: function (e) {
        e.onselectstart = function () { return false; };
        e.setAttribute("unselectable", "on");
        dojo.style(e, {
            webkitTouchCallout: "none",
            webkiUserDelect: "none",
            khtmlUserSelect: "none",
            MozUserSelect: "none",
            msUserSelect: "none",
            userSelect: "none"
        });
    },

    letter2num: function (s) {
        if (scil.Utils.isNullOrEmpty(s))
            return 0;

        var ret = 0;
        s = s.toUpperCase();
        for (var i = 0; i < s.length; ++i) {
            var c = s.charCodeAt(i);
            if (c >= 65 && c <= 90)
                ret = ret * 26 + (c - 65 + 1);
        }

        return ret;
    },

    num2letter: function (i_1based, lowercase) {
        var s = "";
        while (i_1based > 0) {
            var c = (i_1based - 1) % 26;
            s = String.fromCharCode(c + (lowercase ? 97 : 65)) + s;
            i_1based = (i_1based - c - 1) / 26;
        }
        return s;
    },

    connect: function (element, event, fun) {
        return dojo.connect(element, event, fun);
    },

    array2str: function (list, sep) {
        if (list == null || list.length == 0)
            return "";

        var s = "";
        if (sep == null)
            sep = ',';
        for (var i = 0; i < list.length; ++i) {
            if (i > 0)
                s += sep;
            if (list[i] != null)
                s += list[i];
        }
        return s;
    },

    isDictEmpty: function (obj) {
        if (obj == null)
            return true;
        for (var k in obj)
            return false;
        return true;
    },

    getDictValues: function (dict, list) {
        if (dict == null)
            return null;

        if (list == null)
            list = [];
        else if (list == true)
            list = [""];

        for (var k in dict)
            list.push(dict[k]);
        return list;
    },

    getDictKeys: function (dict, list) {
        if (dict == null)
            return null;

        if (list == null)
            list = [];
        else if (list == true)
            list = [""];

        for (var k in dict)
            list.push(k);
        return list;
    },

    getDictKeyByValue: function (dict, v) {
        if (dict == null)
            return null;
        for (var k in dict) {
            if (dict[k] == v)
                return k;
        }
        return null;
    },

    setEnv: function (env) {
        if (env == null || env == "")
            return;
        document.body.style.backgroundImage = scil.Utils.imgSrc("img/" + env + ".gif", true);
        document.body.style.backgroundRepeat = "no-repeat";
    },

    sound: function (wav) {
        if (this.isIE && this.isIE < 9)
            return;

        if (this.__sound == null)
            this.__sound = this.createElement(document.body, "audio", null, { display: "none" });
        if (this.__sound.src != wav)
            this.__sound.src = wav;
        this.__sound.play();
    },

    escapeHtml: function (s) {
        if (s == null)
            return "";

        return s.replace(/>/g, "&gt;").replace(/</g, "&lt;");
    },

    textWidth: function (s) {
        if (s == null || s.length == null)
            return 0;

        var sum = 0;
        for (var i = 0; i < s.length; ++i) {
            if (s.charCodeAt(i) > 255)
                sum += 2;
            else
                ++sum;
        }
        return sum;
    },

    areListEq: function (x, y) {
        if (x == y)
            return true;
        if (x == null && y != null || x != null && y == null || x.length != y.length)
            return false;
        for (var i = 0; i < x.length; ++i) {
            if (x[i] != y[i])
                return false;
        }
        return true;
    },

    areDictEq: function (main, to) {
        if (main == to)
            return true;
        if (main == null || to == null)
            return false;
        for (var k in main) {
            var x = main[k];
            var y = to[k];
            if (!(x == y || x == null && y == "" || x == "" && y == null))
                return false;
        }
        return true;
    },

    splitStr: function (s, separator) {
        if (s == null)
            return null;

        var ret = [];
        var ss = s.split(separator);
        for (var i = 0; i < ss.length; ++i)
            ret.push(this.trim(ss[i]));
        return ret;
    },

    isEmptyStr: function (s) {
        return this.isNullOrEmpty(s);
    },

    regFindAllMatches: function (s, pattern, start) {
        var ret = [];
        if (s == null)
            return ret;

        if (start > 0)
            s = s.substr(start);
        else
            start = 0;

        var m;
        var st = 0;
        while ((m = pattern.exec(s)) != null) {
            var p = m.index;
            var w = m + "";
            ret.push({ start: st + p + start, str: w });

            st += p + w.length;
            s = s.substr(p + w.length);
        }

        return ret;
    },

    isNumber: function (s, allowoperator) {
        if (typeof (s) == "number")
            return true;
        if (scil.Utils.isNullOrEmpty(s))
            return false;

        var p = s.indexOf('.');
        if (p > 0) {
            var i = s.indexOf(',');
            if (i > 0 && i < p)
                s = s.replace(/[,]/g, '');
        }

        // I#11086
        if (allowoperator)
            return new RegExp("^[>|<|≥|≤]?[ ]{0,50}[-]?[0-9]+([\.][0-9]{0,50})?([e|E][-|+][0-9]+)?([ ]{0,50}[±][0-9]{0,50}([\.][0-9]{0,50})?)?$").test(s + "");
        else
            return !isNaN(s);
    },

    htmlDecode: function (s) {
        if (scil.Utils.isNullOrEmpty(s))
            return s;
        var e = document.createElement('div');
        e.innerHTML = s;
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    },

    html2Text: function (html) {
        if (this.isNullOrEmpty(html))
            return html;
        var e = document.createElement('div');
        e.innerHTML = html;
        return e.childNodes.length === 0 ? "" : this.getInnerText(e);
    },

    parseNumber: function (s) {
        var n = s == null ? NaN : parseFloat(s);
        return isNaN(n) ? null : n;
    },

    /**
    * Test if it is null or empty string
    * @function {static} isNullOrEmpty
    * @param {var} s - var to be tested
    * @returns bool
    */
    isNullOrEmpty: function (s) {
        return s == null || typeof (s) == "string" && s == "";
    },

    /**
    * Test if it is not a number
    * @function {static} isNaN
    * @param {var} n - var to be tested
    * @returns bool
    */
    isNaN: function (n) {
        return n == null || isNaN(n);
    },

    /**
    * Get outer xml of an XML element
    * @function {static} getOuterXml
    * @param {XMLElement} e
    * @returns a string
    */
    getOuterXml: function (e) {
        if (e == null)
            return null;
        return e.xml != null ? e.xml : (new XMLSerializer()).serializeToString(e);
    },

    /**
    * Add css script in a page
    * @function {static} addCss
    * @param {string} code - css script
    */
    addCss: function (code) {
        var style = document.createElement('style');
        style.type = 'text/css';

        if (style.styleSheet) {
            // IE
            style.styleSheet.cssText = code;
        } else {
            // Other browsers
            style.innerHTML = code;
        }

        document.getElementsByTagName("head")[0].appendChild(style);
    },

    /**
    * Insert all items of a dirctionary in another dictionary
    * @function {static} insertAfterDict
    * @param {dict} dict - destination
    * @param {dict} items - items to be inserted
    * @param {string} key - reference item
    */
    insertAfterDict: function (dict, items, key) {
        var found = false;

        var temp = {};
        for (var k in dict) {
            if (k == key) {
                found = true;
            }
            else if (found) {
                temp[k] = dict[k];
                delete dict[k];
            }
        }

        for (var k in items)
            dict[k] = items[k];

        for (var k in temp)
            dict[k] = temp[k];
    },

    /**
    * Insert all items of a dirctionary in another dictionary
    * @function {static} insertBeforeDict
    * @param {dict} dict - destination
    * @param {dict} items - items to be inserted
    * @param {string} key - reference item
    */
    insertBeforeDict: function (dict, items, key) {
        var found = false;

        var temp = {};
        for (var k in dict) {
            if (k == key || found) {
                found = true;
                temp[k] = dict[k];
                delete dict[k];
            }
        }

        for (var k in items)
            dict[k] = items[k];

        for (var k in temp)
            dict[k] = temp[k];
    },

    disableSelection: function (d) {
        if (d == null)
            return;

        scil.apply(d.style, {
            webkitTouchCallout: "none", /* iOS Safari */
            webkitUserSelect: "none", /* Chrome */
            mozUserSelect: "none", /* Firefox */
            msUserSelect: "none", /* IE/Edge */
            userSelect: "none"
        });
    },

    getLastBarcode: function (callback, category, email, url) {
        scil.Utils.jsonp(url != null ? url : "JSDraw/Service.aspx?cmd=mobile.getlast", function (ret) {
            callback(ret);
        }, { category: category, useremail: email });
    },

    beep: function (doublebeep) {
        if (typeof (Audio) == "undefined")
            return;

        if (this._beepobj == null)
        //this._beepobj = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");
            this._beepobj = new Audio("data:audio/wav;base64,UklGRtoEAABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0YbUEAAB9dXFpa3F4fYSLkZiUjoeCe3RuaWtze36GjJOZkYyGgHpybGhvc3uBiI2UmZCKhX93cWxob3Z9g4mQlZaPioN8dm9qanF4f4OLkZeUjoiBe3RvaWxzeICGi5OYlIuFgXlybWltdHuBiI6Ul5CLhn14cmlqcHV8g4mOl5ePiYR8dnBoa3F3foWKkZaVjoiBenVwZ2xyeoCFjZKXlIyGgHpza2lvdHmCh4+Tl5KKhX54cWtpb3Z9gYmPlpePiYN9dnBoa3F4foOLkZeWjYmAfHRvZ25yeX+FjZKXlIyFgXlza2lvc3uAh46Vl5CLhX93cWtqb3V9g4iQlZePioJ9dnFoa3F4foSKkZaUj4eBfHVuaWtzeX+GjJKYk4yGgHl0bWdudXt/iI2VmJCMhX53cWtqb3Z8g4iQlZaPioN8dnFoa3B4foSKkZeVjoiCe3RuaWxzeX+Gi5OXk42Gf3tzbGhtdXuBh4yVl5GMhH54cmtpcHV8g4mOlpaRiYN9dm9raXF4fYSLkJaWjoeCenZuaGxzeICFjJOXk4yHf3pzbWltdHqBiI2Ul5GNhH54cmtpbnd7gomQlZePi4J9dnBqanF3fYOLkJiUj4eBfHVuaWtzeX+FjJKYk4yHgHpzbGltc3uBh42Vl5GLhX92c2ppcXV8gomPlZiOioJ+dnFpaXF5fYOKkZeWjYiDenVuaWtzeIGFjJKXk42GgHl1bWhtdHt/h42Vl5KLhH93c2tob3V9g4iPlZePi4N8d3Bpa3F3foSJkZaWj4eCfHNvaGtyen+FjJGYlIuIgHl0bGhuc3uBh42Ul5KMg4B4cmtocXR8g4mPlZWRioJ9d29ram93foSJkZeUjomCe3VvaG1yd3+Hi5KYlI2GgHpzbmdtdHqBiIyVlpKLhH95cmppb3V8g4iOlpeQiYN+dnFqaXJ2fYSLj5iUj4iCfHRuaWxzeH+FjJGYk42Hf3tzbWhudHqAho6TmZGLhX94c2ppbnZ8gomOlpePi4J+dnBqanB3foOKkJeWjoiBfHRwaGxyeH+Gi5KYk46GgXpzbWdudHqAh46TmJGMhX54cmtpb3V8g4ePlZiPioR9dnFpa3B2foOKkZaVj4iBfHZuaWxyeX6EjZGYlI2GgXlzbmhuc3qBho2Ul5KLhX95cWtpcHV8gYiPlZePi4R8d3FpanB3foOKkJiVjomBe3ZuamtyeICFipOWlI6FgXp1a2psc3uAh46SmJKLhX94c2tocHR9goiOlZeRioN9d3BqaXF3foKLkJWVj4mBfHVvaWtyeH+Gi5KXloyHgHl0bmhuc3qAh42Tl5KMhX55cmtocHZ7goiOlZePioR8eHBqanF2fYSJkJiVj4iCfHZuaGxzeH2Hi5KXlY2FgHtzbWltc3qAh42UlpKMhX94c2tqbnZ6gomOlpaRi4N9d3FpanF2fYSKkJWWjomCe3ZvaWtxeX6Fi5KYk42HgXp0bmhtc3uAhoyUmJKLhYB4c2tocHR9gYiOlpeQioN9d3JqanB3fISJkJeVj4iBfnRwaWpyeX6FjJGXlI6GgHp1bGlucnqBhoyUmJKMhH94c21nb3V8gYmOlZeQi4N+d3FqaXB3fQA=");
        this._beepobj.play();

        if (doublebeep) {
            var me = this;
            setTimeout(function () { me._beepobj.play(); }, 300);
        }
    },

    textareaSelect: function (ta, startPos, endPos) {
        // do selection
        // Chrome / Firefox
        if (typeof (ta.selectionStart) != "undefined") {
            ta.focus();
            ta.selectionStart = startPos;
            ta.selectionEnd = endPos;
        }

        // IE
        if (document.selection && document.selection.createRange) {
            ta.focus();
            ta.select();
            var range = document.selection.createRange();
            range.collapse(true);
            range.moveEnd("character", endPos);
            range.moveStart("character", startPos);
            range.select();
        }
    },

    /**
    * Fire an event
    * @function {static} fireEvent
    * @param {DOM} element
    * @param {string} eventname
    */
    fireEvent: function (element, eventname, bubbles, cancelable, args) {
        var event; // The custom event that will be created

        if (document.createEvent) {
            event = document.createEvent("HTMLEvents");
            event.initEvent(eventname, bubbles == null ? true : bubbles, cancelable == null ? true : cancelable);
        } else {
            event = document.createEventObject();
            event.eventType = eventname;
        }

        if (args != null)
            scil.apply(event, args);

        event.eventName = eventname;

        if (document.createEvent) {
            element.dispatchEvent(event);
        } else {
            element.fireEvent("on" + event.eventType, event);
        }
    },

    sum: function (list) {
        return scil.Math.sum(list);
    },

    avg: function (list) {
        return scil.Math.avg(list);
    },

    stdev: function (list) {
        return scil.Math.stdev(list);
    },

    xml2Lines: function (xml) {
        var doc = xml == null ? null : scil.Utils.parseXml("<d> " + xml + "</d>");
        var root = doc == null ? null : doc.documentElement || doc.firstElementChild;
        if (root == null)
            return null;

        var ret = [];
        var lines = scil.Utils.getElements(root, null);
        for (var i = 0; i < lines.length; ++i) {
            var e = lines[i];
            var line = {};
            for (var k = 0; k < e.attributes.length; ++k) {
                var a = e.attributes[k];
                line[a.name] = a.value;
            }
            ret.push(line);
        }

        return ret;
    }
};

scil.form = {};
JsUtils = scil.Utils;
scil.Utils.padleft = scil.Utils.padLeft;
scil.Utils.padright = scil.Utils.padRight;

﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
@project JSDraw
@version 6.0.0
@description JSDraw Chemical/Biological Structure Editor
*/

/**
* JSDraw2 namespace
* @namespace scilligence.JSDraw2
*/
JSDraw2 = {};
JSDrawServices = {};
scilligence.JSDraw2 = JSDraw2;
scilligence.JSDraw3 = JSDraw3 = JSDraw2;

JSDraw2.speedup = { fontsize: 2, gap: 0, disableundo: false, minbondlength: 1 };

/**
* JSDraw Version
* @property scilligence.JSDraw2.version
*/
JSDraw2.version = "JSDraw V6.0.0";

// JSDraw file version
JSDraw2.kFileVersion = "5.0";

/**
* JSDraw Default Options
* @property {dictionay} scilligence.JSDraw2.defaultoptions default Editor options: { skin: "w8" or null, delheteroatom: false, salts: { name: MF, ...}, abbreviations: {}, tlc: {}, popupwidth: number, popupheight: number, popupxdraw: true or false, monocolor: true or false, jdrawpath: "http://server/jdraw/" }
*/
JSDraw2.defaultoptions = {};
JSDraw2.config = {};
JSDraw2.password = {encrypt:true};

JSDraw2.TEXTKEYWORDS = ["°C", "rt", "reflux", "hr", "min", "sec", "psi", "atm", "overnight", "microwave", "Δ"];
JSDraw2.MOLECULETYPES = ["SmallMolecule", "Polymer", "Peptide", "DNA", "RNA", "ADC", "ChemicalReagent"];
JSDraw2.CHIRALITIES = ["Achiral", "Absolute", "Racemic", "Diastereomeric", "Enatiomer R", "Enatiomer S"];

/**
* Predefined Bond Types:
<pre>
JSDraw2.BONDTYPES = {
    UNKNOWN: 0,
    SINGLE: 1,
    DOUBLE: 2,
    TRIPLE: 3,
    DELOCALIZED: 4,
    WEDGE: 5,
    HASH: 6,
    WIGGLY: 7,
    EITHER: 8,
    SINGLEORDOUBLE: 9,
    SINGLEORAROMATIC: 10,
    DOUBLEORAROMATIC: 11,
    QUADRUPLE: 12,
    DUMMY: 13,
    PEPTIDE: 21,
    NUCLEOTIDE: 22,
    DISULFIDE: 23,
    AMIDE: 24
}
</pre>
* @class {static} scilligence.JSDraw2.BONDTYPES
*/
JSDraw2.BONDTYPES = {
    UNKNOWN: 0,
    SINGLE: 1,
    DOUBLE: 2,
    TRIPLE: 3,
    DELOCALIZED: 4,
    WEDGE: 5,
    HASH: 6,
    WIGGLY: 7,
    EITHER: 8,
    SINGLEORDOUBLE: 9,
    SINGLEORAROMATIC: 10,
    DOUBLEORAROMATIC: 11,
    QUADRUPLE: 12,
    DUMMY: 13,
    BOLD: 14,
    BOLDHASH: 15,
    PEPTIDE: 21,
    NUCLEOTIDE: 22,
    DISULFIDE: 23,
    AMIDE: 24
};

JSDraw2.RXNCENTER = {
    NOTCENTER: -1,
    CENTER: 1,
    BREAK: 4,
    CHANGE: 8,
    BREAKANDCHANGE: 12
};

JSDraw2.ALIGN = {
    RIGHT: 0,
    BOTTOM: 1,
    LEFT: 2,
    TOP: 3
};

JSDraw2.BIO = {
    AA: 'AA',
    //BASE: 'BASE',
    ANTIBODY: 'ANTIBODY',
    PROTEIN: "PROTEIN",
    GENE: "GENE",
    DNA: "DNA",
    RNA: "RNA",
    BASE_DNA: "BASEDNA",
    BASE_RNA: "BASERNA"
};

JSDraw2.ANTIBODY = {
    IgG: "IgG",
    Fab: "Fab",
    ScFv: "ScFv"
};


JSDraw2.DNATable = {
    GCT: "A", GCC: "A", GCA: "A", GCG: "A",
    CGT: "R", CGC: "R", CGA: "R", CGG: "R", AGA: "R", AGG: "R",
    AAT: "", AAC: "N",
    GAT: "D", GAC: "D",
    TGT: "C", TGC: "C",
    CAA: "Q", CAG: "Q",
    GAA: "E", GAG: "E",
    GGT: "G", GGC: "G", GGA: "G", GGG: "G",
    CAT: "H", CAC: "H",
    ATT: "I", ATC: "I", ATA: "I",
    TTA: "L", TTG: "L", CTT: "L", CTC: "L", CTA: "L", CTG: "L",
    AAA: "K", AAG: "K",
    ATG: "M",
    TTT: "F", TTC: "F",
    CCT: "P", CCC: "P", CCA: "P", CCG: "P",
    TCT: "S", TCC: "S", TCA: "S", TCG: "S", AGT: "S", AGC: "S",
    ACT: "T", ACC: "T", ACA: "T", ACG: "T",
    TGG: "W",
    TAT: "Y", TAC: "Y",
    GTT: "V", GTC: "V", GTA: "V", GTG: "V",
    ATG: "[",
    TAA: "]", TGA: "]", TAG: "]"
};


JSDraw2.RNATable = {
    GCU: "A", GCC: "A", GCA: "A", GCG: "A",
    CGU: "R", CGC: "R", CGA: "R", CGG: "R", AGA: "R", AGG: "R",
    AAU: "N", AAC: "N",
    GAU: "D", GAC: "D",
    UGU: "C", UGC: "C",
    CAA: "Q", CAG: "Q",
    GAA: "E", GAG: "E",
    GGU: "G", GGC: "G", GGA: "G", GGG: "G",
    CAU: "H", CAC: "H",
    AUU: "I", AUC: "I", AUA: "I",
    AUG: "[",
    UUA: "L", UUG: "L", CUU: "L", CUC: "L", CUA: "L", CUG: "L",
    AAA: "K", AAG: "K",
    AUG: "M",
    UUU: "F", UUC: "F",
    CCU: "P", CCC: "P", CCA: "P", CCG: "P",
    UCU: "S", UCC: "S", UCA: "S", UCG: "S", AGU: "S", AGC: "S",
    ACU: "T", ACC: "T", ACA: "T", ACG: "T",
    UGG: "W",
    UAU: "Y", UAC: "Y",
    GUU: "V", GUC: "V", GUA: "V", GUG: "V",
    UAA: "]", UGA: "]", UAG: "]"
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.needPro = function () {
    scil.Utils.alert("This is a JSDraw Pro feature.");
};

JSDraw2.Security = {
    kEdition: "Lite",
    error: null,
    valid: true,

    _check: function () {
    }
};


scil.apply(JSDraw2, {
    Text: { cast: function (a) { return null; } },
    Shape: { cast: function (a) { return null; } },
    Bracket: { cast: function (a) { return null; } },
    AssayCurve: { cast: function (a) { return null; } },
    Arrow: { cast: function (a) { return null; } },
    TLC: { cast: function (a) { return null; } },
    Spectrum: { cast: function (a) { return null; } },
    Plus: { cast: function (a) { return null; } },
    Group: { cast: function (a) { return null; } },
    RGroup: { cast: function (a) { return null; } }
});

﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.PT = {
    commonUsed: { C: "C", N: "N", O: "O", S: "S", P: "P", F: "F", Cl: "L", Br: "B", I: "I", H: "H,D,T", Si: null, R: "R" },

    getCommonUsedElements: function (forwhat) {
        var list = [];
        if (forwhat == "menu") {
            for (var e in JSDraw2.PT.commonUsed)
                list.push({ caption: e, shortcut: JSDraw2.PT.commonUsed[e] });
            list.push("-");
        }
        else {
            for (var e in this.commonUsed)
                list.push(e);
        }

        //list.push("...");
        return list;
    },

    '*': { a: 0 },
    'X': { a: 0 }, // halogen
    'R': { a: 0 },

    H: { a: 1, c: '909090', m: 1.0079, em: 1.0078, e: 1, v: [1], iso: { 1: 1.0078, 2: 2.0141, 3: 3.0161} },
    // JSDraw.Pro
    Be: { a: 4, c: 'C2FF00', m: 9.0122, em: 9.0122, v: [0, 2], iso: { 9: 9.0122} },
    B: { a: 5, c: 'FFB5B5', m: 10.811, em: 11.0093, e: 3, v: [3], iso: { 10: 10.0129, 11: 11.0093} },
    C: { a: 6, c: '000000', m: 12.0107, em: 12, e: 4, v: [4], iso: { 12: 12, 13: 13.0034} },
    N: { a: 7, c: '3050F8', m: 14.0067, em: 14.0031, e: 5, v: [3], iso: { 14: 14.0031, 15: 15.0001} },
    O: { a: 8, c: 'FF0D0D', m: 15.9994, em: 15.9949, e: 6, v: [2], iso: { 16: 15.9949, 17: 16.9991, 18: 17.9992} },
    F: { a: 9, c: '90E050', m: 18.9984, em: 18.9984, e: 7, v: [1], iso: { 19: 18.9984} },
    // JSDraw.Pro
    Na: { a: 11, c: 'AB5CF2', m: 22.9898, em: 22.9898, v: [0, 1], iso: { 23: 22.9898} },
    // JSDraw.Pro
    Si: { a: 14, c: 'F0C8A0', m: 28.0855, em: 27.9769, e: 4, v: [4], iso: { 28: 27.9769, 29: 28.9765, 30: 29.9738} },
    P: { a: 15, c: 'FF8000', m: 30.9738, em: 30.9738, e: 5, v: [3, 5], iso: { 31: 30.9738} },
    S: { a: 16, c: 'C0C000', m: 32.065, em: 31.9721, e: 6, v: [2, 4, 6], iso: { 32: 31.9721, 33: 32.9715, 34: 33.9679, 36: 35.9671} },
    Cl: { a: 17, c: '1FF01F', m: 35.453, em: 34.9689, e: 7, v: [1, 3, 5, 7], iso: { 35: 34.9689, 37: 36.9659} },
    // JSDraw.Pro
    K: { a: 19, c: '8F40D4', m: 39.0983, em: 38.9637, v: [0, 1], iso: { 39: 38.9637, 40: 39.964, 41: 40.9618} },
    Ca: { a: 20, c: '3DFF00', m: 40.078, em: 39.9626, v: [0, 2], iso: { 40: 39.9626, 42: 41.9586, 43: 42.9588, 44: 43.9555, 46: 45.9537, 48: 47.9525} },
    // JSDraw.Pro
    Ge: { a: 32, c: '668F8F', m: 72.64, em: 73.9212, v: [4, 2], iso: { 70: 69.9243, 72: 71.9221, 73: 72.9235, 74: 73.9212, 76: 75.9214} },
    As: { a: 33, c: 'BD80E3', m: 74.9216, em: 74.9216, e: 5, v: [3, 5], iso: { 75: 74.9216} },
    Se: { a: 34, c: 'FFA100', m: 78.96, em: 79.9165, e: 6, v: [2, 4, 6], iso: { 74: 73.9225, 76: 75.9192, 77: 76.9199, 78: 77.9173, 80: 79.9165, 82: 81.9167} },
    Br: { a: 35, c: 'A62929', m: 79.904, em: 78.9183, e: 7, v: [1, 3, 5, 7], iso: { 79: 78.9183, 81: 80.9163} },
    // JSDraw.Pro
    I: { a: 53, c: '940094', m: 126.904, em: 126.904, e: 7, v: [1, 3, 5, 7], iso: { 127: 126.904} },
    // JSDraw.Pro

    isElectronAcceptor: function (e) {
        var an = e.a;
        return an >= 6 && an <= 9 || // Element.C && atomicno <= Element.F ||
                an >= 15 && an <= 17 || // atomicno > Element.P && atomicno <= Element.Cl ||
                an >= 33 && an <= 35 || // atomicno >= Element.As && atomicno <= Element.Br ||
                an >= 50 && an <= 53 || // atomicno >= Element.Sb && atomicno <= Element.I ||
                an >= 83 && an <= 85; // atomicno >= Element.Bi && atomicno <= Element.At;
    },

    showQueryAtoms: function (parent, f) {
        var buttons = parent.getElementsByTagName("button");
        for (var i = 0; i < buttons.length; ++i) {
            if (buttons[i].getAttribute("r") == "1")
                buttons[i].style.display = f ? "" : "none";
        }
    },

    makeAtomList: function (list, f) {
        if (list == null || list == "")
            return null;

        var atoms = [];
        var ss = list.split(",");
        for (var i = 0; i < ss.length; ++i) {
            var s = scilligence.Utils.trim(ss[i]);
            if (this.isValidAtomList(s))
                atoms.push(s);
        }

        return atoms.length == 0 ? null : { atoms: atoms, t: !scilligence.Utils.isFalse(f) };
    },

    isMetal: function (atomicno) {
        return false;
    },

    isValidAtomList: function (s) {
        var e = JSDraw2.PT[s];
        return e != null && e.a > 0 || s == "*" || s == "A" || s == "a" || s == "c" || this.isArAtom(s.toUpperCase());
    },

    isArAtom: function (s) {
        return s == "C" || s == "N" || s == "S" || s == "P" || s == "O";
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Atom class
* @class scilligence.JSDraw2.Atom
*/
JSDraw2.Atom = scil.extend(scil._base, {
    /**
    @property {Point} p Atom Coordinate
    */
    /**
    @property {number} charge Atom charges
    */
    /**
    @property {number} isotope Atom Isotope
    */
    /**
    @property {number} radical Atom Radical
    */
    /**
    @property {string} elem Element Symbol 
    */
    /**
    @property {string} color Display Color
    */
    /**
    @property {bool} selected Selecting Flag
    */

    /**
    * @constructor Atom
    * @param {Point} p - coordinate
    * @param {string} elem - element symbol
    * @bio {bool} bio - indicate if this is a Bio object
    */
    constructor: function (p, elem, bio) {
        this.T = "ATOM";
        this.p = p;
        this.charge = 0;
        this.isotope = null;
        this.radical = null;
        this.group = null;
        this.alias = null;
        this.superatom = null;
        this.attachpoints = [];
        this.rgroup = null;
        this.bio = bio;
        this.locked = false;
        this.hidden = null;
        this._rect = null;
        if (bio == null) {
            if (elem == null || elem.length == 0) {
                this.elem = "C";
            }
            else if (elem == "D") {
                this.elem = "H";
                this.isotope = 2;
            }
            else if (elem == "T") {
                this.elem = "H";
                this.isotope = 3;
            }
            else {
                this.elem = elem;
            }
        }
        else {
            this.elem = elem;
        }
        this.color = null;
        this.hcount = null;
        this.selected = false;
        this.f = null;
        this.bonds = null;
        this.id = null;
        this.atommapid = null;
        this.query = null;
        this.hasError = null;
        this.hs = null;
        this.val = null;
        this.tag = null;
    },

    clone: function (selectedOnly) {
        var a = new JSDraw2.Atom(this.p.clone(), this.elem, dojo.clone(this.bio));
        a.charge = this.charge;
        a.isotope = this.isotope;
        a.radical = this.radical;
        a.hcount = this.hcount;
        a.id = this.id;
        a.color = this.color;
        a.tag = this.tag;
        a.alias = this.alias;
        a.superatom = this.superatom == null ? null : this.superatom.clone();
        a.attachpoints = scil.clone(this.attachpoints);
        a.rgroup = this.rgroup == null ? null : this.rgroup.clone(selectedOnly);
        a.atommapid = this.atommapid;
        a.hasError = this.hasError;
        a.hs = this.hs;
        a.val = this.val;
        if (this.query != null)
            a.query = scil.clone(this.query);
        if (this.bio != null)
            a.bio = scil.clone(this.bio);
        a.locked = this.locked;
        a.hidden = this.hidden;
        a.ratio = this.ratio;
        a.selected = this.selected;
        return a;
    },

    biotype: function () {
        return this.bio == null ? null : this.bio.type;
    },

    isMarkedStereo: function () {
        var bs = this.bonds;
        if (bs == null || bs.length != 3 && bs.length != 4)
            return false;

        for (var i = 0; i < bs.length; ++i) {
            if (bs[i].a1 == this && (bs[i].type == JSDraw2.BONDTYPES.WEDGE || bs[i].type == JSDraw2.BONDTYPES.HASH))
                return true;
        }

        return false;
    },

    updateRGroup: function () {
        if (this.rgroup != null)
            this.rgroup.text = (this.alias == null || this.alias == "" ? this.elem : this.alias) + "=";
    },

    getLabel: function () {
        if (this.alias != null && this.alias != "")
            return this.alias;
        return this.elem;
    },

    html: function (scale, len) {
        var s = "<a i='" + this.id + "' e='" + scil.Utils.escXmlValue(this.elem) + "' p='" + this.p.toString(scale) + "'";
        if (this.bio == null) {
            if (this.charge != 0)
                s += " c='" + this.charge + "'";
            if (this.radical >= 1 && this.radical <= 3)
                s += " rad='" + this.radical + "'";
            if (this.isotope > 0)
                s += " iso='" + this.isotope + "'";
            if (this.tag != null && this.tag != "")
                s += " tag='" + scil.Utils.escXmlValue(this.tag) + "'";
            if (this.alias != null && this.alias != "")
                s += " alias='" + scil.Utils.escXmlValue(this.alias) + "'";
            if (this.color != null)
                s += " clr='" + this.color + "'";
            if (this.atommapid > 0)
                s += " ami='" + this.atommapid + "'";
            if (this.locked)
                s += " locked='1'";
            if (this.attachpoints.length > 0) {
                var apos = "";
                for (var i = 0; i < this.attachpoints.length; ++i)
                    apos += (i > 0 ? ',' : '') + this.attachpoints[i];
                s += " apo='" + apos + "'";
            }
            if (this.hs > 0)
                s += " hs='" + this.hs + "'";
            if (this.val > 0)
                s += " val='" + this.val + "'";
            if (this.group != null)
                s += " g='" + this.group.id + "'";
            if (this.query != null) {
                if (this.query.sub != null)
                    s += " sub='" + this.query.sub + "'";
                if (this.query.uns != null)
                    s += " uns='" + (this.query.uns ? 1 : 0) + "'";
                if (this.query.rbc != null)
                    s += " rbc='" + this.query.rbc + "'";
                if (this.query.als != null && this.query.t != null) {
                    s += " als='" + this.query.als.join(',') + "'";
                    s += " als_t='" + (this.query.t == false ? 0 : 1) + "'";
                }
            }
        }
        else {
            s += " bio='" + this.bio.type + "'";
            if (!scil.Utils.isNullOrEmpty(this.bio.subtype))
                s += " subtype='" + this.bio.subtype + "'";
            if (!scil.Utils.isNullOrEmpty(this.bio.sequences))
                s += " seq='" + scil.Utils.escXmlValue(this.bio.sequences) + "'";
            if (this.bio.id > 0)
                s += " bioid='" + scil.Utils.escXmlValue(this.bio.id) + "'";
            if (!scil.Utils.isNullOrEmpty(this.bio.annotation))
                s += " ann='" + scil.Utils.escXmlValue(this.bio.annotation) + "'";
            if (this.elem == "?" && !scil.Utils.isNullOrEmpty(this.bio.ambiguity))
                s += " amb='" + scil.Utils.escXmlValue(this.bio.ambiguity) + "'";
            if (this.biotype() == org.helm.webeditor.HELM.BLOB && !scil.Utils.isNullOrEmpty(this.bio.blobtype))
                s += " blobtype='" + scil.Utils.escXmlValue(this.bio.blobtype) + "'";
        }

        if (this.rgroup == null && this.superatom == null) {
            s += "/>";
        } else {
            s += ">\n";
            if (this.rgroup != null) {
                s += "<rgroup>\n";
                s += this.rgroup.html(scale) + "\n";
                for (var j = 0; j < this.rgroup.mols.length; ++j) {
                    var s2 = this.rgroup.mols[j]._getXml(null, null, null, null, len, true);
                    if (s2 != null)
                        s += s2;
                }
                s += "</rgroup>";
            }
            if (this.superatom != null) {
                s += "<superatom>\n";
                s += this.superatom._getXml(null, null, null, null, len, true);
                s += "</superatom>";
            }
            s += "</a>";
        }
        return s;
    },

    readHtml: function (e) {
        var c = e.getAttribute("c");
        if (c != null)
            this.charge = parseInt(c);

        var r = e.getAttribute("clr");
        if (r != null)
            this.color = r;

        var rad = e.getAttribute("rad");
        if (rad != null && rad != "")
            this.radical = parseInt(rad);

        var iso = e.getAttribute("iso");
        if (iso != null && iso != "")
            this.isotope = parseInt(iso);

        var hs = e.getAttribute("hs");
        if (hs != null && hs != "")
            this.hs = parseInt(hs);

        var val = e.getAttribute("val");
        if (val != null && val != "")
            this.val = parseInt(val);

        var tag = e.getAttribute("tag");
        if (tag != null && tag != "")
            this.tag = tag;

        var alias = e.getAttribute("alias");
        if (alias != null && alias != "")
            this.alias = alias;

        var ami = e.getAttribute("ami");
        if (ami != null && !isNaN(ami))
            this.atommapid = parseInt(ami);

        var apo = e.getAttribute("apo");
        if (apo != null && apo != '') {
            var ss = apo.split(',');
            for (var i = 0; i < ss.length; ++i) {
                var s2 = ss[i];
                var apo = isNaN(s2) ? 0 : parseInt(s2);
                if (apo > 0)
                    this.attachpoints.push(apo);
            }
        }

        var rbc = e.getAttribute('rbc');
        if (rbc != null) {
            if (this.query == null)
                this.query = {};
            this.query.rbc = parseInt(rbc);
        }

        var sub = e.getAttribute('sub');
        if (sub != null) {
            if (this.query == null)
                this.query = {};
            this.query.sub = sub == '*' ? '*' : parseInt(sub);
        }

        var uns = e.getAttribute('uns');
        if (uns == "1" || uns == "0") {
            if (this.query == null)
                this.query = {};
            this.query.uns = uns == "1";
        }

        var als = JSDraw2.PT.makeAtomList(e.getAttribute('als'), e.getAttribute('als_t'));
        if (als != null) {
            if (this.query == null)
                this.query = {};
            this.query.als = als.atoms;
            this.query.t = als.t;
        }

        if (this.bio != null) {
            this.bio.subtype = e.getAttribute("subtype");
            this.bio.sequences = e.getAttribute("seq");
            bioid = parseInt(e.getAttribute("bioid"));
            if (bioid > 0)
                this.bio.id = bioid;

            var ann = e.getAttribute("ann");
            if (!scil.Utils.isNullOrEmpty(ann))
                this.bio.annotation = ann;

            var amb = e.getAttribute("amb");
            if (this.elem == "?" && !scil.Utils.isNullOrEmpty(amb))
                this.bio.ambiguity = amb;

            var blobtype = e.getAttribute("blobtype");
            if (this.biotype() == org.helm.webeditor.HELM.BLOB && !scil.Utils.isNullOrEmpty(blobtype))
                this.bio.blobtype = blobtype;
        }

        if (this.elem != null) {
            var rg = scil.Utils.getFirstElement(e, "rgroup");
            if (rg) {
                var t = scil.Utils.getFirstElement(rg, "i");
                if (t != null) {
                    var r = new JSDraw2.RGroup();
                    if (r.readHtml(t, null)) {
                        this.rgroup = r;

                        r.position = JSDraw2.Point.fromString(e.getAttribute("p"));
                        var divs = scil.Utils.getElements(rg, "div");
                        for (var i = 0; i < divs.length; ++i) {
                            var m = new JSDraw2.Mol();
                            if (m.setXml(divs[i]) != null)
                                r.mols.push(m);
                        }
                    }
                }
            }
        }

        if (this.alias != null || this.bio != null) {
            var superatom = scil.Utils.getFirstElement(e, "superatom");
            var div = superatom == null ? null : scil.Utils.getFirstElement(superatom, "div");
            if (div != null) {
                var m = new JSDraw2.Mol();
                if (m.setXml(div) != null) {
                    if (m.atoms.length == 1 && m.atoms[0].elem == this.alias) {
                        this.elem = this.alias;
                        this.alias = null;
                    }
                    else {
                        this.superatom = m;
                    }
                }
            }
        }
    },

    toggle: function (p, tor) {
        if (this._rect != null)
            return this._rect.contains(p);
        return this.p.distTo(p) <= tor;
    },

    drawCur: function (surface, r, color, m) {
        var c = this._rect == null ? this.p : this._rect.center();
        surface.createCircle({ cx: c.x, cy: c.y, r: r }).setFill(color);
        if (this.elem == "@" && m != null) {
            var list = m.getAllBonds(this);
            for (var i = 0; i < list.length; ++i) {
                var b = list[i];
                if (b.type == JSDraw2.BONDTYPES.DUMMY)
                    b.otherAtom(this).drawCur(surface, r * 0.75, color);
            }
        }
    },

    needShowAtomLabel: function () {
        return this.elem != 'C' || this.charge != 0 || this.isotope != null || this.hcount == 4;
    },

    showLabel: function () {
        return a.elem != 'C' || a.charge != 0 || a.isotope != null || a.hcount == 4;
    },

    drawBio: function (surface, linewidth, fontsize, color) {
        var a = this;
        var biotype = this.biotype();
        var p = a.p.clone();
        if (biotype == JSDraw2.BIO.ANTIBODY) {
            color = "#00f";
            var color2 = a.bio.subtype == JSDraw2.ANTIBODY.ScFv ? "#bbb" : color;
            var color3 = a.bio.subtype == JSDraw2.ANTIBODY.ScFv || a.bio.subtype == JSDraw2.ANTIBODY.Fab ? "#bbb" : color;
            surface.createCircle({ cx: p.x, cy: p.y, r: fontsize })
                    .setFill("white")
                    .setStroke({ color: color, width: linewidth / 2 });
            fontsize /= 2;
            p.offset(0, -linewidth);
            JSDraw2.Drawer.drawLine(surface, new JSDraw2.Point(p.x - linewidth, p.y), new JSDraw2.Point(p.x - linewidth - fontsize, p.y - fontsize), color2, linewidth);
            JSDraw2.Drawer.drawLine(surface, new JSDraw2.Point(p.x + linewidth, p.y), new JSDraw2.Point(p.x + linewidth + fontsize, p.y - fontsize), color, linewidth);
            JSDraw2.Drawer.drawLine(surface, new JSDraw2.Point(p.x - 2 * linewidth, p.y + fontsize / 1.5), new JSDraw2.Point(p.x - 2 * linewidth - fontsize, p.y - fontsize + fontsize / 1.5), color2, linewidth);
            JSDraw2.Drawer.drawLine(surface, new JSDraw2.Point(p.x + 2 * linewidth, p.y + fontsize / 1.5), new JSDraw2.Point(p.x + 2 * linewidth + fontsize, p.y - fontsize + fontsize / 1.5), color, linewidth);
            JSDraw2.Drawer.drawLine(surface, new JSDraw2.Point(p.x - linewidth, p.y), new JSDraw2.Point(p.x - linewidth, p.y + fontsize * 2), color3, linewidth);
            JSDraw2.Drawer.drawLine(surface, new JSDraw2.Point(p.x + linewidth, p.y), new JSDraw2.Point(p.x + linewidth, p.y + fontsize * 2), color3, linewidth);
        }
        else if (biotype == JSDraw2.BIO.PROTEIN) {
            var colors = [{ offset: 0, color: "#4ea1fc" }, { offset: linewidth / 20, color: "#0072e5" }, { offset: linewidth / 10, color: "#003b80"}];
            surface.createCircle({ cx: this.p.x, cy: this.p.y, r: fontsize })
                    .setFill({ type: "radial", cx: this.p.x + fontsize / 4, cy: this.p.y + fontsize / 4, colors: colors });
        }
        else if (biotype == JSDraw2.BIO.GENE || biotype == JSDraw2.BIO.DNA || biotype == JSDraw2.BIO.RNA) {
            color = "#00f";
            var color2 = a.bio.subtype == JSDraw2.ANTIBODY.ScFv ? "#bbb" : color;
            var color3 = a.bio.subtype == JSDraw2.ANTIBODY.ScFv || a.bio.subtype == JSDraw2.ANTIBODY.Fab ? "#bbb" : color;
            surface.createCircle({ cx: p.x, cy: p.y, r: fontsize })
                    .setFill("white")
                    .setStroke({ color: color, width: linewidth / 2 });
            this.drawEllipse(surface, p.x + fontsize / 6, p.y + fontsize / 3, fontsize / 6, fontsize / 2, color, -20);
            this.drawEllipse(surface, p.x + fontsize / 6, p.y - fontsize / 3, fontsize / 6, fontsize / 2, color, +20);
            this.drawEllipse(surface, p.x - fontsize / 6, p.y + fontsize / 3, fontsize / 6, fontsize / 2, color, +20);
            this.drawEllipse(surface, p.x - fontsize / 6, p.y - fontsize / 3, fontsize / 6, fontsize / 2, color, -20);
        }
        else if (org.helm.webeditor.isHelmNode(a)) {
            org.helm.webeditor.Interface.drawMonomer(surface, a, p, fontsize, linewidth, color);
        }
        else {
            if (color == null)
                color = a.bio.type == JSDraw2.BIO.AA ? "#00F" : (a.bio.type == JSDraw2.BIO.BASE_RNA ? "#278925" : "#FFAA00");
            this.drawDiamond(surface, p.x, p.y, fontsize * 0.55, color, linewidth);
            p.offset(0, -1);
            JSDraw2.Drawer.drawLabel(surface, p, a.elem, color, fontsize * (a.elem.length > 1 ? 2 / a.elem.length : 1.0), null, null, null, false);
        }

        //if (this.selected)
        //    this.drawSelect(surface, linewidth);
    },

    drawDiamond: function (surface, x, y, w, color, linewidth) {
        surface.createRect({ x: x - w, y: y - w, width: 2 * w, height: 2 * w })
            .setTransform([dojox.gfx.matrix.rotategAt(45, x, y)])
            .setFill("white")
            .setStroke({ color: color, width: linewidth / 2 });
    },

    drawEllipse: function (surface, x, y, rx, ry, color, deg) {
        surface.createEllipse({ cx: x, cy: y, rx: rx, ry: ry })
            .setFill(color)
            .setTransform([dojox.gfx.matrix.rotategAt(deg, x, y)]);
    },

    hasLabel: function (m, showcarbon) {
        var a = this;
        return a.bio == null && (a.elem != 'C' || a.charge != 0 || a.radical != null ||
            a.elem == 'C' && (showcarbon == "all" || showcarbon == "terminal" && m.getNeighborAtoms(a).length == 1) ||
            a.isotope != null || a.hcount == 4 || a.hs > 0 || a.val > 0 || a.alias != null && a.alias != "" ||
            a.query != null && (a.query.sub != null || a.query.uns != null || a.query.rbc != null || a.query.als != null && a.query.t != null));
    },

    hasErr: function () {
        var a = this;
        var e = a.bio ? null : JSDraw2.PT[a.elem];
        return (!a.bio && (e == null || e.a >= 0 && a.hasError)) && a.elem != "3'" && a.elem != "5'";
    },

    draw: function (surface, linewidth, m, fontsize, showError) {
        var a = this;

        this._rect = null;
        var e = a.bio ? null : JSDraw2.PT[a.elem];
        var hasError = showError && this.hasErr();
        var color = a.color;

        if (a.bio != null) {
            this.drawBio(surface, linewidth, fontsize, color);
            return;
        }

        var atomcolor = color;
        if (color == null) {
            if (surface.monocolor)
                color = "black";
            else
                color = e == null || e.c == null ? "#000" : "#" + e.c;
            atomcolor = color;
            if (hasError)
                atomcolor = e == null || e.c == null ? "#000" : "#fff";
        }

        if (a.attachpoints.length > 0)
            this.drawApo(a, m, surface, linewidth, fontsize, color);

        if (a.alias != null && a.alias != "") {
            this._rect = JSDraw2.Atom.drawAlias(m.calcHDir(a, 4 * linewidth, true), surface, a.p, a.alias, hasError ? "red" : atomcolor, fontsize);
        }
        else {
            var elem = a.elem;
            var isotope = a.isotope;
            if (elem == "H") {
                if (isotope == 2) {
                    elem = "D";
                    isotope = null;
                }
                else if (isotope == 3) {
                    elem = "T";
                    isotope = null;
                }
            }
            else if (a.query != null) {
                var x = "";
                var x2 = "";
                if (a.query.als != null)
                    x = (a.query.t == false ? "!" : "") + "[" + a.query.als.join(",") + "]";
                if (a.query.rbc != null)
                    x2 += (x2 == "" ? "" : ",") + "r" + a.query.rbc;
                if (a.query.sub != null)
                    x2 += (x2 == "" ? "" : ",") + "s" + a.query.sub;
                if (a.query.uns)
                    x2 += (x2 == "" ? "" : ",") + "u";

                if (x != "" || x2 != "")
                    elem = (x == "" ? elem : x) + (x2 == "" ? "" : "(" + x2 + ")");
            }

            var x2 = 0;
            var y2 = 0;
            if (hasError || this._haslabel) {
                var t = JSDraw2.Drawer.drawLabel(surface, a.p, elem, atomcolor, fontsize, hasError ? "#f00" : false);
                var c = null;
                var h = null;
                var n = null;
                var iso = null;

                var s = "";
                if (a.charge != 0)
                    s += (Math.abs(a.charge) == 1 ? "" : Math.abs(a.charge) + "") + (a.charge > 0 ? "+" : "-");
                switch (a.radical) {
                    case 1:
                        s += ":";
                        break;
                    case 2:
                        s += "^";
                        break;
                    case 3:
                        s += "^^";
                        break;
                }
                if (s != "")
                    c = JSDraw2.Drawer.drawLabel(surface, a.p, s, color, fontsize / 1.2, false);

                if (isotope != null)
                    iso = JSDraw2.Drawer.drawLabel(surface, a.p, isotope + "", color, fontsize / 1.1, false);
                if (a.query == null && a.hcount > 0 && (this._haslabel || elem != "C" || a.charge != 0 || a.hcount == 4)) {
                    h = JSDraw2.Drawer.drawLabel(surface, a.p, 'H', color, fontsize, false);
                    n = a.hcount == 1 ? null : JSDraw2.Drawer.drawLabel(surface, a.p, a.hcount + "", color, fontsize / 1.4, false);
                }

                var tw = t.getTextWidth();
                if (c != null || h != null || n != null || iso != null) {
                    var extra = scil.Utils.isOpera ? Math.round(fontsize / 4) : 0;
                    var hw = h == null ? 0 : h.getTextWidth() + extra;
                    var nw = n == null ? 0 : n.getTextWidth() + extra;
                    var cw = c == null ? 0 : c.getTextWidth() + extra;
                    var iw = iso == null ? 0 : iso.getTextWidth() + extra;

                    var noAdj = true; //scil.Utils.isIE || scil.Utils.isTouch;
                    switch (m.calcHDir(a, 4 * linewidth)) {
                        case JSDraw2.ALIGN.RIGHT:
                            if (iso != null)
                                iso.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw / 2 + (noAdj ? 0 : 2)), -4)]);
                            if (h != null)
                                h.setTransform([dojox.gfx.matrix.translate(tw / 2 + hw / 2 + (noAdj ? 0 : 2), 0)]);
                            if (n != null)
                                n.setTransform([dojox.gfx.matrix.translate(tw / 2 + hw + nw / 2 + (noAdj ? 0 : 4), 4)]);
                            if (c != null)
                                c.setTransform([dojox.gfx.matrix.translate(tw / 2 + hw + nw + cw / 2 + (noAdj ? 0 : 2), -4)]);
                            x2 = tw / 2 + hw + nw + cw + (noAdj ? 0 : 2);
                            break;
                        case JSDraw2.ALIGN.LEFT:
                            if (iso != null)
                                iso.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw / 2 + (noAdj ? 0 : 2)), -4)]);
                            if (n != null)
                                n.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw + nw / 2 + (noAdj ? 0 : 4)), 4)]);
                            if (h != null)
                                h.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw + nw + hw / 2 + (noAdj ? 0 : 6)), 0)]);
                            if (c != null)
                                c.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw + nw + hw + cw / 2 + (noAdj == 0 ? 0 : 0)), -4)]);
                            x2 = tw / 2;
                            break;
                        case JSDraw2.ALIGN.BOTTOM:
                            if (iso != null)
                                iso.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw / 2 + (noAdj ? 0 : 2)), -4)]);
                            if (h != null)
                                h.setTransform([dojox.gfx.matrix.translate(0, fontsize)]);
                            if (n != null)
                                n.setTransform([dojox.gfx.matrix.translate(hw / 2 + nw / 2 + (noAdj ? 0 : 2), fontsize + 4)]);
                            if (c != null)
                                c.setTransform([dojox.gfx.matrix.translate((h == null ? tw / 2 : hw / 2 + nw) + cw / 2 + (noAdj ? 0 : 4), (h == null ? 0 : fontsize) - 4)]);
                            x2 = (h == null ? tw / 2 : hw / 2 + nw) + cw + (noAdj ? 0 : 4);
                            break;
                        case JSDraw2.ALIGN.TOP:
                            if (iso != null)
                                iso.setTransform([dojox.gfx.matrix.translate(-(tw / 2 + iw / 2 + (noAdj ? 0 : 2)), -4)]);
                            if (h != null)
                                h.setTransform([dojox.gfx.matrix.translate(0, -fontsize)]);
                            if (n != null)
                                n.setTransform([dojox.gfx.matrix.translate(hw / 2 + nw / 2 + (noAdj ? 0 : 2), -fontsize + 4)]);
                            if (c != null)
                                c.setTransform([dojox.gfx.matrix.translate((h == null ? tw / 2 : hw / 2 + nw) + cw / 2 + (noAdj ? 0 : 4), (h == null ? 0 : -fontsize) - 4)]);
                            x2 = (h == null ? tw / 2 : hw / 2 + nw) + cw + (noAdj ? 0 : 4);
                            y2 = (h == null ? 0 : -fontsize) - 4;
                            break;
                    }
                }
                else {
                    x2 = tw / 2;
                }
            }

            if (a.atommapid != null) {
                var p = a.p.clone();
                var t = JSDraw2.Drawer.drawText(surface, p.offset(x2, y2 - fontsize - 2), "(" + a.atommapid + ")", "#f55", fontsize / 1.4);
                x2 += t.getTextWidth();
            }

            if (a.val > 0) {
                var p = a.p.clone();
                var t = JSDraw2.Drawer.drawText(surface, p.offset(x2, y2 - fontsize - 2), "(" + (a.val == 15 ? 0 : a.val) + ")", "#000", fontsize / 1.2);
                x2 += t.getTextWidth();
            }

            if (a.tag != null && a.tag != "") {
                var p = a.p.clone();
                var t = JSDraw2.Drawer.drawText(surface, p.offset(x2, y2 - fontsize - 2), "<" + a.tag + ">", "#000", fontsize / 1.2);
                x2 += t.getTextWidth();
            }
        }

        if (a.locked)
            surface.createCircle({ cx: a.p.x, cy: a.p.y, r: fontsize * 0.6 }).setStroke({ color: "#0ff", width: linewidth });
    },

    drawApo: function (a, m, surface, linewidth, fontsize, color) {
        var attachpoints = a.attachpoints;
        for (var i = 0; i < attachpoints.length; ++i) {
            var apo = attachpoints[i];

            var d = fontsize * 1.5;
            var p = m.guessBond(a, d, i);
            if (p == null) {
                p = a.p.clone();
                p.offset(d, 0);
            }

            var ap = a.p.clone();
            if (a._haslabel)
                ap.shrink(p, fontsize * 0.6);

            JSDraw2.Drawer.drawLine(surface, ap, p, color, linewidth / 2, apo == 99 ? 2 : 0);
            if (apo == 99 || apo == 98) { // Basis
                var v = new JSDraw2.Point(ap.x - p.x, ap.y - p.y).rotate(90).setLength(fontsize);
                var p1 = p.clone().offset(v.x, v.y);
                var p2 = p.clone().offset(-v.x, -v.y);

                if (apo == 99)
                    JSDraw2.Drawer.drawBasis(surface, p1, p2, color, linewidth / 2);
                else
                    JSDraw2.Drawer.drawCurves(surface, p1, p2, color, linewidth / 2);
            }
            else {
                this.drawDiamond(surface, p.x, p.y, fontsize * 0.3, color, linewidth / 3);
                JSDraw2.Drawer.drawText(surface, p.offset(-fontsize * 0.2, -fontsize * 0.6), apo + "", color, fontsize * 0.7);
            }
        }
    },

    drawSelect: function (lasso) {
        var c = this._rect == null ? this.p : this._rect.center();
        lasso.draw(this, c);
    }
});

JSDraw2.Atom.cast = function (a) {
    return a != null && a.T == 'ATOM' ? a : null;
};

scil.apply(JSDraw2.Atom, {
    match: function (x, y) {
        if (!scil.Utils.areListEq(x.attachpoints, y.attachpoints))
            return false;

        var e1 = x.elem;
        var e2 = y.elem;
        var f = JSDraw2.Atom.match2(e1, e2);
        if (f)
            return true;

        if (x.isotope != y.isotype || x.charge != y.charge)
            return false;

        if (x.bio != null || y.bio != null) {
            if (x.bio == null || y.bio == null)
                return false;
            return x.bio.type == y.bio.type && e1 == e2;
        }

        if (e1 != "L" && e2 != "L")
            return false;

        var list1 = [];
        var list2 = [];
        var t1 = true;
        var t2 = true;
        if (e1 == 'L') {
            if (x.query != null && x.query.als != null) {
                for (var i = 0; i < x.query.als.length; ++i)
                    list1.push(x.query.als[i]);
                if (x.query.t == false)
                    t1 = false;
            }
        }
        else {
            list.push(e1);
        }

        if (e2 == 'L') {
            if (y.query != null && y.query.als != null) {
                for (var i = 0; i < y.query.als.length; ++i)
                    list2.push(y.query.als[i]);
                if (y.query.t == false)
                    t2 = false;
            }
        }
        else {
            list2.push(e2);
        }

        for (var i = 0; i < list1.length; ++i) {
            for (var j = 0; j < list2.length; ++j) {
                f = JSDraw2.Atom.match(list1[i], list2[j]);
                if (f && t1 == t2)
                    return true;
            }
        }

        return t1 != t2;
    },

    match2: function (e1, e2) {
        return e1 == e2 || e1 == "*" || e1 == "A" || e2 == "*" || e2 == "A" ||
            e1 == "X" && (e2 == "F" || e2 == "Cl" || e2 == "Br" || e2 == "I") ||
            e2 == "X" && (e1 == "F" || e1 == "Cl" || e1 == "Br" || e1 == "I") ||
            e1 == "Q" && (e2 != "H" && e2 != "C") ||
            e2 == "Q" && (e1 != "H" && e1 != "C");
    },

    drawAlias: function (dir, surface, p, s, color, fontsize) {
        return JSDraw2.Drawer.drawFormula(surface, p, dir == JSDraw2.ALIGN.LEFT, s, color, fontsize);

        //        var t = null;
        //        if (dir == JSDraw2.ALIGN.LEFT)
        //            t = JSDraw2.Drawer.drawLabel(surface, p, s, color, fontsize, false, "end-anchor");
        //        else
        //            t = JSDraw2.Drawer.drawLabel(surface, p, s, color, fontsize, false, "start-anchor");

        //        return t._rect;
    },

    isValidChiral: function (c) {
        if (c == null)
            return false;
        return /^R|S|(abs)|(\&[0-9]+)|(and[0-9]+)|(or[0-9]+)$/.test(c);
    },

    isStereo: function (s) {
        return s != null && /^((abs)|(or[0-9]+)|(and[0-9]+))$/.test(s);
    }
});
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.BA = scilligence.extend(scilligence._base, {
    constructor: function (b, a, ri) {
        this.b = b;
        this.a = a;
        this.ringclosure = ri;
        this.next = [];
        this.f = null;
        this.parent = null;
        this.depth = null;
    },

    find: function (a) {
        var stack = new JSDraw2.Stack();
        stack.push(this);
        while (stack.length() > 0) {
            var ba = stack.pop();
            if (ba.a == a)
                return ba;

            for (var k = 0; k < ba.next.length; ++k)
                stack.push(ba.next[k]);
        }

        return null;
    },

    list: function (list, mode) {
        var stack = new JSDraw2.Stack();
        stack.push(this);
        var depthfirst = mode == "depthfirst";
        while (stack.length() > 0) {
            var ba = depthfirst ? stack.pop() : stack.popHead();
            list.push(ba);
            for (var k = 0; k < ba.next.length; ++k)
                stack.push(ba.next[k]);
        }
    },

    startAtom: function () {
        return this.b == null ? null : this.b.otherAtom(this.a);
    },

    addNext: function (ba) {
        this.next.push(ba);
        ba.parent = this;
        ba.depth = this.depth + 1;
    },

    stereo: function () {
        var bs = this.a.bonds;
        if (this.b == null || !this.a.isMarkedStereo())
            return null;


        // find out 2D layout
        var angles = [];
        var bonds = [];
        var a0 = this.a;
        var angle0 = this.b.otherAtom(a0).p.angleTo(a0.p);
        DEBUG.print(a0.elem);
        DEBUG.print(angle0);
        for (var i = 0; i < bs.length; ++i) {
            if (bs[i] == this.b)
                continue;

            var a1 = bs[i].otherAtom(a0);
            var ang = a1.p.angleTo(a0.p);
            var angle = ang - angle0;
            DEBUG.print(a1.elem + ", " + ang + ", " + angle);
            if (angle < 0)
                angle += 360;
            var p = angles.length;
            for (var k = 0; k < angles.length; ++k) {
                if (angle < angles[k]) {
                    p = k;
                    break;
                }
            }

            var next = null;
            for (var k = 0; k < this.next.length; ++k) {
                if (this.next[k].b == bs[i]) {
                    next = this.next[k];
                    break;
                }
            }
            if (next == null && this.a.ringclosures != null) {
                for (var k = 0; k < this.a.ringclosures.length; ++k) {
                    if (this.a.ringclosures[k].next.b == bs[i]) {
                        next = this.a.ringclosures[k].next;
                        this.a.ringclosures.splice(k, 1);
                        break;
                    }
                }
            }
            if (next == null)
                return null;

            angles.splice(p, 0, angle);
            bonds.splice(p, 0, next);
        }
        this.next = bonds;

        for (var i = 0; i < bonds.length; ++i)
            DEBUG.print(bonds[i].a.elem + ", " + angles[i]);

        var pattern = "";
        if (this.b.type == JSDraw2.BONDTYPES.WEDGE && this.b.a1 == this.a)
            pattern += "U";
        else if (this.b.type == JSDraw2.BONDTYPES.HASH && this.b.a1 == this.a)
            pattern += "D";
        else
            pattern += "-";

        for (var i = 0; i < bonds.length; ++i) {
            if (bonds[i].b.type == JSDraw2.BONDTYPES.WEDGE && bonds[i].b.a1 == this.a)
                pattern += "U";
            else if (bonds[i].b.type == JSDraw2.BONDTYPES.HASH && bonds[i].b.a1 == this.a)
                pattern += "D";
            else
                pattern += "-";
        }

        DEBUG.print(pattern);
        switch (pattern) {
            case "D--":
            case "DD-":
            case "DDD":
            case "--D":
            case "-D-":
            case "-DD":
            case "D---":
            case "-U--":
            case "--D-":
            case "---U":
            case "DU--":
            case "-DU-":
            case "--DU":
            case "U--D":
                return "@";
            case "U--":
            case "UU-":
            case "UUU":
            case "--U":
            case "-U-":
            case "-UU":
            case "U---":
            case "-D--":
            case "--U-":
            case "---D":
            case "UD--":
            case "-UD-":
            case "--UD":
            case "D--U":
                return "@@";
        }

        return null;
    },

    renderSmiles: function () {
        var s = "";
        if (this.b != null) {
            var ring = "";
            if (this.b.ring != null)
                ring = this.b.ring ? "@" : "!@";
            switch (this.b.type) {
                case JSDraw2.BONDTYPES.DOUBLE:
                    s += ring + "=";
                    break;
                case JSDraw2.BONDTYPES.TRIPLE:
                    s += ring + "#";
                    break;
                case JSDraw2.BONDTYPES.SINGLEORDOUBLE:
                    s += ring + "-," + ring + "=";
                    break;
                case JSDraw2.BONDTYPES.SINGLEORAROMATIC:
                    s += ring + "-," + ring + ":";
                    break;
                case JSDraw2.BONDTYPES.DOUBLEORAROMATIC:
                    s += ring + "=," + ring + ":";
                    break;
                case JSDraw2.BONDTYPES.UNKNOWN:
                    s += ring + "~";
                    break;
                case JSDraw2.BONDTYPES.DUMMY:
                    s += ring + "..";
                    break;
                default:
                    if (this.b.ring != null)
                        s += ring + "-";
                    break;
            }
        }

        if (this.ringclosure == null) {
            var stereo = this.stereo();
            // B, C, N, O, P, S, F, Cl, Br, and I
            var ar = JSDraw2.PT.isArAtom(this.a.elem);
            if (this.a.elem == "5'" || this.a.elem == "3'") {
                // do nothing
            }
            else if (this.a.bio) {
                s += "[[" + this.a.elem + "]]";
            }
            else if ((ar || this.a.elem == 'Cl' || this.a.elem == 'F' || this.a.elem == 'Br' || this.a.elem == 'I' || this.a.elem == 'B') &&
                this.a.charge == 0 && this.a.isotope == null && stereo == null && this.a.query == null && !this.a.locked) {
                if (this.a.aromatic && ar)
                    s += this.a.elem.toLowerCase();
                else
                    s += this.a.elem;
            }
            else {
                s += "[";
                if (this.a.query != null && this.a.query.als != null) {
                    for (var k = 0; k < this.a.query.als.length; ++k) {
                        if (k > 0)
                            s += ",";
                        if (this.a.query.t == false)
                            s += "!";
                        s += this.a.query.als[k];
                    }
                }
                else {
                    if (this.a.isotope != null)
                        s += this.a.isotope;
                    s += this.a.elem;
                }

                if (this.a.charge != 0) {
                    if (this.a.hcount > 1)
                        s += "H" + this.a.hcount;

                    if (this.a.charge == 1)
                        s += '+';
                    else if (this.a.charge == -1)
                        s += '-';
                    else
                        s += (this.a.charge > 0 ? "+" : "-") + Math.abs(this.a.charge);
                }

                if (stereo != null)
                    s += stereo + (this.a.hcount == 1 ? "H" : "");

                if (this.a.query != null && this.a.query.rbc != null)
                    s += ";R" + this.a.query.rbc;
                if (this.a.query != null && this.a.query.sub != null)
                    s += ";X" + this.a.query.sub;
                if (this.a.locked)
                    s += ";0";
                s += "]";
            }

            if (this.a.ringclosures != null) {
                var list = this.a.ringclosures;
                for (var k = 0; k < list.length; ++k)
                    s += (list[k].ri < 10 ? "" : "%") + list[k].ri;
            }
        }
        else {
            s += (this.ringclosure < 10 ? "" : "%") + this.ringclosure;
        }

        if (this.next.length > 0) {
            for (var i = 0; i < this.next.length - 1; ++i) {
                var child = this.next[i].renderSmiles();
                if (child == null || child.length == 0)
                    continue;
                if (/^[0-9|\=|\#]+$/.test(child))
                    s += child;
                else
                    s += "(" + child + ")";
            }
            s += this.next[this.next.length - 1].renderSmiles();
        }

        return s;
    }
});
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////



/**
* Base64 class provide base64 encode/decode functions
* @class {static} scilligence.JSDraw2.Base64
*/
JSDraw2.Base64 = {
    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    /**
    * Base64 encode a string
    * @function {static} encode
    * @param {string} input input string
    * @returns encoded string
    */
    encode: function (input) {
        if (input == null)
            return null;

        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        input = JSDraw2.Base64._utf8_encode(input);

        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
        }
        return output;
    },

    /**
    * Base64 decode a string
    * @function {static} decode
    * @param {string} input input string
    * @returns decoded string
    */
    decode: function (input) {
        if (input == null)
            return null;

        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }

        }
        output = JSDraw2.Base64._utf8_decode(output);
        return output;
    },

    // private method for UTF-8 encoding
    _utf8_encode: function (string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode: function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;

        while (i < utftext.length) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if ((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }
        return string;
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Bond class
* @class scilligence.JSDraw2.Bond
*/
JSDraw2.Bond = scilligence.extend(scilligence._base, {
    /**
    @property {Atom} a1 The First Atom
    */
    /**
    @property {Atom} a2 The Second Atom
    */
    /**
    @property {BONDTYPES} type Bond Type
    */
    /**
    @property {string} color Display Color
    */
    /**
    @property {bool} selected Selecting Flag
    */

    /**
    * @constructor Bond
    * @param {Atom} a1 - the first atom
    * @param {Atom} a2 - the second atom
    * @param {BONDTYPES} type - bond type
    */
    constructor: function (a1, a2, type) {
        this.T = "BOND";
        this.a1 = a1;
        this.a2 = a2;
        this.apo1 = null;
        this.apo2 = null;
        this.color = null;
        this.ring = null;
        this.order = null;
        this.rcenter = null;
        this.selected = false;
        this.tag = null;
        this.f = null;
        this.r1 = null;
        this.r2 = null;
        this.ratio1 = null;
        this.ratio2 = null;
        this.type = type == null ? JSDraw2.BONDTYPES.SINGLE : type;
    },

    clone: function () {
        var b = new JSDraw2.Bond(this.a1, this.a2, this.type);
        b.id = this.id;
        b.color = this.color;
        b.order = this.order;
        b.apo1 = this.apo1;
        b.apo2 = this.apo2;
        b.ring = this.ring;
        b.rcenter = this.rcenter;
        b._parent = this.parent;
        b.r1 = this.r1;
        b.r2 = this.r2;
        b.ratio1 = this.ratio1;
        b.ratio2 = this.ratio2;
        b.z = this.z;
        b.tag = this.tag;
        b.selected = this.selected;
        return b;
    },

    replaceAtom: function (old, na) {
        if (this.a1 == old)
            this.a1 = na;
        else if (this.a2 == old)
            this.a2 = na;
        else
            return false;
        return true;
    },

    isBio: function () {
        return this.type == JSDraw2.BONDTYPES.PEPTIDE || this.type == JSDraw2.BONDTYPES.NUCLEOTIDE;
    },

    bondLength: function () {
        return this.a1.p.distTo(this.a2.p);
    },

    center: function () {
        return new JSDraw2.Point((this.a1.p.x + this.a2.p.x) / 2, (this.a1.p.y + this.a2.p.y) / 2);
    },

    angle: function () {
        return this.vector().angle();
    },

    vector: function () {
        return new JSDraw2.Point(this.a2.p.x - this.a1.p.x, this.a2.p.y - this.a1.p.y);
    },

    /**
    * Get the other Atom of the Bond
    * @function otherAtom
    * @param {Atom} a - one atom on the bond
    * @returns the other Atom
    */
    otherAtom: function (a) {
        if (this.a1 == a)
            return this.a2;
        else if (this.a2 == a)
            return this.a1;
        return null;
    },

    /**
    * Switch the atoms' order
    * @function reverse
    * @returns null
    */
    reverse: function () {
        var a = this.a1;
        this.a1 = this.a2;
        this.a2 = a;

        var apo = this.apo1;
        this.apo1 = this.apo2;
        this.apo2 = apo;
    },

    valence: function () {
        switch (this.type) {
            case JSDraw2.BONDTYPES.SINGLE:
            case JSDraw2.BONDTYPES.WEDGE:
            case JSDraw2.BONDTYPES.HASH:
            case JSDraw2.BONDTYPES.WIGGLY:
            case JSDraw2.BONDTYPES.PEPTIDE:
            case JSDraw2.BONDTYPES.NUCLEOTIDE:
            case JSDraw2.BONDTYPES.DISULFIDE:
            case JSDraw2.BONDTYPES.AMIDE:
            case JSDraw2.BONDTYPES.BOLD:
            case JSDraw2.BONDTYPES.BOLDHASH:
                return 1;
            case JSDraw2.BONDTYPES.DELOCALIZED:
                return 1.5;
            case JSDraw2.BONDTYPES.DOUBLE:
            case JSDraw2.BONDTYPES.EITHER:
                return 2;
            case JSDraw2.BONDTYPES.TRIPLE:
                return 3;
            case JSDraw2.BONDTYPES.UNKNOWN:
            case JSDraw2.BONDTYPES.DUMMY:
                return 0;
            default:
                return null;
        }
    },

    _centerDoubleBond: function (m, b) {
        var atoms1 = m.getNeighborAtoms(b.a1, b.a2);
        var atoms2 = m.getNeighborAtoms(b.a2, b.a1);
        return atoms1.length == 0 && atoms2.length == 2 || atoms2.length == 0 && atoms1.length == 2;
    },

    _shirftDirection: function (m, b) {
        var a1 = null;
        var a2 = null;
        var atoms1 = m.getNeighborAtoms(b.a1, b.a2, true);
        if (atoms1.length == 1)
            a1 = atoms1[0];

        if (a1 == null) {
            var atoms2 = m.getNeighborAtoms(b.a2, b.a1, true);
            if (atoms2.length == 1)
                a2 = atoms2[0];

            if (a2 == null) {
                if (atoms1.length >= 2 && atoms2.length >= 2) {
                    if (m._hasDoubleBonds(atoms1[0]))
                        a1 = atoms1[0];
                    else if (m._hasDoubleBonds(atoms1[1]))
                        a1 = atoms1[1];

                    if (m._hasDoubleBonds(atoms2[0]))
                        a2 = atoms2[0];
                    else if (m._hasDoubleBonds(atoms2[1]))
                        a2 = atoms2[1];
                }
            }
        }

        if (a1 != null) {
            var ang = b.p1.angleAsOrigin(b.p2, a1.p);
            return ang <= 180;
        }

        if (a2 != null) {
            var ang = b.p2.angleAsOrigin(a2.p, b.p1);
            return ang <= 180;
        }
    },

    html: function () {
        var s = "<b i='" + this.id + "' a1='" + this.a1.id + "' a2='" + this.a2.id + "' t='" + this.type + "'";
        if (this.ring != null)
            s += " ring='" + (this.ring ? 1 : 0) + "'";
        if (this.rcenter != null)
            s += " rcenter='" + this.rcenter + "'";
        if (this.color != null)
            s += " clr='" + this.color + "'";
        if (!scil.Utils.isNullOrEmpty(this.r1))
            s += " r1='" + this.r1 + "'";
        if (!scil.Utils.isNullOrEmpty(this.r2))
            s += " r2='" + this.r2 + "'";
        if (this.apo1 > 0 && this.a1.superatom != null)
            s += " apo1='" + this.apo1 + "'";
        if (this.apo2 > 0 && this.a2.superatom != null)
            s += " apo2='" + this.apo2 + "'";
        if (this.tag != null)
            s += " tag='" + scil.Utils.escXmlValue(this.tag) + "'";
        s += "/>";
        return s;
    },

    readHtml: function (e) {
        var r = e.getAttribute("clr");
        if (r != null)
            this.color = r;

        var tag = e.getAttribute("tag");
        if (tag != null && tag != "")
            this.tag = tag;
    },

    toggle: function (p, tor) {
        return p.onLine(this.a1.p, this.a2.p, tor / 5);
    },

    drawCur: function (surface, r, color) {
        var p = this.center();
        surface.createCircle({ cx: p.x, cy: p.y, r: r }).setFill(color);
    },

    _drawBond: function (surface, b, color, linewidth, shrink, shift, dotline, gap, cap) {
        if (shrink == null || shrink == 0) {
            JSDraw2.Drawer.drawLine(surface, b.p1, b.p2, color, linewidth, dotline, cap);
        }
        else {
            var d = shift == 0 ? new JSDraw2.Point(0, 0) : b.vector().scale(1.0 / Math.abs(shift));
            var v = b.vector().rotate(shrink > 0 ? 90 : -90).setLength(gap == null ? linewidth * 2 : gap);
            JSDraw2.Drawer.drawLine(surface, b.p1.clone().offset(d.x + v.x, d.y + v.y), b.p2.clone().offset(-d.x + v.x, -d.y + v.y), color, linewidth, dotline, cap);
        }
    },

    getRColor: function (c, r) {
        if (!scil.Utils.isNullOrEmpty(this.color))
            return c;
        switch (r) {
            case 1:
                return "#641E16";
            case 2:
                return "#0000ff";
            case 3:
                return "#aaaaaa";
        }
        return "black";
    },

    splitPosR: function (s) {
        if (!scil.Utils.isNullOrEmpty(s)) {
            var s2 = s == "?" ? "?:?" : s + "";
            var p = s2.indexOf(':');
            if (p >= 0) {
                var pos = s2.substr(0, p);
                var r = s2.substr(p + 1);
                return { pos: (pos == "" ? "?" : pos), r: (r == "" ? "?" : r) };
            }
        }

        return { pos: "?", r: "?" };
    },

    _fmtBondAnn: function () {
        var s1 = "";
        var s2 = "";

        var r1 = this.splitPosR(this.r1);
        var r2 = this.splitPosR(this.r2);
        if (r1.pos != "?" || r2.pos != "?") {
            s1 += (s1 == "" ? "" : "; ") + "Pos: " + r1.pos;
            s2 += (s2 == "" ? "" : "; ") + "Pos: " + r2.pos;
        }
        if (r1.r != "?" || r2.r != "?") {
            s1 += (s1 == "" ? "" : "; ") + "R#: " + r1.r;
            s2 += (s2 == "" ? "" : "; ") + "R#: " + r2.r;
        }

        var defaultratio = org.helm.webeditor.defaultbondratio == null ? "" : org.helm.webeditor.defaultbondratio;
        var ratio1 = scil.Utils.isNullOrEmpty(this.ratio1) ? defaultratio : this.ratio1;
        var ratio2 = scil.Utils.isNullOrEmpty(this.ratio2) ? defaultratio : this.ratio2;
        if (ratio1 != defaultratio || ratio2 != defaultratio /* https://github.com/PistoiaHELM/HELMWebEditor/issues/148 */) {
            s1 += (s1 == "" ? "" : "; ") + "Ratio: " + ratio1;
            s2 += (s2 == "" ? "" : "; ") + "Ratio: " + ratio2;
        }

        return { ba1: s1, ba2: s2 };
    },

    drawBondAnnotation: function (surface, fontsize, b) {
        var s = this._fmtBondAnn();
        var ba1 = s.ba1;
        var ba2 = s.ba2;
        if (ba1 == "" && ba2 == "")
            return;

        var dx = (b.p1.x - b.p2.x) / 90;
        var dy = (b.p1.y - b.p2.y) / 90;
        var c1 = new JSDraw2.Point((b.p1.x + b.p2.x) / 2, (b.p1.y + b.p2.y) / 2);
        var c2 = c1.clone();

        if (Math.abs(b.a1.p.x - b.a2.p.x) < fontsize) {
            //vertical
            c1.offset(fontsize * dx + fontsize * 0.2, fontsize * dy - fontsize * 0.5);
            c2.offset(-fontsize * dx + fontsize * 0.2, -fontsize * dy - fontsize * 0.5);
            if (!scil.Utils.isNullOrEmpty(ba1))
                JSDraw2.Drawer.drawText(surface, c1, ba1, "green", fontsize);
            if (!scil.Utils.isNullOrEmpty(ba2))
                JSDraw2.Drawer.drawText(surface, c2, ba2, "green", fontsize);
        }
        else if (Math.abs(b.a1.p.y - b.a2.p.y) < fontsize) {
            //horizontal
            c1.offset(fontsize * dx, fontsize * dy - fontsize * 0.9);
            c2.offset(-fontsize * dx, -fontsize * dy + fontsize * 0.6);
            if (!scil.Utils.isNullOrEmpty(ba1))
                JSDraw2.Drawer.drawLabel(surface, c1, ba1, "green", fontsize, null, null, null, false);
            if (!scil.Utils.isNullOrEmpty(ba2))
                JSDraw2.Drawer.drawLabel(surface, c2, ba2, "green", fontsize, null, null, null, false);
        }
        else {
            c1.offset(fontsize * dx, fontsize * dy);
            c2.offset(-fontsize * dx, -fontsize * dy);
            if (!scil.Utils.isNullOrEmpty(ba1))
                JSDraw2.Drawer.drawLabel(surface, c1, ba1, "green", fontsize, null, null, null, false);
            if (!scil.Utils.isNullOrEmpty(ba2))
                JSDraw2.Drawer.drawLabel(surface, c2, ba2, "green", fontsize, null, null, null, false);
        }
    },

    draw: function (surface, linewidth, m, fontsize, simpledraw) {
        if (this.type == JSDraw2.BONDTYPES.DUMMY) {
            if ((this.a1.elem == "@" || this.a2.elem == "@") && !this.a1.p.equalsTo(this.a2.p))
                JSDraw2.Drawer.drawLine(surface, this.a1.p, this.a2.p, "#eee", linewidth / 2);
            return;
        }

        if (this.a1.p.equalsTo(this.a2.p))
            return;

        var b = new JSDraw2.Bond.B(this);
        if (!simpledraw) {
            if (b.a1._haslabel)
                b.p1.shrink(b.p2, fontsize * 0.6);
            if (b.a2._haslabel)
                b.p2.shrink(b.p1, fontsize * 0.6);
        }

        var color = scil.Utils.isNullOrEmpty(this.color) ? "black" : this.color;
        if (simpledraw || b.type == JSDraw2.BONDTYPES.PEPTIDE || b.type == JSDraw2.BONDTYPES.AMIDE) {
            JSDraw2.Drawer.drawLine(surface, b.p1, b.p2, color, linewidth);
            return;
        }
        else if (b.type == JSDraw2.BONDTYPES.DISULFIDE) {
            JSDraw2.Drawer.drawLine(surface, b.p1, b.p2, color, linewidth);
            return;
        }
        else if (b.type == JSDraw2.BONDTYPES.NUCLEOTIDE) {
            JSDraw2.Drawer.drawLine(surface, b.p1, b.p2, color, linewidth);
            return;
        }

        if (this.r1 > 0 || this.r2 > 0) {
            var c = new JSDraw2.Point((b.p1.x + b.p2.x) / 2, (b.p1.y + b.p2.y) / 2);
            var color1 = this.getRColor(this.color, this.r1);
            var color2 = this.getRColor(this.color, this.r2);
            if (this.z) {
                var p1 = new JSDraw2.Point(b.p1.x, c.y);
                var p2 = new JSDraw2.Point(b.p2.x, c.y);
                JSDraw2.Drawer.drawLine(surface, b.p1, p1, color1, linewidth, null, "butt");
                JSDraw2.Drawer.drawLine(surface, p1, c, color1, linewidth, null, "butt");
                JSDraw2.Drawer.drawLine(surface, c, p2, color2, linewidth, null, "butt");
                JSDraw2.Drawer.drawLine(surface, p2, b.p2, color2, linewidth, null, "butt");
            }
            else {
                JSDraw2.Drawer.drawLine(surface, b.p1, c, color1, linewidth, null, "butt");
                JSDraw2.Drawer.drawLine(surface, c, b.p2, color2, linewidth, null, "butt");
                if (this.r1 == 1 && this.r2 == 2 || this.r1 == 2 && this.r2 == 1) {
                    JSDraw2.Bond.showHelmAnnotation(this.a1, this.a2, this.r1);
                    JSDraw2.Bond.showHelmAnnotation(this.a2, this.a1, this.r2);
                }
            }
            return;
        }

        if (!simpledraw)
            this.drawBondAnnotation(surface, fontsize, b);

        var dir = 8;
        if (b.type == JSDraw2.BONDTYPES.DOUBLE || b.type == JSDraw2.BONDTYPES.DELOCALIZED || b.type == JSDraw2.BONDTYPES.EITHER || b.type == JSDraw2.BONDTYPES.DOUBLEORAROMATIC)
            dir = this._shirftDirection(m, b) ? 8 : -8;

        if (b.type == JSDraw2.BONDTYPES.DOUBLE && this._centerDoubleBond(m, b)) {
            this._drawBond(surface, b, color, linewidth, -dir, 0, null, linewidth);
            this._drawBond(surface, b, color, linewidth, dir, 0, null, linewidth);
        }
        else if (b.type == JSDraw2.BONDTYPES.SINGLE || b.type == JSDraw2.BONDTYPES.BOLD || b.type == JSDraw2.BONDTYPES.DOUBLE || b.type == JSDraw2.BONDTYPES.TRIPLE || b.type == JSDraw2.BONDTYPES.DELOCALIZED) {
            this._drawBond(surface, b, color, b.type == JSDraw2.BONDTYPES.BOLD ? 3 * linewidth : linewidth, null, null, null, null, b.type == JSDraw2.BONDTYPES.BOLD ? "butt" : "round");

            if (b.type == JSDraw2.BONDTYPES.DOUBLE || b.type == JSDraw2.BONDTYPES.TRIPLE)
                this._drawBond(surface, b, color, linewidth, dir, dir);

            if (b.type == JSDraw2.BONDTYPES.TRIPLE)
                this._drawBond(surface, b, color, linewidth, -dir, -dir);

            if (b.type == JSDraw2.BONDTYPES.DELOCALIZED)
                this._drawBond(surface, b, color, linewidth, dir, dir, 4);
        }

        if (b.type == JSDraw2.BONDTYPES.WEDGE) {
            var v = b.vector().rotate(90).setLength(linewidth * 2);
            surface.createPolyline([
                    b.p1.x, b.p1.y,
                    b.p2.x + v.x, b.p2.y + v.y,
                    b.p2.x - v.x, b.p2.y - v.y
                ])
                .setStroke({ width: 2 })
                .setFill(color);
        }

        if (b.type == JSDraw2.BONDTYPES.HASH || b.type == JSDraw2.BONDTYPES.BOLDHASH) {
            var len = b.bondLength();
            var n = Math.floor(len / (linewidth * 2));
            var d = b.vector().scale(1.0 / n);
            var v = b.vector().rotate(90);
            for (var k = 1; k <= n; ++k) {
                var p = b.p1.clone().offset(d.x * k, d.y * k);
                var vlen = linewidth * 2;
                if (b.type == JSDraw2.BONDTYPES.HASH)
                    vlen *= k / n;
                else
                    vlen *= 0.6;
                var vi = v.clone().setLength(vlen);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(vi.x, vi.y), p.clone().offset(-vi.x, -vi.y), color, linewidth);
            }
        }

        if (b.type == JSDraw2.BONDTYPES.WIGGLY)
            JSDraw2.Drawer.drawCurves(surface, b.p1, b.p2, color, linewidth);

        if (b.type == JSDraw2.BONDTYPES.EITHER) {
            var d = b.vector().scale(1.0 / Math.abs(dir));
            var v = b.vector().rotate(dir > 0 ? 90 : -90).setLength(linewidth * 2);
            var p1 = b.p1.clone().offset(d.x + v.x, d.y + v.y);
            var p2 = b.p2.clone().offset(-d.x + v.x, -d.y + v.y);
            JSDraw2.Drawer.drawLine(surface, b.p1, p2, color, linewidth);
            JSDraw2.Drawer.drawLine(surface, b.p2, p1, color, linewidth);
        }

        if (b.type == JSDraw2.BONDTYPES.DOUBLEORAROMATIC) {
            this._drawBond(surface, b, color, linewidth);
            this._drawBond(surface, b, color, linewidth, dir, dir, 2);
        }

        if (b.type == JSDraw2.BONDTYPES.SINGLEORDOUBLE || b.type == JSDraw2.BONDTYPES.SINGLEORAROMATIC) {
            this._drawBond(surface, b, color, linewidth, 0, 0, 2);

            this._drawBond(surface, b, color, linewidth, dir / 2, dir / 2, null, linewidth * 1.5);
            this._drawBond(surface, b, color, linewidth, -dir / 2, -dir / 2, b.type == JSDraw2.BONDTYPES.SINGLEORAROMATIC ? 2 : null, linewidth * 1.5);
        }

        if (b.type == JSDraw2.BONDTYPES.UNKNOWN)
            this._drawBond(surface, b, color, linewidth, null, null, linewidth * 1.2);

        if (b.b.ring != null) {
            var p = this.center();
            surface.createCircle({ cx: p.x, cy: p.y, r: linewidth * 3 })
                .setStroke({ color: color, width: linewidth / 2, style: b.b.ring ? "Solid" : "Dash" });
        }

        if (b.b.rcenter != null) {
            var p = this.center();
            var d = b.vector().rotate(90).setLength(linewidth * 3);
            var v = b.vector().setLength(linewidth * (b.b.rcenter == JSDraw2.RXNCENTER.BREAKANDCHANGE ? 1.5 : 1));
            if (b.b.rcenter == JSDraw2.RXNCENTER.CENTER) {
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x + v.x, d.y + v.y), p.clone().offset(-d.x + v.x, -d.y + v.y), color, linewidth / 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x - v.x, d.y - v.y), p.clone().offset(-d.x - v.x, -d.y - v.y), color, linewidth / 2);
                d = b.vector().rotate(90).setLength(linewidth * 1.6);
                v = b.vector().setLength(linewidth * 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x + v.x, d.y + v.y), p.clone().offset(d.x - v.x, d.y - v.y), color, linewidth / 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(-d.x + v.x, -d.y + v.y), p.clone().offset(-d.x - v.x, -d.y - v.y), color, linewidth / 2);
            }
            else if (b.b.rcenter == JSDraw2.RXNCENTER.NOTCENTER) {
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x + v.x, d.y + v.y), p.clone().offset(-d.x - v.x, -d.y - v.y), color, linewidth / 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x - v.x, d.y - v.y), p.clone().offset(-d.x + v.x, -d.y + v.y), color, linewidth / 2);
            }
            else if (b.b.rcenter == JSDraw2.RXNCENTER.BREAK) {
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x + v.x, d.y + v.y), p.clone().offset(-d.x + v.x, -d.y + v.y), color, linewidth / 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x - v.x, d.y - v.y), p.clone().offset(-d.x - v.x, -d.y - v.y), color, linewidth / 2);
            }
            else if (b.b.rcenter == JSDraw2.RXNCENTER.CHANGE) {
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x, d.y), p.clone().offset(-d.x, -d.y), color, linewidth / 2);
            }
            else if (b.b.rcenter == JSDraw2.RXNCENTER.BREAKANDCHANGE) {
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x, d.y), p.clone().offset(-d.x, -d.y), color, linewidth / 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x + v.x, d.y + v.y), p.clone().offset(-d.x + v.x, -d.y + v.y), color, linewidth / 2);
                JSDraw2.Drawer.drawLine(surface, p.clone().offset(d.x - v.x, d.y - v.y), p.clone().offset(-d.x - v.x, -d.y - v.y), color, linewidth / 2);
            }
        }
    },

    drawSelect: function (lasso) {
        lasso.draw(this, this.center());
    }
});


scil.apply(JSDraw2.Bond, {
    cast: function (a) {
        return a != null && a.T == 'BOND' ? a : null;
    },

    B: scilligence.extend(scilligence._base, {
        constructor: function (b) {
            this.b = b;
            this.a1 = b.a1;
            this.a2 = b.a2;
            this.type = b.type;
            this.p1 = b.a1.p.clone();
            this.p2 = b.a2.p.clone()
        },

        vector: function () {
            return new JSDraw2.Point(this.p2.x - this.p1.x, this.p2.y - this.p1.y);
        },

        bondLength: function () {
            return this.p1.distTo(this.p2);
        }
    }),

    showHelmAnnotation: function (a1, a2, r1) {
        if (a1.bio == null || scil.Utils.isNullOrEmpty(a1.bio.annotation))
            return;

        if (r1 == 2 && a1.p.x > a2.p.x || r1 == 1 && a1.p.x < a2.p.x)
            a1.bio.annotationshowright = true;
        else
            a1.bio.annotationshowright = null;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.JSDrawIO = {
    downloaddlg: null,
    jsdsavedlg: null,
    jsdFiles: { jsdraw: "JSDraw2 XML", mol: "Mol File", rxn: "Reaction File", inchi: "InChI", helm: "HELM", xhelm: "xHELM", smiles: "SMILES", cml: "Chemical Markup Language", cdxml: "ChemDraw CDXML", cdx: "ChemDraw CDX", png: "PNG Picture" },
    jsdFiles2: { jsd: "JSDraw XML", png: "PNG Picture" },
    jsdFiles3: { helm: "HELM", xhelm: "xHELM" },
    jsssavedlg: null,
    jssFiles: { sdf: "SDF File", csv: "CSV File", xlsx: "Excel File", jssdf: "Xml File", json: "Json File" },

    callWebservice: function (cmd, data, callback) {
        if (JSDrawServices.url == null || JSDrawServices.url == "")
            scil.Utils.alert("JSDraw web service is not available");
        else
            scil.Utils.ajax(JSDrawServices.url + "?cmd=" + cmd, callback, data);
    },

    needCrossdomain: function () {
        if (JSDrawServices.xdomain) {
            var s = window.location + "";
            var p = s.indexOf("://");
            var p2 = s.indexOf("/", p + 3);
            var host = s.substr(0, p2 + 1);
            if (!scil.Utils.startswith(JSDrawServices.url.toLowerCase(), host.toLowerCase()))
                return true;
        }
        return false;
    },

    jsdFileOpen: function (jsd) {
        var msg;
        if (JSDraw2.Security.kEdition == "Lite")
            msg = this.res("Please select a HELM file") + " (*.helm, *.xhelm):";
        else
            msg = this.res("Please select a chemistry file") + " (*.mol, *.rxn, *.cdx, *.skc, *.helm, *.xhelm, *.smiles etc.):";

        if (this.needCrossdomain()) {
            var url = JSDrawServices.url + "?cmd=";
            scil.Utils.uploadFile("<img src='" + scil.App.imgSmall("open.png") + "'>" + this.res("Import File"),
                msg, url + "xdomain.post", function (xfilename) {
                    scil.Utils.jsonp(url + "openjsd", function (ret) { JSDraw2.JSDrawIO.jsdFileOpen2(jsd, ret); },
                    { _xfilename: xfilename });
                }, null, null, null, null, true);
        }
        else {
            if (this.jsdFileOpenDlg == null) {
                var fields = {
                    note: { type: "html", template: "<div style='white-space:nowrap'>" + msg + "</div>" },
                    file: { type: "postfile", attributes: { name: "file"} },
                    importas: JSDraw2.Security.kEdition == "Lite" ? null : { type: "select", items: { "": "", "reactant": "Import as Reactant", "product": "Import as Product"} }
                };
                var me = this;
                this.jsdFileOpenDlg = scil.Form.createDlgForm("Load File", fields,
                    { src: scil.App.imgSmall("open.png"), label: "Load File", onclick: function () { me.jsdFileOpen1(); } },
                    { usepostform: true, hidelabel: true });
            }

            this.jsdFileOpenDlg.show();
            this.jsdFileOpenDlg.jsd = jsd;
            this.jsdFileOpenDlg.form.postform.reset();
            /*
            scil.Utils.uploadFile("<img src='" + scil.Utils.imgSrc("img/open.gif") + "'>" + this.res("Import File"),
            this.res("Please select a chemistry file") + " (*.mol, *.rxn, *.cdx, *.skc, *.smiles etc.):",
            JSDrawServices.url + "?cmd=openjsd",
            function (ret) { JSDraw2.JSDrawIO.jsdFileOpen2(jsd, ret); });
            */
        }
    },

    jsdFileOpen1: function () {
        var me = this;
        this.jsdFileOpenDlg.form.post(JSDrawServices.url + "?cmd=openjsd", null, function (ret) {
            var importas = me.jsdFileOpenDlg.form.fields.importas == null ? null : me.jsdFileOpenDlg.form.fields.importas.value;
            me.jsdFileOpen2(me.jsdFileOpenDlg.jsd, ret, importas);
            me.jsdFileOpenDlg.hide();
        });
    },

    jsdFileOpen2: function (jsd, ret, importas) {
        var data = ret.base64 != null ? JSDraw2.Base64.decode(ret.base64) : ret.contents;
        if (importas == "reactant" || importas == "product") {
            var m = new JSDraw2.Mol();
            if (ret.format == "molfile")
                m.setMolfile(data);
            else if (ret.format == "rxn")
                m.setRxnfile(data);
            else
                m.setXml(data);

            if (m.atoms.length > 0) {
                var rxn = m.parseRxn(true);
                var f = false;
                if (rxn == null) {
                    if (jsd.pasteMol(m, null, importas))
                        f = true;
                }
                else if (rxn.arrow == null && rxn.products.length == 0) {
                    for (var i = 0; i < rxn.reactants.length; ++i)
                        if (jsd.pasteMol(rxn.reactants[i], null, importas))
                            f = true;
                }
                else {
                    if (importas == "reactant" && rxn.reactants != null) {
                        for (var i = 0; i < rxn.reactants.length; ++i)
                            if (jsd.pasteMol(rxn.reactants[i], null, importas))
                                f = true;
                    }
                    else if (importas == "product" && rxn.products != null) {
                        for (var i = 0; i < rxn.products.length; ++i)
                            if (jsd.pasteMol(rxn.products[i], null, importas))
                                f = true;
                    }
                }

                if (f)
                    jsd.refresh(true);
                else
                    scil.Utils.alert("No structure imported");
            }
        }
        else {
            if (ret.format == "molfile" || scil.Utils.endswith(ret.filename, ".mol"))
                jsd.setMolfile(data);
            else if (ret.format == "rxn" || scil.Utils.endswith(ret.filename, ".rxn"))
                jsd.setRxnfile(data);
            else if (ret.format == "xhelm" || scil.Utils.endswith(ret.filename, ".xhelm"))
                jsd.setXHelm(data);
            else if (ret.format == "helm" || scil.Utils.endswith(ret.filename, ".helm"))
                jsd.setHelm(data);
            else
                jsd.setXml(data);
        }
    },

    jsdFileSave: function (jsd) {
        if (JSDraw2.JSDrawIO.jsdsavedlg == null) {
            var div = scil.Utils.createElement(null, "div", this.res("Please select the file format to be saved: "), { width: "420px", margin: "10px" });
            var sel = scil.Utils.createElement(div, "select");
            scil.Utils.createElement(sel, "option");
            if (JSDraw2.Security.kEdition == "Lite") {
                if (jsd.options.toolbarmode == "helm")
                    scil.Utils.listOptions(sel, JSDraw2.JSDrawIO.jsdFiles3, null, false);
                else
                    scil.Utils.listOptions(sel, JSDraw2.JSDrawIO.jsdFiles, null, false);
            }
            else if (jsd.options.toolbarmode == "tlc")
                scil.Utils.listOptions(sel, JSDraw2.JSDrawIO.jsdFiles2, null, false);
            else
                scil.Utils.listOptions(sel, JSDraw2.JSDrawIO.jsdFiles, null, false);

            var s = scil.Utils.createElement(div, "div", null, { marginTop: "20px", textAlign: "center" });
            scil.Utils.createButton(s, { src: scil.App.imgSmall("submit.png"), label: "Save File", onclick: function (e) { JSDraw2.JSDrawIO.jsdFileSave2(); e.preventDefault(); } });
            scil.Utils.createButton(s, "&nbsp;");
            scil.Utils.createButton(s, { src: scil.App.imgSmall("cancel.png"), label: "Cancel", onclick: function (e) { JSDraw2.JSDrawIO.jsdsavedlg.hide(); e.preventDefault(); } });

            JSDraw2.JSDrawIO.jsdsavedlg = new JSDraw2.Dialog("<img src='" + scil.App.imgSmall("save.png") + "'>" + this.res("Save File"), div);
            JSDraw2.JSDrawIO.jsdsavedlg.sel = sel;
        }
        JSDraw2.JSDrawIO.jsdsavedlg.jsd = jsd;
        JSDraw2.JSDrawIO.jsdsavedlg.show();
        JSDraw2.JSDrawIO.jsdsavedlg.sel.selectedIndex = 0;
    },

    jsdFileSave2: function () {
        this.jsdFileSave3(JSDraw2.JSDrawIO.jsdsavedlg.sel.value, JSDraw2.JSDrawIO.jsdsavedlg.jsd);
        this.jsdsavedlg.hide();
    },

    jsdFileSave3: function (ext, jsd) {
        var s;
        if (ext == "helm")
            s = jsd.getHelm();
        else if (ext == "xhelm")
            s = jsd.getXHelm();
        else
            s = jsd.getXml();

        var dt = new Date();
        var prefix = JSDraw2.Security.kEdition == "Lite" && jsd.options.toolbarmode == "helm" ? "HELM" : "JSDraw";
        var filename = prefix + dt.getFullYear() + "-" + (dt.getMonth() + 1) + "-" + dt.getDate() + "." + ext;
        var args = { client: "jsdraw", wrapper: "none", filename: filename, contents: s };
        scil.Utils.post(JSDrawServices.url + "?cmd=savefile", args, "_blank");
    },

    cleanup: function (jsd) {
        var selected = jsd.m.clone(true);
        if (selected != null && selected.atoms.length == 0)
            selected = null;
        var smiles = selected != null ? selected.getSmiles() : jsd.getSmiles();
        if (smiles == null || smiles == "")
            return;

        var url = JSDrawServices.url;
        if (url == null) {
            scil.Utils.alert("JSDraw Web Service is not configured yet.");
            return;
        }

        var l = window.location;
        var s = l.protocol + "//" + l.host + "/";

        var fun = null;
        if (scil.Utils.startswith(url.toLowerCase(), s.toLowerCase())) {
            fun = scil.Utils.ajax;
            smiles = selected != null ? selected.getXml() : jsd.getXml();
        }
        else {
            fun = scil.Utils.jsonp;
        }

        var openbonds = [];
        if (selected != null) {
            for (var i = 0; i < jsd.m.bonds.length; ++i) {
                var b = jsd.m.bonds[i];
                if (b.a1.selected != b.a2.selected)
                    openbonds.push(b);
            }
        }

        var me = this;
        fun(url + "?cmd=cleanup", function (data) {
            if (selected != null) {
                var m = me._data2Mol(data);
                if (m != null && !m.isEmpty()) {
                    m.setBondLength(jsd.bondlength);

                    if (!me._connectOpenBonds(jsd.m, m, openbonds, jsd.bondlength)) {
                        var center = selected.rect().center();
                        var center2 = m.rect().center();
                        m.offset(center.x - center2.x, center.y - center2.y);
                    }

                    jsd.pushundo();
                    jsd.delSelected();

                    m.setSelected(true);
                    jsd.m.mergeMol(m);
                    jsd.refresh(true);

                }
            }
            else {
                me._setMolData(jsd, data, null, true);
            }
        }, { input: smiles, inputformat: "jsdraw" });
    },

    _connectOpenBonds: function (host, m, bonds, bondlength) {
        if (bonds.length == 0)
            return false;

        if (bonds.length > 1) {
            for (var i = 0; i < bonds.length; ++i) {
                var bond = bonds[i];
                var move = bond.a1.selected ? bond.a1 : bond.a2;
                var fix = bond.a1.selected ? bond.a2 : bond.a1;
                var a = m.getObjectById(move.id);
                if (a == null)
                    continue;

                var nb = bond.clone();
                nb.replaceAtom(move, a);
                m.addBond(nb);
            }
            return false;
        }

        var bond = bonds[0];
        var move = bond.a1.selected ? bond.a1 : bond.a2;
        var fix = bond.a1.selected ? bond.a2 : bond.a1;

        var a = m.getObjectById(move.id);
        if (a == null)
            return false;

        // translate
        var p;
        if (bond.selected) {
            var i = scil.Utils.indexOf(host.bonds, bond);
            host.bonds.splice(i, 1);
            p = host.guessBond(fix, bondlength);
            host.bonds.splice(i, 0, bond);
        }
        else {
            p = move.p;
        }
        m.offset(p.x - a.p.x, p.y - a.p.y);

        // rotate
        var p2 = m.guessBond(a, bondlength);
        var ang1 = fix.p.angleTo(p);
        var ang2 = p2.angleTo(p);
        m.rotate(p, ang1 - ang2);

        var nb = bond.clone();
        nb.replaceAtom(move, a);
        m.addBond(nb);
        return true;
    },

    _data2Mol: function (data) {
        var m = new JSDraw2.Mol();
        if (typeof (data) == "string")
            m = m.setXml(data);
        else
            m = m.setXml(data.output);
        return m;
    },

    _setMolData: function (jsd, data, q, clear) {
        var m = this._data2Mol(data);
        if (m == null || m.isEmpty())
            return;

        jsd.pushundo();
        if (jsd.setXml(m.getXml()) != null)
            jsd.refresh(true);
    },

    name2structure: function (jsd) {
        var fn = function (q) {
            var url;
            if (JSDrawServices.id2s != null && JSDrawServices.id2s.url != null && JSDrawServices.id2s.regex != null && q.match(JSDrawServices.id2s.regex) != null)
                url = JSDrawServices.id2s.url;
            else if (JSDrawServices.n2s != null && JSDrawServices.n2s.url != null)
                url = JSDrawServices.n2s.url;

            if (url == null) {
                scil.Utils.alert("Name-to-structure is not configured yet.");
                return;
            }

            scil.Utils.jsonp(url, function (data) { JSDraw2.JSDrawIO._setMolData(jsd, data, q); }, { q: q, fmt: "jsdraw" }, { showprogress: true });
        };

        // caption, message, defaultval, btn, callback,
        var msg = JSDrawServices.n2s != null && JSDrawServices.url.msg != null ? JSDrawServices.n2s.msg : this.res("Please type chemical name, CAS, SMILES etc.") + ":";
        scil.Utils.prompt2({
            caption: "<img src='" + scil.Utils.imgSrc("img/n2s.gif") + "'>" + this.res("Name to Structure"),
            message: msg,
            button: this.res("Convert"),
            callback: fn,
            autosuggesturl: (JSDrawServices.n2s != null ? JSDrawServices.n2s.suggest : null),
            iconurl: scil.Utils.imgSrc("img/name2s.gif"),
            owner: jsd
        });
    },

    res: function (s) {
        return JSDraw2.Language.res(s);
    },

    jssFileOpen: function (jss) {
        var check = { msg: "Appending Mode" };
        if (jss.options.appendingmode) {
            check.checked = true;
            check.disabled = true;
        }
        var structurecolumn = jss.options.structurecolumn == null ? "" : jss.options.structurecolumn;
        scil.Utils.uploadFile("<img src='" + scil.Utils.imgSrc("img/open.gif") + "'>" + this.res("Open File"),
            this.res("Please select a file") + " (*.sdf,*.rdf,*.xls,*.csv,*.smiles):", JSDrawServices.url + "?cmd=openjss",
            function (ret) { JSDraw2.JSDrawIO.jssFileOpen2(jss, ret); }, { structurecolumn: structurecolumn }, check);

        if (this.needCrossdomain()) {
            var url = JSDrawServices.url + "?cmd=";
            scil.Utils.uploadFile("<img src='" + scil.Utils.imgSrc("img/open.gif") + "'>" + this.res("Open File"),
                this.res("Please select a file") + " (*.sdf,*.rdf,*.xls,*.csv,*.smiles)",
                url + "xdomain.post", function (xfilename) {
                    scil.Utils.jsonp(url + "openjss", function (ret) { JSDraw2.JSDrawIO.jssFileOpen2(jsd, ret); },
                    { _xfilename: xfilename, structurecolumn: structurecolumn });
                }, null, null, null, null, true);
        }
        else {
            scil.Utils.uploadFile("<img src='" + scil.Utils.imgSrc("img/open.gif") + "'>" + this.res("Open File"),
                this.res("Please select a file") + " (*.sdf,*.rdf,*.xls,*.csv,*.smiles):", JSDrawServices.url + "?cmd=openjss",
                function (ret) { JSDraw2.JSDrawIO.jssFileOpen2(jss, ret); }, { structurecolumn: structurecolumn }, check);
        }
    },

    jssFileOpen2: function (jss, ret, check) {
        var appendingmode = scil.Utils.uploadfileDlg.check.checked;
        if (scil.Utils.endswith(ret.filename, ".rdf"))
            jss.setRdf(ret.base64 != null ? JSDraw2.Base64.decode(ret.base64) : ret.contents, null, null, !appendingmode);
        //else if (scil.Utils.endswith(ret.filename, ".sdf"))
        //    jss.setSdf(ret.base64 != null ? JSDraw2.Base64.decode(ret.base64) : ret.contents, null, null, !appendingmode);
        else
            jss.setXml(ret.base64 != null ? JSDraw2.Base64.decode(ret.base64) : ret.contents, null, !appendingmode, appendingmode);
    },

    jssFileSave: function (jss) {
        if (JSDraw2.JSDrawIO.jsssavedlg == null) {
            var div = scil.Utils.createElement(null, "div", this.res("Please select a file type") + ":", { width: "350px", margin: "10px" });
            var sel = scil.Utils.createElement(div, "select");
            scil.Utils.createElement(sel, "option");
            scil.Utils.listOptions(sel, JSDraw2.JSDrawIO.jssFiles, null, false);

            var s = scil.Utils.createElement(div, "div", null, { marginTop: "20px", textAlign: "center" });
            var btn = scil.Utils.createElement(s, "button", "<img src='" + scil.App.imgSmall("submit.png") + "'>" + this.res("Save"));
            dojo.connect(btn, "onclick", function (e) { JSDraw2.JSDrawIO.jssFileSave2(); e.preventDefault(); });
            JSDraw2.JSDrawIO.jsssavedlg = new JSDraw2.Dialog("<img src='" + scil.App.imgSmall("save.png") + "'>" + this.res("Save File"), div);
            JSDraw2.JSDrawIO.jsssavedlg.sel = sel;
        }
        JSDraw2.JSDrawIO.jsssavedlg.jss = jss;
        JSDraw2.JSDrawIO.jsssavedlg.show();
        JSDraw2.JSDrawIO.jsssavedlg.sel.selectedIndex = 0;
    },

    jssFileSave2: function () {
        var ext = JSDraw2.JSDrawIO.jsssavedlg.sel.value;
        var dt = new Date();
        var filename = "JSDrawTable" + dt.getFullYear() + "-" + (dt.getMonth() + 1) + "-" + dt.getDate() + "." + ext;
        var args = { client: "jssdf", wrapper: "none", filename: filename };
        switch (ext) {
            case "sdf":
                args.contents = JSDraw2.JSDrawIO.jsssavedlg.jss.getSdf();
                break;
            case "jssdf":
                args.contents = JSDraw2.JSDrawIO.jsssavedlg.jss.getXml();
                break;
            case "xlsx":
                args.contents = JSDraw2.JSDrawIO.jsssavedlg.jss.getXml(null, true);
                break;
            case "json":
                args.contents = scil.Utils.json2str(JSDraw2.JSDrawIO.jsssavedlg.jss.getJson());
                break;
            case "csv":
                args.contents = JSDraw2.JSDrawIO.jsssavedlg.jss.getCsv();
                break;
        }
        scil.Utils.post(JSDrawServices.url + "?cmd=savefile", args, "_blank");
        JSDraw2.JSDrawIO.jsssavedlg.hide();
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Mol class - define a Molecule object
*<pre>
* <b>Example:</b>
*    var molfile = "\n";
*    molfile += "MolEngine02021312372D\n";
*    molfile += "\n";
*    molfile += "  2  1  0  0  0  0  0  0  0  0999 V2000\n";
*    molfile += "    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n";
*    molfile += "    1.3510    0.7800    0.0000 O   0  0  0  0  0  0  0  0  0  0  0  0\n";
*    molfile += "  1  2  1  0  0  0  0\n";
*    molfile += "M  END\n";
*
*    var m = new JSDraw3.Mol();
*    m.setMolfile(molfile);
*
*    var smiles = m.getSmiles();
* </pre>
* @class scilligence.JSDraw2.Mol
*/
JSDraw2.Mol = scil.extend(scil._base, {
    /**
    @property {array} atoms Array of Atom Objects
    */
    /**
    @property {array} bonds Array of Bond Objects
    */
    /**
    @property {array} graphics Array of Graphics (not Atom and Bond) Objects
    */

    /**
    * @constructor Mol
    */
    constructor: function (showimplicithydrogens) {
        this.T = "MOL";
        this.name = null;
        this.atoms = [];
        this.bonds = [];
        this.graphics = [];
        this.stats = null;
        this.showimplicithydrogens = showimplicithydrogens != false;
        this.props = null;
    },

    _addAtom: function (a, parent) { this.atoms.push(a); a._parent = parent != null ? parent : this; },
    _addBond: function (a, parent) { this.bonds.push(a); a._parent = parent != null ? parent : this; },
    _addGraphics: function (a, parent) { this.graphics.push(a); a._parent = parent != null ? parent : this; },

    /**
    * Reset object IDs including atoms, bonds, and other graphics
    * @function resetIds
    * @returns null
    */
    resetIds: function (keepoldid) {
        var idg = new JSDraw2.IDGenerator(keepoldid ? this._getMaxID() : 0);

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            a.id = idg.next(a.id);
            a.atomid = i + 1;
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var a = this.bonds[i];
            a.id = idg.next(a.id);
            a.bondid = i + 1;
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var a = this.graphics[i];
            a.id = idg.next(a.id);
            a.graphicsid = i + 1;
        }

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.rgroup != null)
                a.rgroup.id = idg.next(a.rgroup.id);
        }
    },

    _getMaxID: function () {
        var max = 0;
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.id > max)
                max = a.id;
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var a = this.bonds[i];
            if (a.id > max)
                max = a.id;
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var a = this.graphics[i];
            if (a.id > max)
                max = a.id;
        }

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.rgroup != null) {
                if (a.rgroup.id > max)
                    max = a.rgroup.id;
            }
        }

        return max;
    },

    getObjectById: function (id) {
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i].id == id)
                return this.atoms[i];
        }
        for (var i = 0; i < this.bonds.length; ++i) {
            if (this.bonds[i].id == id)
                return this.bonds[i];
        }
        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i].id == id)
                return this.graphics[i];
        }
    },

    /**
    * Clone the Mol object
    * @function clone
    * @param {bool} selectedOnly - indicate if cloning only selected objects
    * @returns a new Mol object
    */
    clone: function (selectedOnly) {
        var m = new JSDraw2.Mol();
        m.bondlength = this.bondlength;
        m.name = this.name;
        m.chiral = this.chiral;
        m.props = scil.clone(this.props);
        m.showimplicithydrogens = this.showimplicithydrogens;
        m.mw = this.mw;
        m.attachpoints = this.attachpoints;

        var map = [];
        this.resetIds(true);
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (selectedOnly && !a.selected)
                continue;

            var a1 = a.clone(selectedOnly);
            if (selectedOnly)
                a1.atommapid = null;
            m._addAtom(a1);
            map[a.id] = a1;
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (selectedOnly && !(b.selected && b.a1.selected && b.a2.selected))
                continue;

            var b1 = b.clone();
            m._addBond(b1);
            map[b.id] = b1;
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            if (selectedOnly && !g.selected)
                continue;

            var g1 = g.clone(map);
            m._addGraphics(g1);
            map[g.id] = g1;
        }

        // fix references
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            var b1 = map[b.id];
            if (b1 == null)
                continue;
            b1.a1 = map[b.a1.id];
            b1.a2 = map[b.a2.id];
            if (b1.a1 == null || b.a2 == null)
                i = i;
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            var g1 = map[g.id];
            if (g1 == null)
                continue;

            if (JSDraw2.Group.cast(g) != null) {
                for (var j = 0; j < this.atoms.length; ++j) {
                    var a = this.atoms[j];
                    if (a.group == g)
                        map[a.id].group = g1;
                }
                if (g.a != null)
                    g1.a = map[g.a.id];

                if (g.group != null)
                    g1.group = map[g.group.id];
            }
            else if (JSDraw2.Bracket.cast(g) != null) {
                g1.atoms = this._getMappedArray(g.atoms, map);
            }
            else if (JSDraw2.Text.cast(g) != null) {
                g1.anchors = this._getMappedArray(g.anchors, map);
            }
            else if (JSDraw2.Shape.cast(g) != null) {
                g1.froms = this._getMappedArray(g.froms, map);
                if (g1.reject != null)
                    g1.reject = map[g1.reject.id];
            }
        }

        m._setParent(m);
        return m;
    },

    _getMappedArray: function (list, map) {
        var ret = [];
        for (var i = 0; i < list.length; ++i) {
            var d = list[i];
            if (d != null && map[d.id] != null)
                ret.push(map[d.id]);
        }
        return ret;
    },

    guessBond: function (a, len, extra) {
        var p = a.p.clone();
        var bonds = this.getAllBonds(a);
        switch (bonds.length + (extra > 0 ? extra : 0)) {
            case 0:
                p.offset(1, 0);
                break;
            case 1:
                p = bonds[0].otherAtom(a).p.clone().rotateAround(a.p, 120);
                break;
            case 2:
                var p1 = bonds[0].otherAtom(a).p;
                var p2 = bonds[1].otherAtom(a).p;
                var angle = a.p.angleAsOrigin(p1, p2);
                if (Math.abs(angle - 180) <= 1) {
                    p = p1.clone();
                    p.rotateAround(a.p, 90);
                }
                else {
                    p.x = (p1.x + p2.x) / 2;
                    p.y = (p1.y + p2.y) / 2;
                    p.rotateAround(a.p, 180);
                }
                break;
            case 3:
                var p1 = bonds[0].otherAtom(a).p;
                var p2 = bonds[1].otherAtom(a).p;
                var p3 = bonds[2].otherAtom(a).p;
                var a1 = p.angleAsOrigin(p1, p2);
                var a2 = p.angleAsOrigin(p2, p3);
                var a3 = p.angleAsOrigin(p3, p1);
                if (a1 > 180)
                    a1 = 360 - a1;
                if (a2 > 180)
                    a2 = 360 - a2;
                if (a3 > 180)
                    a3 = 360 - a3;
                if (a1 > a2 && a1 > a3)
                    p = p3.clone();
                else if (a2 > a1 && a2 > a3)
                    p = p1.clone();
                else
                    p = p2.clone();
                p.rotateAround(a.p, 180);
                break;
            default:
                return null;
        }
        p.setLength(len, a.p);
        return p;
    },

    getMaxRIndex: function (index) {
        if (index == null)
            index = 0;

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.elem != "R")
                continue;
            var r = scil.Utils.parseIndex(a.alias);
            if (r == null || r.index == null)
                continue;

            if (r.index > index)
                index = r.index;
            if (a.rgroup != null) {
                for (var j = 0; j < a.rgroup.mols.length; ++j) {
                    var r = a.rgroup.mols[j].getMaxRIndex(index);
                    if (r > index)
                        index = r;
                }
            }
        }
        return index;
    },

    /**
    * Set color to all objects
    * @function setColor
    * @param {string} color - a color, such as red, blue, #ffe, #f0f0f0
    * @param {bool} selectedOnly - indicate if only set the color to selected objects
    * @returns null
    */
    setColor: function (color, selectedOnly) {
        var n = 0;
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.color != color && (!selectedOnly || a.selected)) {
                a.color = color;
                ++n;
            }

            if (a.rgroup != null) {
                if (a.rgroup.color != color && (!selectedOnly || a.rgroup.selected)) {
                    a.rgroup.color = color;
                    ++n;
                }
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    n += a.rgroup.mols[j].setColor(color, selectedOnly);
            }
        }
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.color != color && (!selectedOnly || b.selected)) {
                b.color = color;
                ++n;
            }
        }
        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            if (g.color != color && (!selectedOnly || g.selected)) {
                g.color = color;
                ++n;
            }
        }

        return n;
    },

    /**
    * Remove all object
    * @function clear
    * @returns null
    */
    clear: function () {
        this.name = null;
        this.chiral = null;
        this.atoms = [];
        this.bonds = [];
        this.graphics = [];
    },

    /**
    * Test if the Mol object is empty - without any atom, bond, or graphics
    * @function isEmpty
    * @returns true or false
    */
    isEmpty: function () {
        return this.atoms.length == 0 && this.bonds.length == 0 && this.graphics.length == 0;
    },

    /**
    * Set selecting flags to all objects
    * @function setSelected
    * @param {bool} f - true or false
    * @returns null
    */
    setSelected: function (f) {
        if (f == null)
            f = false;

        var n = 0;
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.selected != f) {
                a.selected = f;
                ++n;
            }
            if (a.rgroup != null) {
                if (a.rgroup.selected != f) {
                    a.rgroup.selected = f;
                    ++n;
                }
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    n += a.rgroup.mols[j].setSelected(f);
            }
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.selected != f) {
                b.selected = f;
                ++n;
            }
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            if (g.selected != f) {
                g.selected = f;
                ++n;
            }
        }

        return n;
    },

    lassoSelect: function (extra, start, end, last, linewidth, tor) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.p.inTriangle(start, end, last))
                extra.lasso.hit(a);

            if (a.rgroup != null) {
                var g = a.rgroup;
                var r2 = g.rect();
                if (r2.center().inTriangle(start, end, last))
                    extra.lasso.hit(g);
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].lassoSelect(extra, start, end, last, linewidth, tor);
            }
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.center().inTriangle(start, end, last))
                extra.lasso.hit(b);
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            var r2 = g.rect();
            if (r2.center().inTriangle(start, end, last))
                extra.lasso.hit(g);
        }

        extra.lasso.endHits(start, end);
    },

    getSelectedAtomInMol: function () {
        var list = [];
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.selected) {
                list.push(a);
            }
            else if (a.rgroup != null) {
                for (var j = 0; j < a.rgroup.mols.length; ++j) {
                    var r = a.rgroup.mols[j].getSelectedAtomInMol();
                    if (r.length > 0)
                        return r;
                }
            }
        }
        return list;
    },

    bracketSelect: function (r) {
        var ret = [];
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (r.contains(a.p))
                ret.push(a);
        }

        // find open connected bonds
        var xbonds = [];
        var bonds = scil.clone(this.bonds);
        for (var i = this.bonds.length - 1; i >= 0; --i) {
            var b = this.bonds[i];
            var f1 = scil.Utils.indexOf(ret, b.a1) >= 0;
            var f2 = scil.Utils.indexOf(ret, b.a2) >= 0;
            if (f1 != f2) {
                if (JSDraw2.Point.intersect(b.a1.p, b.a2.p, r.topleft(), r.bottomleft()) ||
                    JSDraw2.Point.intersect(b.a1.p, b.a2.p, r.topright(), r.bottomright())) {
                    xbonds.push({ b: b, a: f2 ? b.a1 : b.a2 });
                    bonds.splice(i, 1);
                }
            }
        }

        // only handle one or two open connected bonds
        if (xbonds.length == 2 || xbonds.length == 1) {
            var oldbonds = this.bonds;
            this.bonds = bonds;
            var frags = this.splitFragments();
            this.bonds = oldbonds;

            if (frags.length > 1) {
                for (var i = 0; i < frags.length; ++i) {
                    if (scil.Utils.arrayContainsArray(frags[i].atoms, ret)) {
                        // avoid circle
                        if (xbonds.length == 1 && scil.Utils.indexOf(frags[i].atoms, xbonds[0].a) < 0 ||
                            xbonds.length == 2 && scil.Utils.indexOf(frags[i].atoms, xbonds[0].a) < 0 && scil.Utils.indexOf(frags[i].atoms, xbonds[1].a) < 0) {
                            ret = frags[i].atoms;
                            break;
                        }
                    }
                }
            }
        }

        for (var i = 0; i < ret.length; ++i)
            ret[i].selected = true;
        return ret;
    },

    selectInRect: function (r) {
        var n = 0;
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (r.contains(a.p)) {
                a.selected = true;
                ++n;
            }

            if (a.rgroup != null) {
                var g = a.rgroup;
                var r2 = g.rect();
                if (r2 != null && r.contains(r2.center())) {
                    g.selected = true;
                    ++n;
                }

                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    n += a.rgroup.mols[j].selectInRect(r);
            }
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (r.contains(b.center())) {
                b.selected = true;
                ++n;
            }
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            var r2 = g.rect();
            if (r2 != null && r.contains(r2.center())) {
                g.selected = true;
                ++n;
            }
        }
        return n;
    },

    hasAtom: function (a) {
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i] == a)
                return true;
        }
        return false;
    },

    hasGraphics: function (g) {
        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i] == g)
                return true;
        }
        return false;
    },

    hasBond: function (b) {
        for (var i = 0; i < this.bonds.length; ++i) {
            if (this.bonds[i] == b)
                return true;
        }
        return false;
    },

    calcHCount: function (recalc) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (recalc || a.hcount == null)
                this.setHCount(a);

            if (a.rgroup != null) {
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].calcHCount(recalc);
            }
        }
    },

    setHCount: function (a) {
        a.hcount = null;
        if (this.showimplicithydrogens == false || a.bio)
            return;

        var error = false;
        var v = null;

        if (a.elem != "R" && a.alias != null && a.alias != "") {
            if (a.superatom == null) {
                if (a.elem != "#")
                    error = true;
            }
            else if (a.superatom != null) {
                var bonds = this.getNeighborBonds(a, true);
                if (bonds.length > a.superatom.attachpoints) {
                    if (a.superatom.atoms.length > 0)
                        error = true;
                }
                else {
                    for (var i = 0; i < bonds.length; ++i) {
                        if (bonds[i].valence() != 1) {
                            error = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (a.hs > 0) {
            v = a.hs - 1;
        }
        else {
            var e = JSDraw2.PT[a.elem];
            if (e != null && e.v != null && e.e != null) {
                var bonds = this.getNeighborBonds(a);
                var sum = 0;
                var naromatic = 0;
                for (var i = 0; i < bonds.length; ++i) {
                    var val = bonds[i].valence();
                    if (val == null)
                        return;
                    if (val == 1.5) {
                        ++naromatic;
                        if (naromatic > 2) // two benzene-rings
                            sum += 1;
                        else
                            sum += 1.5;
                    }
                    else {
                        sum += bonds[i].valence();
                    }
                }

                // the two bonds connect to O and S on c1cocc1 should be single bond
                // TODO: Nitrogen on c1ncnc1: one N should be NH, and one should N
                if (bonds.length == 2 && (a.elem == "O" || a.elem == "S") &&
                    bonds[0].type == JSDraw2.BONDTYPES.DELOCALIZED && bonds[1].type == JSDraw2.BONDTYPES.DELOCALIZED) {
                    --sum;
                }

                // charges
                var extra = 0;
                var pair_e = e.e <= 4 ? 0 : e.e % 4;
                var single_e = e.e <= 4 ? e.e : 4 - (e.e % 4);
                if (a.charge > 0) {
                    if (pair_e > 0) {
                        if (pair_e >= a.charge)
                            extra = a.charge;
                        else
                            return;
                    }
                    else if (single_e > 0) {
                        if (single_e >= a.charge)
                            extra -= a.charge;
                        else
                            return;
                    }
                }
                else if (a.charge < 0) {
                    if (single_e > 0) {
                        if (single_e > -a.charge)
                            extra = a.elem == "B" || a.elem == "P" || a.elem == "Si" ? -a.charge : a.charge; // I#8702
                        else
                            return;
                    }
                }

                // radical
                if (a.radical == 1 || a.radical == 3)
                    sum += 2;
                else if (a.radical == 2)
                    ++sum;

                // attach points
                if (a.attachpoints != null) {
                    for (var i = 0; i < a.attachpoints.length; ++i) {
                        if (a.attachpoints[i] != 99)
                            ++sum;
                    }
                }

                sum = Math.ceil(sum);
                error = true;
                for (var i = 0; i < e.v.length; ++i) {
                    if (sum <= e.v[i] + extra) {
                        v = e.v[i] + extra - sum;
                        error = false;
                        break;
                    }
                }
            }
        }

        a.hasError = error;
        return a.hcount = v;
    },

    hasError: function () {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.hasError)
                return true;
        }
        return false;
    },

    hasGenericAtom: function () {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.elem == "R" && a.bio == null || a.superatom != null && a.superatom.atoms.length == 0)
                return true;
        }
        return false;
    },

    /**
    * Find a bond
    * @function findBond
    * @param {Atom} a1 - the first atom
    * @param {Atom} a2 - the second atom
    * @returns the bond
    */
    findBond: function (a1, a2) {
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.a1 == a1 && b.a2 == a2 || b.a1 == a2 && b.a2 == a1)
                return b;
        }
        return null;
    },

    /**
    * Move all objects to the center
    * @function moveCenter
    * @param {number} width - the width of the view
    * @param {number} height - the height of the view
    * @returns null
    */
    moveCenter: function (width, height) {
        if (this.isEmpty())
            return;

        var center = this.center();
        this.offset(width > 0 ? (width / 2 - center.x) : 0,
            height > 0 ? (height / 2 - center.y) : 0);
    },

    /**
    * Clean up the reaction, and make it looks nicer
    * @function cleanupRxn
    * @returns null
    */
    cleanupRxn: function (defaultbondlength) {
        var rxn = this.parseRxn(true);
        if (rxn == null || rxn.reactants.length == 1 && rxn.products.length == 0 && rxn.arrow == null)
            return false;

        var bondlength = this.medBondLength();
        if (!(bondlength > 0))
            bondlength = defaultbondlength > 0 ? defaultbondlength : JSDraw2.Editor.BONDLENGTH;
        return this._layoutRxn(rxn, bondlength);
    },

    _layoutRxn: function (rxn, bondlength) {
        var pluses = [];
        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i].T == "PLUS")
                pluses.push(this.graphics[i]);
        }

        var x = null;
        var y = null;
        for (var i = 0; i < rxn.reactants.length; ++i) {
            var r = rxn.reactants[i].rect();
            if (r.width == 0)
                r.inflate(bondlength, 0);
            if (r.height == 0)
                r.inflate(0, bondlength);

            if (x == null) {
                x = r.right();
                y = r.center().y;
            }
            else {
                x += bondlength;
                if (pluses.length > 0) {
                    var plus = pluses.pop();
                    plus.p = new JSDraw2.Point(x, y);
                }
                else {
                    var plus = new JSDraw2.Plus(new JSDraw2.Point(x, y));
                    this._addGraphics(plus);
                }

                x += bondlength;
                rxn.reactants[i].offset(x - r.left, y - r.center().y);
                x += r.width;
            }
        }

        var arrow = rxn.arrow;
        if (arrow != null) {
            var ang = arrow.p2.angleTo(arrow.p1);
            arrow.p2.rotateAround(arrow.p1, -ang);
            var r = arrow.rect();
            if (x == null) {
                x = r.right();
                y = r.center().y;
            }
            else {
                x += bondlength;
                arrow.offset(x - r.left, y - r.center().y);
                x += r.width;
            }

            // adjust arrow width
            var width = 0;
            if (rxn.above != null) {
                for (var i = 0; i < rxn.above.length; ++i) {
                    var w = rxn.above[i]._rect.width;
                    if (w > width)
                        width = w;
                }
            }
            if (rxn.below != null) {
                for (var i = 0; i < rxn.below.length; ++i) {
                    var w = rxn.below[i]._rect.width;
                    if (w > width)
                        width = w;
                }
            }
            if (width > 0 && width + bondlength > r.width) {
                var d = width + bondlength - r.width;
                arrow.p2.offset(d, 0);
                x += d;
            }

            // layout reaction conditions above/below arrow
            var d = bondlength / 10;
            var center = arrow.rect().center();

            if (rxn.above != null) {
                var y1 = center.y - d * 2;
                for (var i = rxn.above.length - 1; i >= 0; --i) {
                    var t = rxn.above[i];
                    t.offset(center.x - t._rect.center().x, y1 - t._rect.bottom());
                    y1 = t._rect.top - d;
                }
            }

            if (rxn.below != null) {
                var y2 = center.y + d * 2;
                for (var i = 0; i < rxn.below.length; ++i) {
                    var t = rxn.below[i];
                    t.offset(center.x - t._rect.center().x, y2 - t._rect.top);
                    y2 = t._rect.bottom() + d;
                }
            }
        }

        for (var i = 0; i < rxn.products.length; ++i) {
            var r = rxn.products[i].rect();
            if (r.width == 0)
                r.inflate(bondlength, 0);
            if (r.height == 0)
                r.inflate(0, bondlength);

            if (x == null) {
                x = r.right();
                y = r.center().y;
            }
            else {
                if (i > 0) {
                    x += bondlength;
                    if (pluses.length > 0) {
                        var plus = pluses.pop();
                        plus.p = new JSDraw2.Point(x, y);
                    }
                    else {
                        var plus = new JSDraw2.Plus(new JSDraw2.Point(x, y));
                        this._addGraphics(plus);
                    }
                }

                x += bondlength;
                rxn.products[i].offset(x - r.left, y - r.center().y);
                x += r.width;
            }
        }

        for (var i = 0; i < pluses.length; ++i)
            this.delObject(pluses[i]);

        return true;
    },

    /**
    * Return the center coorindate of all objects
    * @function center
    * @returns the center as a Point object
    */
    center: function () {
        return this.rect().center();
    },

    /**
    * Return the Rect of a Group
    * @function getGroupRect
    * @param {Group} g - the input group
    * @returns a Rect object
    */
    getGroupRect: function (g, bondlength) {
        var r = null;
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.group != g || a.hidden)
                continue;

            var p = a.p;
            if (r == null)
                r = new JSDraw2.Rect(p.x, p.y, 0, 0);
            else
                r.unionPoint(p);
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g2 = this.graphics[i];
            if (g2.group != g)
                continue;

            var rect = JSDraw2.Group.cast(g2) != null ? this.getGroupRect(g2, bondlength) : g2.rect();
            if (r == null)
                r = rect.clone();
            else
                r.union(rect);
        }

        if (r != null && g.gap > 0)
            r.inflate(g.gap * bondlength / 15.0, g.gap * bondlength / 15.0);
        return r;
    },

    /**
    * Get the Rect of selected atoms
    * @function getSelectedRect
    * @returns a Rect object
    */
    getSelectedRect: function () {
        var r = null;
        for (var i = 0; i < this.atoms.length; ++i) {
            if (!this.atoms[i].selected)
                continue;

            var p = this.atoms[i].p;
            if (r == null)
                r = new JSDraw2.Rect(p.x, p.y, 0, 0);
            else
                r.unionPoint(p);
        }
        return r;
    },

    /**
    * Return the Rect of all object
    * @function rect
    * @returns a Rect object
    */
    rect: function (withoutRgroups) {
        if (this.atoms.length == 0) {
            if (this.graphics.length == 0)
                return null;
            var r = this.graphics[0].rect();
            for (var i = 1; i < this.graphics.length; ++i)
                r.union(this.graphics[i].rect());
            return r;
        }

        var x1 = null;
        var y1 = null;
        var x2 = null;
        var y2 = null;

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.hidden)
                continue;

            var p = a.p;
            if (x1 == null) {
                x1 = x2 = p.x;
                y1 = y2 = p.y;
                continue;
            }

            if (p.x < x1)
                x1 = p.x;
            else if (p.x > x2)
                x2 = p.x;

            if (p.y < y1)
                y1 = p.y;
            else if (p.y > y2)
                y2 = p.y;
        }

        var r = new JSDraw2.Rect(x1, y1, x2 - x1, y2 - y1);
        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            if (JSDraw2.Group.cast(g) != null)
                continue;
            r.union(g.rect());
        }

        if (!withoutRgroups) {
            for (var i = 0; i < this.atoms.length; ++i) {
                var a = this.atoms[i];
                if (a.rgroup == null)
                    continue;
                r.union(a.rgroup.rect());
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    r.union(a.rgroup.mols[j].rect());
            }
        }

        return r;
    },

    /**
    * Move all objects
    * @function offset
    * @param {number} dx - x offset
    * @param {number} dy - y offset
    * @param {bool} selectedOnly - indicated if moving only selected objects
    * @returns null
    */
    offset: function (dx, dy, selectedOnly) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (selectedOnly != true || a.selected)
                a.p.offset(dx, dy);
            if (a.rgroup != null) {
                if (selectedOnly != true || a.rgroup.selected)
                    a.rgroup.offset(dx, dy);
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].offset(dx, dy, selectedOnly);
            }
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            if (selectedOnly != true || g.selected) {
                this.graphics[i].offset(dx, dy);
            }
            else {
                if (selectedOnly && !g.selected) {
                    var t = JSDraw2.Text.cast(g);
                    if (t != null && t.anchors.length > 0) {
                        var all = true;
                        for (var j = 0; j < t.anchors.length; ++j) {
                            if (!t.anchors[j].selected) {
                                all = false;
                                break;
                            }
                        }
                        if (all) {
                            t.selected = true;
                            t.offset(dx, dy);
                        }
                    }
                }
            }
        }
    },

    /**
    * Rotate all objects around a point
    * @function rotate
    * @param {Point} origin - the position to be rotated around
    * @param {number} deg - degrees to be rotated
    * @returns null
    */
    rotate: function (origin, deg) {
        for (var i = 0; i < this.atoms.length; ++i)
            this.atoms[i].p.rotateAround(origin, deg);
    },

    /**
    * Delete an object
    * @function delObject
    * @param {object} obj - Atom, bond, or graphics to be removed
    * @returns null
    */
    delObject: function (obj) {
        if (obj == null)
            return;

        var a = JSDraw2.Atom.cast(obj);
        if (a != null)
            return this.delAtom(a);

        var b = JSDraw2.Bond.cast(obj);
        if (b != null)
            return this.delBond(b);

        return this.delGraphics(obj);
    },

    delGraphics: function (obj) {
        var group = JSDraw2.Group.cast(obj);
        if (group != null) {
            for (var i = 0; i < this.atoms.length; ++i) {
                if (this.atoms[i].group == group)
                    this.atoms[i].group = null;
            }

            for (var i = 0; i < this.graphics.length; ++i) {
                if (this.graphics[i].group == group)
                    this.graphics[i].group = null;
            }
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i] == obj) {
                this.graphics.splice(i, 1);
                this.objectRemoved(obj);
                return true;
            }
        }
        return false;
    },

    delAtom: function (a, checkBonds) {
        var atoms = [];
        atoms.push(a);

        if (checkBonds != false) {
            for (var i = this.bonds.length - 1; i >= 0; --i) {
                var b = this.bonds[i];
                if (b.a1 == a || b.a2 == a) {
                    this.bonds.splice(i, 1);
                    this.objectRemoved(b);
                    atoms.push(b.otherAtom(a));
                    if (a.atommapid != null)
                        this.clearAtomMap(a.atommapid);
                }
            }
        }

        var n = 0;
        for (var i = 0; i < atoms.length; ++i) {
            var a1 = atoms[i];
            if (a == a1 || !a1.bio) {
                if (this.delLoneAtom(atoms[i]))
                    ++n;
            }
        }
        return n > 0;
    },

    delBond: function (b, delLoneAtom) {
        for (var i = 0; i < this.bonds.length; ++i) {
            if (this.bonds[i] == b) {
                this.bonds.splice(i, 1);
                if (delLoneAtom != false) {
                    if (!b.a1.bio)
                        this.delLoneAtom(b.a1);
                    if (!b.a2.bio)
                        this.delLoneAtom(b.a2);
                }
                this.objectRemoved(b);
                return true;
            }
        }

        return false;
    },

    delLoneAtom: function (a) {
        if (!this.isLoneAtom(a)) {
            this.setHCount(a);
            return false;
        }

        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i] == a) {
                this.atoms.splice(i, 1);
                if (a.atommapid != null)
                    this.clearAtomMap(a.atommapid);
                this.objectRemoved(a);
                return true;
            }
        }

        return false;
    },

    objectRemoved: function (obj) {
        for (var i = 0; i < this.graphics.length; ++i) {
            var g = this.graphics[i];
            if (g.removeObject != null)
                g.removeObject(obj);
        }
    },

    hasSelected: function () {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (this.atoms[i].selected)
                return true;
            if (a.rgroup != null) {
                if (a.rgroup.selected) {
                    return true;
                }
                else {
                    for (var j = 0; j < a.rgroup.mols.length; ++j) {
                        if (a.rgroup.mols[j].hasSelected())
                            return true;
                    }
                }
            }
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            if (this.bonds[i].selected)
                return true;
        }

        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i].selected)
                return true;
        }

        return false;
    },

    delSelected: function () {
        var n = 0;

        var atoms = scil.clone(this.atoms);
        for (var i = 0; i < atoms.length; ++i) {
            var a = atoms[i];
            if (a.selected) {
                this.delAtom(atoms[i]);
                ++n;
            }

            if (a.rgroup != null) {
                if (a.rgroup.selected) {
                    a.rgroup = null;
                    ++n;
                }
                else {
                    for (var j = 0; j < a.rgroup.mols.length; ++j)
                        n += a.rgroup.mols[j].delSelected();
                }
            }
        }

        var bonds = scil.clone(this.bonds);
        for (var i = 0; i < bonds.length; ++i) {
            if (bonds[i].selected) {
                this.delBond(bonds[i]);
                ++n;
            }
        }

        var graphics = scil.clone(this.graphics);
        for (var i = 0; i < graphics.length; ++i) {
            if (graphics[i].selected) {
                this.delObject(graphics[i]);
                ++n;
            }
        }

        return n;
    },

    setBondLength: function (d) {
        var s = d / this.medBondLength();
        if (isNaN(s))
            return false;
        this.scale(s);
    },

    getSketchType: function () {
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i].bio != null)
                return "biologics";
        }
        return this.isRxn() ? "reaction" : "molecule";
    },

    /**
    * Merge another Molecule
    * @function mergeMol
    * @param {Mol} m - the Molecule to be merged
    */
    mergeMol: function (m, _parent, group) {
        for (var i = 0; i < m.atoms.length; ++i) {
            this.addAtom(m.atoms[i]);
            if (group != null)
                m.atoms[i].group = group;
        }

        for (var i = 0; i < m.bonds.length; ++i) {
            var b = m.bonds[i];
            if (this.findBond(b.a1, b.a2) == null)
                this.addBond(b, false);
        }

        for (var i = 0; i < m.graphics.length; ++i)
            this.addGraphics(m.graphics[i]);

        this._setParent(this);
    },

    replaceAtom: function (old, newa) {
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i] == old) {
                this.atoms[i] = newa;
                break;
            }
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.a1 == old)
                b.a1 = newa;
            if (b.a2 == old)
                b.a2 = newa;
        }

        this.setHCount(newa);
    },

    replaceBond: function (old, newb) {
        for (var i = 0; i < this.bonds.length; ++i) {
            if (this.bonds[i] == old) {
                this.bonds[i] = newb;
                break;
            }
        }

        this.replaceAtom(old.a1, newb.a1);
        this.replaceAtom(old.a2, newb.a2);
    },

    /**
    * Add a graphics
    * @function addGraphics
    * @param {Graphics} g - the graphics to be added
    * @returns the Graphics added
    */
    addGraphics: function (g) {
        if (this.hasGraphics(g))
            return null;

        this._addGraphics(g);
        return g;
    },

    /**
    * Add an Atom
    * @function addAtom
    * @param {Atom} a - the atom to be added
    * @returns the Atom added
    */
    addAtom: function (a) {
        if (this.hasAtom(a))
            return null;

        this._addAtom(a);
        return a;
    },

    /**
    * Add a Bond
    * @function addBond
    * @param {Bond} b - the bond to be added
    * @param {bool} resetcharge - indicate if reset atoms' charges of bonded atoms
    * @returns the Bond added
    */
    addBond: function (b, resetcharge, add2rgroup) {
        if (this.hasBond(b))
            return null;

        if (b.a1.mol != b.a2.mol) {
            if (add2rgroup) {
                this._addBond2RGroupMol(b);
            }
            else {
                scil.Utils.alert("Cannot create this bond");
                return null;
            }
        }

        this._addBond(b);
        if (resetcharge != false && b.type != JSDraw2.BONDTYPES.DUMMY)
            b.a1.charge = b.a2.charge = 0;

        if (b.a1.alias == "Me")
            b.a1.alias = null;
        if (b.a2.alias == "Me")
            b.a2.alias = null;

        this.setHCount(b.a1);
        this.setHCount(b.a2);
        return b;
    },

    _addBond2RGroupMol: function (b) {
        var m = b.a1._parent || b.a2._parent;
        if (m == null || b.a1._parent == b._parent && b.a2._parent == b.a1._parent)
            return;

        if (b.a1._parent == null) {
            m.addAtom(b.a1);
            b.a1._parent = m;
        }

        if (b.a2._parent == null) {
            m.addAtom(b.a2);
            b.a2._parent = m;
        }

        m.addBond(b);
        b._parent = m;
    },

    /**
    * Set atom alias
    * @function setAtomAlias
    * @param {Atom} a - the target atom
    * @param {string} alias - alias name
    * @returns true of false
    */
    setAtomAlias: function (a, alias, len) {
        if (alias == null || alias == "")
            return this.setAtomType(a, alias);

        if (a.alias == alias)
            return false;

        var elem = "*";
        var m = JSDraw2.SuperAtoms.get(alias);
        if (m == null) {
            var alias2 = alias.replace(/^[\+|\-]/, "").replace(/[\+|\-]$/, "");
            if (JSDraw2.PT[alias2] != null || (/^R[0-9]+$/).test(alias))
                return this.setAtomType(a, alias);

            var s = JSDraw2.SuperAtoms.guessOne(alias);
            if (s != null) {
                alias = s;
                m = JSDraw2.SuperAtoms.get(alias);
            }
            else {
                // leading O or S
                var list = this.getNeighborBonds(a);
                var orphan = list == null || list.length == 0 || list.length == 1 && list[0].type == JSDraw2.BONDTYPES.DUMMY;
                m = JSDraw2.FormulaParser.parse(alias, orphan, list.length);
                if (m != null && m.atoms.length == 0)
                    return this.setAtomType(a, m.atoms[0].elem);

                if (orphan) {
                    var salt = JSDraw2.FormulaParser.parseSalt(alias);
                    if (salt != null)
                        elem = "#";
                }
            }
        }

        a.isotope = null;
        a.query = null;
        a.hcount = null;
        a.radical = null;
        a.charge = 0;
        a.alias = alias;
        if (m != null) {
            var attach = JSDraw2.SuperAtoms._getFirstAttachAtom(m);
            if (attach != null)
                JSDraw2.SuperAtoms._alignMol(a._parent, a, m, attach, len != null ? len : this.medBondLength(1.56));
            a.superatom = m;
            a.rgroup = null;
            a.elem = elem;
        }
        else {
            if (!scil.Utils.isNullOrEmpty(alias))
                a.elem = elem;

            if (a.elem == "R")
                a.updateRGroup();
            else
                a.rgroup == null;
            a.superatom = null;
        }
        this.setHCount(a);
        return true;
    },

    setAttachPoint: function (a, apo) {
        if (apo > 0 && !(a.attachpoints.length == 1 && a.attachpoints[0] == apo)) {
            a.attachpoints = [apo];
            a._parent.setHCount(a);
            return true;
        }
        return false;
    },

    /**
    * Set atom type
    * @function setAtomType
    * @param {Atom} a - the target atom
    * @param {string} elem - element symbol of atom
    * @returns true of false
    */
    setAtomType: function (a, elem, setCharge) {
        if (elem == "antibody" || elem == "protein" || elem == "gene" || elem == "dna" || elem == "rna") {
            if (a.biotype() == JSDraw2.BIO.ANTIBODY || a.biotype() == JSDraw2.BIO.PROTEIN || a.biotype() == JSDraw2.BIO.GENE || a.biotype() == JSDraw2.BIO.DNA || a.biotype() == JSDraw2.BIO.RNA)
                return false;
            switch (elem) {
                case "antibody":
                    a.bio = { type: JSDraw2.BIO.ANTIBODY };
                    break;
                case "protein":
                    a.bio = { type: JSDraw2.BIO.PROTEIN };
                    break;
                case "gene":
                    a.bio = { type: JSDraw2.BIO.GENE };
                    break;
                case "dna":
                    a.bio = { type: JSDraw2.BIO.DNA };
                    break;
                case "rna":
                    a.bio = { type: JSDraw2.BIO.RNA };
                    break;
            }
            a.elem = "X";
            a.isotope = null;
            a.query = null;
            a.hcount = null;
            a.radical = null;
            a.charge = 0;
            return true;
        }

        var charge = null;
        if (elem.length > 1 && /[\+|\-][0-9]?$/.test(elem)) {
            var s = elem.replace(/[\+|\-][0-9]?$/, "");
            var cs = elem.substr(s.length);
            elem = s;
            if (cs == "+")
                charge = 1;
            else if (cs == "-")
                charge = -1;
            else
                charge = parseInt(cs);
        }

        if (a.elem == elem && (elem == 'H' && a.isotope == null) || a.bio)
            return false;
        var alias = null;
        var e = elem == "D" || elem == "T" ? "H" : elem;
        if ((/^R[0-9]+$/).test(elem)) {
            e = "R";
            alias = elem;
        }
        if (JSDraw2.PT[e] == null)
            return false;

        var oldelem = a.elem;
        a.elem = e;
        if (e != "R")
            a.rgroup = null;
        a.alias = alias;
        a.superatom = null;
        if (elem == "D")
            a.isotope = 2;
        else if (elem == "T")
            a.isotope = 3;
        else
            a.isotope = null;
        a.query = null;

        if (charge > 0 || charge < 0)
            a.charge = charge;
        else if (setCharge)
            a.charge = 0;

        if (oldelem == "@") {
            a.alias = null;
            a.bio = null;
            var list = this.getAllBonds(a);
            for (var i = 0; i < list.length; ++i) {
                var b = list[i];
                if (b.type == JSDraw2.BONDTYPES.DUMMY)
                    scil.Utils.removeArrayItem(this.bonds, b);
            }
        }

        a._parent.setHCount(a);
        if (e == "R")
            a.updateRGroup();
        return true;
    },

    /**
    * Set atom charges
    * @function setAtomCharge
    * @param {Atom} a - the target atom
    * @param {number} charge - charges
    * @returns true of false
    */
    setAtomCharge: function (a, charge) {
        if (charge == null || isNaN(charge) || a.bio)
            return false;
        charge = Math.round(charge);
        if (a.charge == charge)
            return false;
        a.charge = charge;
        a._parent.setHCount(a);
        return true;
    },

    /**
    * Set bond type
    * @function setBondType
    * @param {Bond} b - the target bond
    * @param {BONDTYPES} type - predefined bond type
    * @returns true of false
    */
    setBondType: function (b, type) {
        if (b.a1.biotype() == JSDraw2.BIO.AA && b.a2.biotype() == JSDraw2.BIO.AA) {
            if (b.type == JSDraw2.BONDTYPES.DISULFIDE && type == JSDraw2.BONDTYPES.PEPTIDE || b.type == JSDraw2.BONDTYPES.PEPTIDE && type == JSDraw2.BONDTYPES.DISULFIDE) {
                b.type = type;
                return true;
            }
        }
        else {
            if (type < JSDraw2.BONDTYPES.UNKNOWN && type > JSDraw2.BONDTYPES.DOUBLEORAROMATIC || b.a1.bio || b.a2.bio)
                return false;
            b.type = type;
            b._parent.setHCount(b.a1);
            b._parent.setHCount(b.a2);
            return true;
        }
    },

    isLoneAtom: function (a) {
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.a1 == a || b.a2 == a)
                return false;
        }

        return true;
    },

    medBondLength: function (defaultValue) {
        if (this.bonds.length == 0)
            return defaultValue;

        var step = Math.floor(this.bonds.length / 10);
        if (step == 0)
            step = 1;

        var list = [];
        for (var i = 0; i < this.bonds.length; i += step) {
            var b = this.bonds[i];
            list.push(b.a1.p.distTo(b.a2.p));
        }
        if (list.length == 0)
            return 1.5;
        if (list.length == 1)
            return list[0] <= 0 ? 1.5 : list[0];

        list.sort();
        var d = list[Math.round(list.length / 2)];
        return d <= 0 ? 1.5 : d;
    },

    _hasDoubleBonds: function (a) {
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.type == JSDraw2.BONDTYPES.DOUBLE && (b.a1 == a || b.a2 == a))
                return true;
        }
        return false;
    },

    getNeighborAtoms: function (a, oa, excludeDummyBond) {
        var list = [];
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (excludeDummyBond && b.type == JSDraw2.BONDTYPES.DUMMY)
                continue;

            if (b.a1 == a) {
                if (b.a2 != oa)
                    list.push(b.a2);
            }
            else if (b.a2 == a) {
                if (b.a1 != oa)
                    list.push(b.a1);
            }
        }
        return list;
    },

    getNeighborBonds: function (a, excludeDummyBonds) {
        var list = [];
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if ((b.a1 == a || b.a2 == a) &&
                (!excludeDummyBonds || b.type != JSDraw2.BONDTYPES.DUMMY && b.type != JSDraw2.BONDTYPES.UNKNOWN))
                list.push(b);
        }
        return list;
    },

    /**
    * Remove all hydrogen atoms
    * @function removeHydrogens
    * @returns the count of removed atoms
    */
    removeHydrogens: function () {
        var hs = [];
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.elem == "H" && a.isotope == null)
                hs.push(i);
        }

        for (var k = hs.length - 1; k >= 0; --k) {
            var a = this.atoms[hs[k]];
            for (var i = this.bonds.length - 1; i >= 0; --i) {
                var b = this.bonds[i];
                if (b.a1 == a || b.a2 == a)
                    this.bonds.splice(i, 1);
            }

            this.atoms.splice(hs[k], 1);
        }

        return hs.length;
    },

    draw: function (surface, linewidth, fontsize, textonly, dimension, highlighterrors, showcarbon, simpledraw) {
        if (linewidth == null)
            linewidth = 2;
        if (fontsize == null)
            fontsize = 14;

        if (textonly) {
            for (var i = 0; i < this.graphics.length; ++i) {
                if (this.graphics[i].T == "TEXT")
                    this.graphics[i].draw(surface, linewidth, this, fontsize);
            }
        }
        else {
            for (var i = 0; i < this.atoms.length; ++i) {
                var a = this.atoms[i];
                a._outside = a.p.x < -JSDraw2.speedup.gap || a.p.x > dimension.x + JSDraw2.speedup.gap || a.p.y < -JSDraw2.speedup.gap || a.p.y > dimension.y + JSDraw2.speedup.gap;
                a._haslabel = a.hasLabel(this, showcarbon);
            }

            // draw bonds connect to hidden group atom
            var bonds = [];
            for (var i = 0; i < this.bonds.length; ++i) {
                var b = this.bonds[i];
                if (b.a1._outside && b.a2._outside && !b.a1.hidden && !b.a2.hidden)
                    continue;

                if (!simpledraw || !b.selected) {
                    if (this.moveHiddenAtomToGroupBorder(b.a1, b.a2) || this.moveHiddenAtomToGroupBorder(b.a2, b.a1))
                        b.draw(surface, linewidth, this, fontsize, simpledraw);
                    else
                        bonds.push(b);
                }
            }

            for (var i = 0; i < this.graphics.length; ++i)
                this.graphics[i].draw(surface, linewidth, this, fontsize);

            for (var i = 0; i < bonds.length; ++i)
                bonds[i].draw(surface, linewidth, this, fontsize, simpledraw);

            var tor = linewidth * 2;
            if (simpledraw) {
                // I#9069
                for (var i = 0; i < this.atoms.length; ++i) {
                    var a = this.atoms[i];
                    if (a._outside || !a.hasErr())
                        continue;

                    var w = 8;
                    var r = new JSDraw2.Rect(a.p.x - w / 2, a.p.y - w / 2, w, w);
                    JSDraw2.Drawer.drawRect(surface, r, "red", linewidth).setFill("red");
                }
            }
            else {
                for (var i = 0; i < this.atoms.length; ++i) {
                    var a = this.atoms[i];
                    if (a._outside)
                        continue;

                    // check overlapping
                    for (var k = i + 1; k < this.atoms.length; ++k) {
                        var a1 = this.atoms[k];
                        if (Math.abs(a.p.x - a1.p.x) < tor && Math.abs(a.p.y - a1.p.y) < tor) {
                            var r = new JSDraw2.Rect(a.p.x - fontsize / 2, a.p.y - fontsize / 2, fontsize, fontsize);
                            JSDraw2.Drawer.drawRect(surface, r, "red", linewidth);
                            break;
                        }
                    }

                    a.draw(surface, linewidth, this, fontsize, highlighterrors);
                    if (a.rgroup != null) {
                        if (a.rgroup.text != null)
                            a.rgroup.draw(surface, linewidth, this, fontsize);
                        for (var j = 0; j < a.rgroup.mols.length; ++j)
                            a.rgroup.mols[j].draw(surface, linewidth, fontsize, textonly, dimension, highlighterrors);
                    }
                }
            }

            this.drawSelect(new JSDraw2.Lasso(surface, linewidth * (simpledraw ? 5 : 1), false), simpledraw);

            var s = null;
            if (this.chiral == "and")
                s = "[AND Enantiomer]";
            else if (this.chiral == "or")
                s = "[OR Enantiomer]";
            else if (this.chiral == true)
                s = "Chiral";

            if (s != null)
                JSDraw2.Drawer.drawText(surface, new JSDraw2.Point(dimension.x - fontsize * 4, fontsize * 1), s, "gray", fontsize, "right");
        }
    },

    moveHiddenAtomToGroupBorder: function (a, a2) {
        if (!a.hidden)
            return false;

        var g = this._findGroup(a);
        if (g == null)
            return false;

        var r = g.rect();
        if (!a2.hidden) {
            // group to atom: use the closest border
            var p = a2.p;
            if (p.x < r.left)
                a.p.x = r.left;
            else if (p.x > r.right())
                a.p.x = r.right();
            else
                a.p.x = p.x;

            if (p.y < r.top)
                a.p.y = r.top;
            else if (p.y > r.bottom())
                a.p.y = r.bottom();
            else
                a.p.y = p.y;

            a._outside = false;
        }
        else {
            // group to group
            var g2 = this._findGroup(a2);
            if (g2 == null)
                return false;

            var r2 = g2.rect();
            if (r.left >= r2.left && r.left <= r2.right() || r.right() >= r2.left && r.right() <= r2.right() || r2.left >= r.left && r2.left <= r.right() || r2.right() >= r.left && r2.right() <= r.right()) {
                // vertically overlapped: vertical center
                var x = (Math.max(r.left, r2.left) + Math.min(r.right(), r2.right())) / 2;
                a.p.x = a2.p.x = x;
                a.p.y = r.bottom() < r2.top ? r.bottom() : r.top;
                a2.p.y = r2.top > r.bottom() ? r2.top : r2.bottom();
            }
            else if (r.top >= r2.top && r.top <= r2.bottom() || r.bottom() >= r2.top && r.bottom() <= r2.bottom() || r2.top >= r.top && r2.top <= r.bottom() || r2.bottom() >= r.top && r2.bottom() <= r.bottom()) {
                // horizontally overlapped: horizontal center
                var y = (Math.max(r.top, r2.top) + Math.min(r.bottom(), r2.bottom())) / 2;
                a.p.y = a2.p.y = y;
                a.p.x = r.right() < r2.left ? r.right() : r.left;
                a2.p.x = r2.left > r.right() ? r2.left : r2.right();
            }
            else {
                // then corner to corner
                if (r.right() < r2.left) {
                    if (r.bottom() < r2.top) {
                        a.p = r.bottomright();
                        a2.p = r2.topleft();
                    }
                    else {
                        a.p = r.topright();
                        a2.p = r2.bottomleft();
                    }
                }
                else {
                    if (r.bottom() < r2.top) {
                        a.p = r.bottomleft();
                        a2.p = r2.topright();
                    }
                    else {
                        a.p = r.topleft();
                        a2.p = r2.bottomright();
                    }
                }
            }

            a._outside = false;
            a2._outside = false;
        }

        return true;
    },

    _findGroup: function (a) {
        for (var i = 0; i < this.graphics.length; ++i) {
            var g = JSDraw2.Group.cast(this.graphics[i]);
            if (g != null && g.a == a)
                return g;
        }

        return null;
    },

    drawSelect: function (lasso, simpledraw) {
        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i].selected)
                this.graphics[i].drawSelect(lasso);
        }

        for (var i = 0; i < this.atoms.length; ++i)
            this.atoms[i].__drawselect = false;

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.selected) {
                b.drawSelect(lasso);
                if (simpledraw) {
                    b.a1.__drawselect = true;
                    b.a2.__drawselect = true;
                }
            }
        }

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.selected && !a.__drawselect)
                a.drawSelect(lasso);

            if (a.rgroup != null) {
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].drawSelect(lasso, simpledraw);
            }
        }
    },

    setZOrder: function (g, z) {
        var i = scil.Utils.indexOf(this.graphics, g);
        if (i < 0 || this.graphics.length == 1)
            return false;

        if (z == 0) {
            if (z != i) {
                this.graphics.splice(i, 1);
                this.graphics.splice(0, 0, g);
            }
        }
        else if (z == -1) {
            if (i != this.graphics.length - 1) {
                this.graphics.splice(i, 1);
                this.graphics.push(g);
            }
        }

        return true;
    },

    calcHDir: function (a, tor, drawalias) {
        var atoms = this.getNeighborAtoms(a);
        if (atoms.length == 0 && a.charge == 0)
            return drawalias ? JSDraw2.ALIGN.RIGHT : JSDraw2.ALIGN.LEFT;

        var r = false, b = false, l = false, t = false;
        for (var i = 0; i < atoms.length; ++i) {
            var oa = atoms[i];
            var dx = oa.p.x - a.p.x;
            var dy = oa.p.y - a.p.y;
            if (dx > tor)
                r = true;
            else if (dx < -tor)
                l = true;
            if (dy > tor)
                b = true;
            else if (dy < -tor)
                t = true;
        }

        if (!r)
            return JSDraw2.ALIGN.RIGHT;
        else if (!l)
            return JSDraw2.ALIGN.LEFT;
        else if (!b)
            return JSDraw2.ALIGN.BOTTOM;
        else if (!t)
            return JSDraw2.ALIGN.TOP;
        return JSDraw2.ALIGN.RIGHT;
    },

    /**
    * Set molfile
    * @function setMolfile
    * @param {string} molfile - the input molfile
    * @returns the Mol object
    */
    setMolfile: function (molfile, rxn) {
        var m = this.setMolfile2(molfile, rxn);
        if (m != null)
            this.guessSuperAtoms();
        return m;
    },

    guessSuperAtoms: function () {
        return 0;
    },

    setMolfile2: function (molfile, rxn) {
        if (molfile != null && molfile.length > 4) {
            if (molfile.substr(0, 4) == "$RXN")
                return this.setRxnfile(molfile);
            if (molfile.substr(0, 4) == "$MDL")
                return this.setRgfile(molfile);
        }

        this.clear();
        if (molfile == null || molfile.length == 0)
            return null;

        var lines = null;
        if (molfile.indexOf('\n') >= 0)
            lines = molfile.replace(/[\r]/g, "").split("\n");
        else
            lines = molfile.split('|');

        for (var i = 0; i <= Math.min(3, lines.length - 1); ++i) {
            if (lines[i].toUpperCase().indexOf(" V2000") > 0) {
                this.setMolV2000(lines, i, rxn);
                if (i == 3)
                    this.name = scil.Utils.trim(lines[0]);
                return this;
            }
            else if (lines[i].toUpperCase().indexOf(" V3000") > 0) {
                this.setMolV3000(lines, i + 1, rxn);
                if (i + 1 == 3)
                    this.name = scil.Utils.trim(lines[0]);
                return this;
            }
        }
        return null;
    },

    setMolV2000: function (lines, start, rxn, rAtoms) {
        var natoms = parseFloat(lines[start].substr(0, 3));
        var nbonds = parseFloat(lines[start].substr(3, 3));
        var chiral = lines[start].substr(12, 3);
        if (!JSDraw2.defaultoptions.and_enantiomer)
            this.chiral = chiral == "  1";
        if (isNaN(natoms) || isNaN(nbonds))
            return null;
        ++start;

        for (var i = start; i < natoms + start; i++) {
            var s = lines[i];
            var x = parseFloat(s.substr(0, 10));
            var y = -parseFloat(s.substr(10, 10));
            var e = scil.Utils.trim(s.substr(31, 3));
            var c = s.length >= 39 ? parseInt(s.substr(36, 3)) : 0;
            var ami = rxn && s.length >= 63 ? parseInt(s.substr(60, 3)) : 0;
            var hs = s.length >= 45 ? parseInt(s.substr(42, 3)) : 0;
            var val = s.length >= 51 ? parseInt(s.substr(48, 3)) : 0;

            if (isNaN(x) || isNaN(y) || isNaN(c))
                return null;

            var alias = null;
            if ((/^R[0-9]+$/).test(e)) {
                alias = e;
                e = "R";
            }
            var a = new JSDraw2.Atom(new JSDraw2.Point(x, y), e == "R#" ? "R" : e);
            a.alias = alias;
            if (ami > 0)
                a.atommapid = ami;
            if (hs > 0 && hs <= 5)
                a.hs = hs;
            if (val > 0 && val <= 15)
                a.val = val;
            this._addAtom(a);
            switch (c) {
                case 1:
                    a.charge = 3;
                    break;
                case 2:
                    a.charge = 2;
                    break;
                case 3:
                    a.charge = 1;
                    break;
                case 5:
                    a.charge = -1;
                    break;
                case 6:
                    a.charge = -2;
                    break;
                case 7:
                    a.charge = -3;
                    break;
            }
        }

        start += natoms;
        for (i = start; i < (nbonds + start); i++) {
            var line = lines[i];
            var s = parseFloat(line.substr(0, 3)) - 1;
            var e = parseFloat(line.substr(3, 3)) - 1;
            var order = parseInt(line.substr(6, 3));
            var stereo = parseInt(line.substr(9, 3));
            var ring = line.length >= 18 ? parseInt(line.substr(15, 3)) : null;
            var rcenter = line.length >= 21 ? line.substr(18, 3) : null;
            if (isNaN(s) || isNaN(e) || isNaN(order))
                return null;

            var a1 = this.atoms[s];
            var a2 = this.atoms[e];
            var b;
            switch (order) {
                case 0:
                    b = JSDraw2.BONDTYPES.UNKNOWN;
                    break;
                case 1:
                    switch (stereo) {
                        case 1:
                            b = JSDraw2.BONDTYPES.WEDGE;
                            break;
                        case 4:
                            b = JSDraw2.BONDTYPES.WIGGLY;
                            break;
                        case 6:
                            b = JSDraw2.BONDTYPES.HASH;
                            break;
                        default:
                            b = JSDraw2.BONDTYPES.SINGLE;
                            break;
                    }
                    break;
                case 2:
                    b = stereo == 3 ? JSDraw2.BONDTYPES.EITHER : JSDraw2.BONDTYPES.DOUBLE;
                    break;
                case 3:
                    b = JSDraw2.BONDTYPES.TRIPLE;
                    break;
                case 4:
                    b = JSDraw2.BONDTYPES.DELOCALIZED;
                    break;
                case 5:
                    b = JSDraw2.BONDTYPES.SINGLEORDOUBLE;
                    break;
                case 6:
                    b = JSDraw2.BONDTYPES.SINGLEORAROMATIC;
                    break;
                case 7:
                    b = JSDraw2.BONDTYPES.DOUBLEORAROMATIC;
                    break;
                case 8:
                    b = JSDraw2.BONDTYPES.UNKNOWN;
                    break;
                case 9:
                    b = JSDraw2.BONDTYPES.DUMMY;
                    break;
            }
            var bond = new JSDraw2.Bond(a1, a2, b);
            if (ring == 1)
                bond.ring = true;
            else if (ring == 2)
                bond.ring = false;
            if (rxn)
                this.readRxnCenter(bond, rcenter);
            this._addBond(bond);
        }

        var sgroups = [];
        start += nbonds;
        for (var i = start; i < lines.length; ++i) {
            var s = scil.Utils.rtrim(lines[i]);
            var token = s.length >= 6 ? s.substr(0, 6) : null;
            var token3 = s.length >= 6 ? s.substr(0, 3) : null;
            if (token == "M  ISO") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = parseInt(s.substr(10 + k * 8, 3));
                    var v = parseInt(s.substr(14 + k * 8, 3));
                    if (isNaN(ai) || isNaN(v))
                        return null;
                    this.atoms[ai - 1].isotope = v;
                }
            }
            else if (token == "M  RAD") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = parseInt(s.substr(10 + k * 8, 3));
                    var v = parseInt(s.substr(14 + k * 8, 3));
                    if (isNaN(ai) || isNaN(v))
                        return null;
                    if (v >= 1 && v <= 3)
                        this.atoms[ai - 1].radical = v;
                }
            }
            else if (token == "M  CHG") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = parseInt(s.substr(10 + k * 8, 3));
                    var v = parseInt(s.substr(14 + k * 8, 3));
                    if (isNaN(ai) || isNaN(v))
                        return null;
                    this.atoms[ai - 1].charge = v;
                }
            }
            else if (token == "M  ALS") {
                //M  ALS   7  4 F C   N   S   O 
                var ai = parseInt(s.substr(7, 3));
                var n = parseInt(s.substr(10, 3));
                var f = s.substr(14, 1) == "F";
                var list = [];
                for (var k = 0; k < n; ++k) {
                    var el = scil.Utils.trim(s.substr(16 + k * 4, 4));
                    if (JSDraw2.PT.isValidAtomList(el))
                        list.push(el);
                }
                var a = this.atoms[ai - 1];
                if (a.query == null)
                    a.query = {};
                a.query.t = f;
                a.query.als = list;
            }
            else if (token == "M  SUB") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = s.substr(9 + 8 * k + 1, 3);
                    var v = parseInt(s.substr(9 + 8 * k + 5, 3));
                    var a = this.atoms[ai - 1];
                    if (a.query == null)
                        a.query = {};
                    if (v == -1)
                        a.query.sub = 0;
                    else if (v == -2)
                        a.query.sub = "*";
                    else
                        a.query.v = v;
                }
            }
            else if (token == "M  UNS") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = s.substr(9 + 8 * k + 1, 3);
                    var v = parseInt(s.substr(9 + 8 * k + 5, 3));
                    var a = this.atoms[ai - 1];
                    if (a.query == null)
                        a.query = {};
                    a.query.uns = v == 1;
                }
            }
            else if (token == "M  RBC") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = s.substr(9 + 8 * k + 1, 3);
                    var v = parseInt(s.substr(9 + 8 * k + 5, 3));
                    var a = this.atoms[ai - 1];
                    if (v == -1 || v > 0) {
                        if (a.query == null)
                            a.query = {};
                        a.query.rbc = v == -1 ? 0 : v;
                    }
                }
            }
            else if (token == "M  RGP") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = parseInt(s.substr(10 + k * 8, 3));
                    var rr = parseInt(s.substr(14 + k * 8, 3));
                    if (isNaN(ai) || isNaN(rr))
                        return null;
                    if (this.atoms[ai - 1].elem == "R") {
                        var a = this.atoms[ai - 1];
                        if (a.alias == null || a.alias == "")
                            a.alias = "R" + rr;
                        if (rAtoms != null)
                            rAtoms[rr] = a;
                    }
                }
            }
            else if (token == "M  APO") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ai = parseInt(s.substr(10 + k * 8, 3));
                    var rr = parseInt(s.substr(14 + k * 8, 3));
                    if (!isNaN(ai) && !isNaN(rr) && this.atoms[ai - 1] != null)
                        this.atoms[ai - 1].attachpoints.push(rr);
                }
            }
            else if (token == "M  STY") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var si = parseInt(s.substr(10 + k * 8, 3));
                    var sn = s.substr(14 + k * 8, 3);
                    var br = null;
                    if (sn == "DAT") {
                        br = new JSDraw2.Text();
                    }
                    else if (sn == "SUP") {
                        br = { type: "SUPERATOM", atoms: [] };
                    }
                    else {
                        for (var ty in JSDraw2.SGroup.stys) {
                            if (JSDraw2.SGroup.stys[ty] == sn) {
                                br = new JSDraw2.Bracket(ty == "" ? null : ty, null);
                                break;
                            }
                        }
                        if (br == null)
                            br = new JSDraw2.Bracket(null, null);
                    }
                    if (br != null)
                        sgroups[si] = br;
                }
            }
            else if (token == "M  SMT") {
                var si = parseInt(s.substr(7, 3));
                var sa = s.substr(11);
                if (sa.length > 0 && sa.substr(0, 1) == "^")
                    sa = sa.substr(1);
                sgroups[si].subscript = sa;
            }
            else if (token == "M  SCL") {
                var si = parseInt(s.substr(7, 3));
                sgroups[si].cls = s.substr(11);
            }
            else if (token == "M  SPL") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var ci = parseInt(s.substr(10 + k * 8, 3));
                    var pi = parseInt(s.substr(14 + k * 8, 3));
                    if (JSDraw2.Text.cast(sgroups[ci]) != null && JSDraw2.Bracket.cast(sgroups[pi]) != null)
                        sgroups[ci].anchors = [sgroups[pi]]; // text attached to bracket
                }
            }
            else if (token == "M  SCN") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var si = parseInt(s.substr(10 + k * 8, 3));
                    var conn = s.substr(14 + k * 8, 2);
                    if (JSDraw2.Bracket.cast(sgroups[si]) != null)
                        sgroups[si].conn = conn;
                }
            }
            else if (token == "M  SNC") {
                var n = parseInt(s.substr(6, 3));
                for (var k = 0; k < n; ++k) {
                    var si = parseInt(s.substr(10 + k * 8, 3));
                    var num = scil.Utils.trim(s.substr(14 + k * 8, 2));
                    if (JSDraw2.Bracket.cast(sgroups[si]) != null) {
                        if (sgroups[si].type == "c")
                            sgroups[si].type = "c" + num;
                        else if (sgroups[si].type == "mul")
                            sgroups[si].type = num + "";
                    }
                }
            }
            else if (token == "M  SAL") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                if (sg != null) {
                    var n = parseInt(s.substr(10, 3));
                    for (var k = 0; k < n; ++k) {
                        var ai = parseInt(s.substr(14 + k * 4, 3));
                        var a = this.atoms[ai - 1];
                        if (a != null) {
                            if (sg.type == "SUPERATOM")
                                sg.atoms.push(a);
                            else if (JSDraw2.Bracket.cast(sg) != null)
                                sg.atoms.push(a);
                            else if (JSDraw2.Text.cast(sg) != null)
                                sg.anchors.push(a);
                        }
                    }
                }
            }
            else if (token == "M  SPA") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                if (JSDraw2.Bracket.cast(sg) != null && sg.type == "mul") {
                    var n = parseInt(s.substr(10, 3));
                    for (var k = 0; k < n; ++k) {
                        var ai = parseInt(s.substr(14 + k * 4, 3));
                        var a = this.atoms[ai - 1];
                        if (a != null) {
                            if (sg.spa == null)
                                sg.spa = [];
                            sg.spa.push(a);
                        }
                    }
                }
            }
            else if (token == "M  SBL") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                var n = parseInt(s.substr(10, 3));
                for (var k = 0; k < n; ++k) {
                    var bi = parseInt(s.substr(14 + k * 4, 3));
                    var b = this.bonds[bi - 1];
                    if (b != null && JSDraw2.Text.cast(sg) != null)
                        sg.anchors.push(b);
                }
            }
            else if (token == "M  SDI") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                var n = parseInt(s.substr(10, 3));
                if (sg != null && n == 4) {
                    var p1 = new JSDraw2.Point(parseFloat(s.substr(13, 10)), -parseFloat(s.substr(23, 10)));
                    var p2 = new JSDraw2.Point(parseFloat(s.substr(33, 10)), -parseFloat(s.substr(43, 10)));
                    if (p1.isValid() && p2.isValid()) {
                        if (sg._rect == null)
                            sg._rect = new JSDraw2.Rect().set(p1, p2);
                        else
                            sg._rect.unionPoint(p1).unionPoint(p2);
                    }
                }
            }
            else if (token == "M  SDT") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                if (JSDraw2.Text.cast(sg) != null)
                    sg.fieldtype = scil.Utils.trim(s.substr(11, 30));
            }
            else if (token == "M  SDD") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                if (JSDraw2.Text.cast(sg) != null) {
                    var p = new JSDraw2.Point(parseFloat(s.substr(11, 10)), -parseFloat(s.substr(21, 10)));
                    if (p.isValid())
                        sg._rect = new JSDraw2.Rect(p.x, p.y, 0, 0);
                }
            }
            else if (token == "M  SED") {
                var si = parseInt(s.substr(7, 3));
                var sg = sgroups[si];
                if (JSDraw2.Text.cast(sg) != null)
                    sg.text = scil.Utils.trim(s.substr(11));
            }
            else if (token3 == "A  ") {
                var ai = parseInt(s.substr(3, 3));
                ++i;
                this.atoms[ai - 1].alias = scil.Utils.trim(lines[i]);
            }
            else if (token3 == "V  ") {
                var ai = parseInt(s.substr(3, 3));
                var v = scil.Utils.trim(s.substr(7));
                this.atoms[ai - 1].tag = v;
            }
            else if (token == "M  END") {
                break;
            }
        }

        this.readSgroups(sgroups, chiral);
        return this;
    },

    readSgroups: function (sgroups, chiral) {
        var superatoms = [];
        var brackets = [];
        var gap = this.medBondLength(1.56) / 2;
        for (var i = 0; i < sgroups.length; ++i) {
            // post-process sgroups
            var sg = sgroups[i];
            if (sg == null)
                continue;
            var br = JSDraw2.Bracket.cast(sg);
            if (sg._rect != null && (br != null || sg.text != null && sg.text != "")) {
                this.addGraphics(sg);
                if (br != null) {
                    if (br.getType() != "")
                    //this.setSgroup(br, "BRACKET_TYPE", br.getType(), br._rect.right() + gap / 4, br._rect.bottom() - gap);
                        this.setSgroup(br, "BRACKET_TYPE", br.subscript || br.getType(), br._rect.right() + gap / 4, br._rect.bottom() - gap);
                    else
                        brackets.push(br);
                    if (br.conn != null && br.conn != "")
                        this.setSgroup(br, "BRACKET_CONN", br.conn.toLowerCase(), br._rect.right() + gap / 4, br._rect.top - gap / 4);
                    JSDraw2.SuperAtoms.collapseRepeat(this, br);
                }
                else {
                    if (scil.Utils.endswith(sg.fieldtype, "_TYPE") && sg.fieldtype != "BRACKET_TYPE")
                        sg.fieldtype = "BRACKET_SUBTYPE";
                    else if (scil.Utils.endswith(sg.fieldtype, "_MOD"))
                        sg.fieldtype = "BRACKET_MOD";
                }
            }
            else if (sg.type == "SUPERATOM") {
                var na = new JSDraw2.Atom(null, "C");
                var m = new JSDraw2.Mol();
                superatoms.push({ a: na, m: m });
                m.atoms = sg.atoms;
                for (var k = 0; k < m.atoms.length; ++k)
                    scil.Utils.removeArrayItem(this.atoms, m.atoms[k]);

                var p = null;
                var apo = 0;
                for (var j = this.bonds.length - 1; j >= 0; --j) {
                    var b = this.bonds[j];
                    var f1 = scil.Utils.indexOf(m.atoms, b.a1);
                    var f2 = scil.Utils.indexOf(m.atoms, b.a2);
                    if (f1 >= 0 && f2 >= 0) {
                        m.bonds.splice(0, 0, b);
                        this.bonds.splice(j, 1);
                    }
                    else if (f1 >= 0) {
                        if (p == null)
                            p = b.a1.p.clone();
                        b.a1.attachpoints.push(++apo);
                        b.apo1 = apo;
                        b.a1 = na;
                    }
                    else if (f2 >= 0) {
                        if (p == null)
                            p = b.a2.p.clone();
                        b.a2.attachpoints.push(++apo);
                        b.apo2 = apo;
                        b.a2 = na;
                    }
                }

                na.p = p != null ? p : m.atoms[0].p.clone();
                na.superatom = m;
                na.alias = sg.subscript;
                switch (sg.cls) {
                    case "AminoAcid":
                    case "AA":
                        na.bio = { type: JSDraw2.BIO.AA };
                        na.elem = na.alias;
                        na.alias = null;
                        break;
                    case "BASE":
                    case "DNA":
                        na.bio = { type: JSDraw2.BIO.BASE_DNA };
                        na.elem = na.alias;
                        na.alias = null;
                        break;
                    case "RNA":
                        na.bio = { type: JSDraw2.BIO.BASE_RNA };
                        na.elem = na.alias;
                        na.alias = null;
                        break;
                }
                this._addAtom(na);
            }
        }

        for (var i = 0; i < brackets.length; ++i) {
            var br = brackets[i];
            var t = this.getSgroupText(br, "BRACKET_TYPE");
            if (t != null)
                brackets[i].type = t.text;

            if (br.atoms != null) {
                for (var k = 0; k < superatoms.length; ++k) {
                    var a = superatoms[k].a;
                    var m = superatoms[k].m;
                    if (scil.Utils.removeArrayItems(br.atoms, m.atoms) > 0)
                        br.atoms.push(a);
                }
            }
        }

        // set R groups: some R groups are only marked using alias
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.elem == "C" && a.alias != null && (/^R[0-9]+$/).test(a.alias)) {
                var alias = a.alias;
                a.alias = null;
                this.setAtomAlias(a, alias);
            }
        }

        if (JSDraw2.defaultoptions.and_enantiomer) {
            if (this.hasStereoCenter() && chiral == "  0")
                this.chiral = "and";
        }
    },

    hasRGroup: function () {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.elem == "R")
                return true;
        }
        return false;
    },

    /**
    * Get molfile
    * @function getMolfile
    * @param {bool} rxn - get it as a Rxn file
    * @param {bool} v3000 - render it in Molfile V3000 format
    * @returns a string
    */
    getMolfile: function (rxn, v3000, excludeDummyBonds) {
        if (v3000 == null) {
            if (this.needV3000())
                v3000 = true;
        }

        if (v3000)
            return this.getMolV3000(rxn);
        else
            return this.getMolV2000(rxn, excludeDummyBonds);
    },

    needV3000: function () {
        return this.atoms.length > 999 || this.bonds.length > 999 || this.hasEnhancedStereochemistry();
    },

    getRgfile: function (rxn, rgroups, superatoms) {
        return null;
    },

    _getRgroups: function (rgroups) {
        if (rgroups == null)
            rgroups = { n: 0, list: [] };

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            a.iR = null;
            if (a.elem == "R" && (a.alias != null && a.alias != "" || a.rgroup != null)) {
                a.iR = ++rgroups.n;
                if (a.rgroup != null && a.rgroup.mols.length > 0)
                    rgroups.list.push(a);
            }
        }
        return rgroups;
    },

    getSubMol: function (atoms) {
        var m = this;
        var set = { atoms: scil.clone(atoms), bonds: [], openbonds: [] };
        for (var j = 0; j < m.bonds.length; ++j) {
            var b = m.bonds[j];
            var f1 = scil.Utils.indexOf(atoms, b.a1) >= 0;
            var f2 = scil.Utils.indexOf(atoms, b.a2) >= 0;
            if (f1 && f2) {
                //if (scil.Utils.indexOf(set.atoms, b.a1) < 0)
                //    set.atoms.push(b.a1);
                //if (scil.Utils.indexOf(set.atoms, b.a2) < 0)
                //    set.atoms.push(b.a2);
                set.bonds.push(b);
            }
            else if (f1) {
                //if (scil.Utils.indexOf(set.atoms, b.a1) < 0)
                //    set.atoms.push(b.a1);
                set.openbonds.push({ b: b, oa: b.a2 });
            }
            else if (f2) {
                //if (scil.Utils.indexOf(set.atoms, b.a2) < 0)
                //    set.atoms.push(b.a2);
                set.openbonds.push({ b: b, oa: b.a1 });
            }
        }

        return set;
    },

    expandSuperAtoms: function (superatoms2) {
        superatoms = [];

        var m = this.clone(null);
        var list = scil.clone(m.atoms);
        for (var i = 0; i < list.length; ++i) {
            var a = list[i];
            if (a.superatom != null) {
                var m2 = JSDraw2.SuperAtoms.addToMol(m, a, a.superatom);
                superatoms.push({ a: a, m: m2 });
                if (superatoms2 != null)
                    superatoms2.push({ a: a, m: m2 });
            }
            else if (a.elem == "5'") {
                m.setAtomType(a, "H");
            }
            else if (a.elem == "3'") {
                m.setAtomType(a, "O");
            }
        }

        for (var i = 0; i < m.graphics.length; ++i) {
            var br = JSDraw2.Bracket.cast(m.graphics[i]);
            if (br == null)
                continue;

            if (br.atoms != null && superatoms != null) {
                var atoms = [];
                var m2 = null;
                for (var k = 0; k < br.atoms.length; ++k) {
                    for (var j = 0; j < superatoms.length; ++j) {
                        if (br.atoms[k] == superatoms[j].a) {
                            m2 = superatoms[j].m;
                            break;
                        }
                    }
                    if (m2 == null) {
                        atoms.push(br.atoms[k]);
                    }
                    else {
                        for (var j = 0; j < m2.atoms.length; ++j)
                            atoms.push(m2.atoms[j]);
                    }
                }
                br.atoms = atoms;
            }

            JSDraw2.SuperAtoms.expandRepeat(m, br);
        }

        m.calcHCount(true);
        return m;
    },

    getMolV2000: function (rxn, excludeDummyBonds) {
        var superatoms = [];
        var m = this.expandSuperAtoms(superatoms);
        m.chiral = this.chiral;

        if (excludeDummyBonds) {
            for (var i = m.bonds.length - 1; i >= 0; --i) {
                var b = m.bonds[i];
                if (b.type == JSDraw2.BONDTYPES.DUMMY)
                    m.bonds.splice(i, 1);
            }
        }

        var hasRgroup = false;
        var rgroups = m._getRgroups();
        if (rgroups.list.length > 0)
            return m.getRgfile(rxn, rgroups, superatoms);

        var s = (m.name == null ? "" : m.name) + '\n';
        s += m._getMolHeader();
        s += "\n";
        s += m._getMolV2000(rxn, null, superatoms);
        return s;
    },

    allAtoms: function (list) {
        if (list == null)
            list = [];
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            list.push(a);
            if (a.rgroup != null) {
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].allAtoms(list);
            }
        }
        return list;
    },

    allBonds: function (list) {
        if (list == null)
            list = [];
        for (var i = 0; i < this.bonds.length; ++i)
            list.push(this.bonds[i]);

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.rgroup != null) {
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].allBonds(list);
            }
        }
        return list;
    },

    _getMolTime: function () {
        var dt = new Date();
        var yr = dt.getFullYear() + "";
        return scil.Utils.formatStr(dt.getMonth() + 1, 2, 0).replace(' ', '0') +
            scil.Utils.formatStr(dt.getDate(), 2, 0).replace(' ', '0') +
            yr.substr(2) +
            scil.Utils.formatStr(dt.getHours(), 2, 0).replace(' ', '0') +
            scil.Utils.formatStr(dt.getMinutes(), 2, 0).replace(' ', '0');
    },

    _getMolHeader: function () {
        var dt = new Date();
        var yr = dt.getFullYear() + "";
        return "   JSDraw2" + this._getMolTime() + "2D\n";
    },

    _getMolV2000: function (rxn, rgroups, superatoms) {
        if (rgroups != null)
            this._getRgroups(rgroups);

        var len = this.bondlength > 0 ? this.bondlength : this.medBondLength();
        var scale = len > 0 ? (1.56 / len) : 1.0;

        var s = "";
        s += scil.Utils.formatStr(this.atoms.length, 3, 0);
        s += scil.Utils.formatStr(this.bonds.length, 3, 0);
        s += "  0  0";
        if (this.hasStereoCenter() && this.chiral != "and")
            s += "  1";
        else
            s += "  0";
        s += "  0              0 V2000\n";

        var isotopes = "";
        var radicals = "";
        var tags = "";
        var query = "";
        var rgp = "";
        var apo = "";
        var astr = "";
        this.resetIds();
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.isotope != null)
                isotopes += "M  ISO" + "  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(a.isotope, 4, 0) + "\n";
            if (a.radical >= 1 && a.radical <= 3)
                radicals += "M  RAD  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(a.radical, 4, 0) + "\n";
            if (a.tag != null && a.tag != "")
                tags += "V  " + scil.Utils.formatStr(i + 1, 3, 0) + " " + a.tag + "\n";
            if (a.alias != null && a.alias != "")
                astr += "A  " + scil.Utils.formatStr(i + 1, 3, 0) + "\n" + a.alias + "\n";
            for (var k = 0; k < a.attachpoints.length; ++k)
                apo += "M  APO  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(a.attachpoints[k], 4, 0) + "\n";
            if (a.query != null) {
                if (a.query.als != null && a.query.als.length > 0) {
                    query += "M  ALS " + scil.Utils.formatStr(i + 1, 3, 0) + scil.Utils.formatStr(a.query.als.length, 3, 0) + (a.query.t == false ? " T " : " F ");
                    for (var k = 0; k < a.query.als.length; ++k)
                        query += scil.Utils.padright(a.query.als[k], 4, ' ');
                    query += "\n";
                }
                if (a.query.rbc != null)
                    query += "M  RBC  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(a.query.rbc == 0 ? -1 : a.query.rbc, 4, 0) + "\n";
                if (a.query.uns != null)
                    query += "M  UNS  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(a.query.uns ? 1 : 0, 4, 0) + "\n";
                if (a.query.sub != null)
                    query += "M  SUB  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(a.query.sub == 0 ? -1 : (a.query.sub == '*' ? -2 : a.query.sub), 4, 0) + "\n";
            }

            var elem = a.elem;
            if (a.elem == "R") {
                if (a.iR > 0) {
                    elem = "R#";
                    rgp += "M  RGP  1" + scil.Utils.formatStr(i + 1, 4, 0) + scil.Utils.formatStr(parseInt(a.iR), 4, 0) + "\n";
                }
                else {
                    elem = "R";
                }
            }
            else if (elem == "H") {
                if (a.isotope == 2)
                    elem = "D";
                else if (a.isotope == 3)
                    element = "T";
            }

            s += scil.Utils.formatStr(a.p.x * scale, 10, 4);
            s += scil.Utils.formatStr(-a.p.y * scale, 10, 4);
            s += scil.Utils.formatStr(0, 10, 4);
            s += ' ';
            s += scil.Utils.padright(elem, 2, ' ');
            s += '  0';
            var c = 0;
            switch (a.charge) {
                case 1:
                    c = 3;
                    break;
                case 2:
                    c = 2;
                    break;
                case 3:
                    c = 1;
                    break;
                case -1:
                    c = 5;
                    break;
                case -2:
                    c = 6;
                    break;
                case -3:
                    c = 7;
                    break;
            }
            s += scil.Utils.formatStr(c, 3, 0);

            s += "  0";
            if (a.hs > 0)
                s += scil.Utils.formatStr(a.hs, 3, 0);
            else
                s += "  0";

            s += "  0  0";
            if (a.val > 0)
                s += scil.Utils.formatStr(a.val, 3, 0);
            else
                s += "  0";

            s += "  0  0";
            if (rxn && a.atommapid > 0)
                s += scil.Utils.formatStr(a.atommapid, 3, 0);
            else
                s += "  0";
            s += '  0  0\n';
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];

            s += scil.Utils.formatStr(b.a1.id, 3, 0);
            s += scil.Utils.formatStr(b.a2.id, 3, 0);

            var order = 0;
            var stereo = 0;
            switch (b.type) {
                case JSDraw2.BONDTYPES.UNKNOWN:
                    order = 8;
                    break;
                case JSDraw2.BONDTYPES.DUMMY:
                    order = 9;
                    break;
                case JSDraw2.BONDTYPES.DOUBLEORAROMATIC:
                    order = 7;
                    break;
                case JSDraw2.BONDTYPES.SINGLEORAROMATIC:
                    order = 6;
                    break;
                case JSDraw2.BONDTYPES.SINGLEORDOUBLE:
                    order = 5;
                    break;
                case JSDraw2.BONDTYPES.SINGLE:
                case JSDraw2.BONDTYPES.DOUBLE:
                case JSDraw2.BONDTYPES.TRIPLE:
                case JSDraw2.BONDTYPES.DELOCALIZED:
                    order = b.type;
                    stereo = 0;
                    break;
                case JSDraw2.BONDTYPES.PEPTIDE:
                case JSDraw2.BONDTYPES.NUCLEOTIDE:
                case JSDraw2.BONDTYPES.DISULFIDE:
                case JSDraw2.BONDTYPES.AMIDE:
                    order = 1;
                    stereo = 0;
                    break;
                case JSDraw2.BONDTYPES.WEDGE:
                case JSDraw2.BONDTYPES.BOLD:
                    order = 1;
                    stereo = 1;
                    break;
                case JSDraw2.BONDTYPES.HASH:
                case JSDraw2.BONDTYPES.BOLDHASH:
                    order = 1;
                    stereo = 6;
                    break;
                case JSDraw2.BONDTYPES.WIGGLY:
                    order = 1;
                    stereo = 4;
                    break;
                case JSDraw2.BONDTYPES.EITHER:
                    order = 2;
                    stereo = 3;
                    break;
            }
            s += scil.Utils.formatStr(order, 3, 0);
            s += scil.Utils.formatStr(stereo, 3, 0);
            s += scil.Utils.formatStr(0, 3, 0);
            if (b.ring != null)
                s += scil.Utils.formatStr(b.ring ? 1 : 2, 3, 0);
            else
                s += scil.Utils.formatStr(0, 3, 0);
            s += scil.Utils.formatStr(b.rcenter == null ? 0 : b.rcenter, 3, 0);
            s += "\n";
        }

        s += isotopes;
        s += radicals;
        s += tags;
        s += astr;
        s += query;
        s += rgp;
        s += apo;

        var nSTY = 0;
        if (superatoms != null) {
            for (var i = 0; i < superatoms.length; ++i) {
                var a = superatoms[i].a;
                var m = superatoms[i].m;
                if (m == null)
                    continue;

                ++nSTY;
                var sty = scil.Utils.formatStr(nSTY, 3, 0);
                s += "M  STY  1 " + sty + " SUP\n";
                s += this.writeList("M  SAL " + sty, m.atoms, "id", 4, 8);
                s += this.writeList("M  SBL " + sty, m.bonds, "bondid", 4, 8);

                s += "M  SMT " + sty + " " + (a.alias == null ? a.elem : a.alias) + "\n";
                if (a.bio != null)
                    s += "M  SCL " + sty + " " + a.biotype() + "\n";
            }
        }

        var texts = [];
        for (var i = 0; i < this.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t != null)
                texts.push(t);
        }

        // SGroup
        var sgroupdata = "";
        var id = { k: nSTY };
        var brackets = [];
        for (var i = 0; i < this.graphics.length; ++i) {
            var br = JSDraw2.Bracket.cast(this.graphics[i]);
            if (br == null)
                continue;
            brackets.push(br);
            var r = br._rect;

            var bracketatoms = null;
            var bracketbonds = null;
            if (br.atoms.length > 0) {
                bracketatoms = this.getExpandedAtoms(br.expandedatoms == null ? br.atoms : br.expandedatoms);
                bracketbonds = br.getXbonds(this);
            }

            var k = ++id.k;
            var connectivity = null;
            var sgroup = { sty: "", spl: "", data: "", id: id };
            var tp = br.getType();
            var snc = br.getTypeNum();
            sgroup.subscript = tp;

            var type = JSDraw2.SGroup.stys[tp];
            if (type == null) {
                if (bracketbonds != null && bracketbonds.length == 2)
                    type = "SRU";
                else
                    type = "GEN";
            }
            sgroup.sty += " " + scil.Utils.formatStr(k, 3, 0) + " " + type;
            var fieldtype = JSDraw2.SGroup.fieldtypes[tp];
            if (fieldtype == null)
                fieldtype = "BRACKET";
            var custom = type == null;

            var subscript = null;
            for (var j = 0; j < texts.length; ++j) {
                var t = texts[j];
                if (t != null && t.anchors.length == 1 && t.anchors[0] == br) {
                    if (t.fieldtype == "BRACKET_CONN") {
                        connectivity = t.text;
                    }
                    else if (t.fieldtype != "BRACKET_TYPE" || t.text != tp && tp != "mul" || custom) {
                        var ft = t.fieldtype;
                        if (fieldtype != null && ft != null && ft.length > 8 && ft.substr(0, 8) == "BRACKET_") {
                            if (ft == "BRACKET_SUBTYPE")
                                ft = fieldtype + "_TYPE";
                            else
                                ft = fieldtype + ft.substr(7);
                        }

                        if (type == "SRU")
                            sgroup.subscript = t.text;
                        else
                            this.getDataGroup(t.text, ft, t._rect.left * scale, -t._rect.top * scale, k, sgroup);
                    }
                    else if (t.fieldtype == "BRACKET_TYPE" && tp == "mul") {
                        subscript = t.text;
                    }
                    texts[j] = null;
                }
            }

            sgroupdata += "M  STY" + scil.Utils.formatStr(sgroup.sty.length / 8, 3, 0) + sgroup.sty + "\n";
            //sgroupdata += "M  SLB  1   1   1\n";

            if (connectivity == "ht" || connectivity == "hh" || connectivity == "eu")
                sgroupdata += "M  SCN" + scil.Utils.formatStr(1, 3, 0) + " " + scil.Utils.formatStr(k, 3, 0) + " " + connectivity.toUpperCase() + " \n";
            if (snc != null)
                sgroupdata += "M  SNC" + scil.Utils.formatStr(1, 3, 0) + " " + scil.Utils.formatStr(k, 3, 0) + " " + scil.Utils.padLeft(snc, 3, ' ') + " \n";
            if (sgroup.spl != "")
                sgroupdata += "M  SPL" + scil.Utils.formatStr(sgroup.spl.length / 8, 3, 0) + sgroup.spl + "\n";
            if (br.atoms.length > 0) {
                sgroupdata += this.writeList("M  SAL " + scil.Utils.formatStr(k, 3, 0), bracketatoms, "id", 4, 8);
                sgroupdata += this.writeList("M  SBL " + scil.Utils.formatStr(k, 3, 0), bracketbonds, "id", 4, 8);

                if (!scil.Utils.isNullOrEmpty(sgroup.subscript) && /* I#10773 */!(type == "MUL" && sgroup.subscript == "mul"))
                    sgroupdata += "M  SMT   1 " + sgroup.subscript + "\n";

                atoms = br.atoms;
                if (br.type != "n" || type == "SRU")
                    sgroupdata += this.writeList("M  SPA " + scil.Utils.formatStr(k, 3, 0), atoms, "id", 4, 8);
            }

            sgroupdata += "M  SDI " + scil.Utils.formatStr(k, 3, 0) + "  4";
            sgroupdata += scil.Utils.formatStr(br._rect.left * scale, 10, 4);
            sgroupdata += scil.Utils.formatStr(-br._rect.bottom() * scale, 10, 4);
            sgroupdata += scil.Utils.formatStr(br._rect.left * scale, 10, 4);
            sgroupdata += scil.Utils.formatStr(-br._rect.top * scale, 10, 4);
            sgroupdata += "\n";

            sgroupdata += "M  SDI " + scil.Utils.formatStr(k, 3, 0) + "  4";
            sgroupdata += scil.Utils.formatStr(br._rect.right() * scale, 10, 4);
            sgroupdata += scil.Utils.formatStr(-br._rect.top * scale, 10, 4);
            sgroupdata += scil.Utils.formatStr(br._rect.right() * scale, 10, 4);
            sgroupdata += scil.Utils.formatStr(-br._rect.bottom() * scale, 10, 4);
            sgroupdata += "\n";

            if (subscript != null && subscript != "") {
                sgroupdata += "M  SMT " + scil.Utils.formatStr(k, 3, 0) + " " + subscript;
                sgroupdata += "\n";
            }

            sgroupdata += sgroup.data;
        }

        for (var i = 0; i < texts.length; ++i) {
            var t = texts[i];
            if (t == null)
                continue;

            var k = id.k;
            var sgroup = { sty: "", spl: "", data: "", id: id };
            this.getDataGroup(t.text, t.fieldtype, t._rect.left * scale, -t._rect.top * scale, null, sgroup);
            sgroupdata += "M  STY" + scil.Utils.formatStr(sgroup.sty.length / 8, 3, 0) + sgroup.sty + "\n";

            // I#11604
            if (id.k == k)
                ++id.k;
            k = id.k;

            var sal = "";
            var sbl = "";
            for (var j = 0; j < t.anchors.length; ++j) {
                var a = t.anchors[j];
                if (JSDraw2.Atom.cast(a) != null)
                    sal += " " + scil.Utils.formatStr(a.atomid, 3, 0);
                else if (JSDraw2.Bond.cast(a) != null)
                    sbl += " " + scil.Utils.formatStr(a.bondid, 3, 0);
            }
            if (sal != "")
                sgroupdata += "M  SAL " + scil.Utils.formatStr(k, 3, 0) + scil.Utils.formatStr(sal.length / 4, 3, 0) + sal + "\n";
            if (sbl != "")
                sgroupdata += "M  SBL " + scil.Utils.formatStr(k, 3, 0) + scil.Utils.formatStr(sbl.length / 4, 3, 0) + sbl + "\n";

            sgroupdata += sgroup.data;
        }

        s += sgroupdata;
        s += "M  END\n";
        return s;
    },

    getExpandedAtoms: function (atoms) {
        var ret = [];
        for (var i = 0; i < atoms.length; ++i) {
            var a = atoms[i];
            if (a.superatom == null) {
                ret.push(a);
            }
            else {
                for (var k = 0; k < a.superatom.atoms.length; ++k)
                    ret.push(a.superatom.atoms[i]);
            }
        }
        return ret;
    },

    writeList: function (prefix, list, key, chars, countperline) {
        if (list == null || list.Length == 0)
            return "";

        var s = "";
        countlastline = list.length % countperline;
        if (countlastline == 0)
            countlastline = countperline;
        lines = (list.length - countlastline) / countperline + 1;

        for (var i = 0; i < lines; ++i) {
            var countthisline = i + 1 == lines ? countlastline : countperline;
            s += prefix;
            s += scil.Utils.formatStr(countthisline, 3);
            for (var j = 0; j < countthisline; ++j)
                s += scil.Utils.formatStr(list[i * countperline + j][key], chars);
            s += "\n";
        }

        return s;
    },

    getMolV3000: function (rxn) {
        var superatoms = [];
        var m = this.expandSuperAtoms(superatoms);
        m.chiral = this.chiral;
        return m._getMolV3000();
    },

    _getMolV3000: function (rxn) {
        return null;
    },

    hasStereoCenter: function () {
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.type == JSDraw2.BONDTYPES.WEDGE || b.type == JSDraw2.BONDTYPES.HASH)
                return true;
        }

        return false;
    },

    hasEnhancedStereochemistry: function () {
        return false;
    },

    getEnhancedStereochemistry: function () {
        return "";
    },

    setMolV3000: function (lines, start, rxn, pos, endtoken) {
        return this;
    },

    readV30Collections: function (lines, i, atommap) {
    },

    readV30Bonds: function (lines, i, atommap, rxn) {
    },

    getChiralAtom: function (t) {
        if (t == null || t.anchors == null || t.anchors.length != 1 || t.fieldtype != "CHIRAL")
            return null;
        var a = JSDraw2.Atom.cast(t.anchors[0]);
        if (a == null)
            return null;
        return JSDraw2.Atom.isValidChiral(t.text) ? a : null;
    },

    markChirality: function (a, c, bondlength) {
        return false;
    },

    findBestPostion: function (a, bondlength) {
        var atoms = a._parent.getNeighborAtoms(a);
        var p = a.p.clone();
        if (atoms != null && atoms.length > 0) {
            var deg = atoms[0].p.angleTo(a.p);
            p.offset(bondlength * 0.37, 0);
            p.rotateAround(a.p, deg - 60);

            p.x -= bondlength * 0.25;
            p.y -= bondlength * 0.25;
        }
        else {
            p.x -= bondlength * 0.25;
            p.y -= bondlength * 0.75;
        }
        return p;
    },

    readRxnCenter: function (bond, s) {
        var rcenter = s == null ? null : parseInt(s);
        switch (rcenter) {
            case -1:
                bond.rcenter = JSDraw2.RXNCENTER.NOTCENTER;
                break;
            case 1:
                bond.rcenter = JSDraw2.RXNCENTER.CENTER;
                break;
            case 12:
            case 13:
                bond.rcenter = JSDraw2.RXNCENTER.BREAKANDCHANGE;
                break;
            case 4:
            case 5:
                bond.rcenter = JSDraw2.RXNCENTER.BREAK;
                break;
            case 8:
            case 9:
                bond.rcenter = JSDraw2.RXNCENTER.CHANGE;
                break;
        }
    },

    readV30Atoms: function (lines, i, atommap, rxn) {

    },

    readV30Counts: function (lines, i, counts) {

    },

    parseV30Attributes: function (ss, start) {
        return null;
    },

    getDataGroup: function (data, key, x, y, k2, sgroup) {

    },

    containsWord: function (word) {
        word = word.toLowerCase();
        for (var i = 0; i < this.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t != null && scil.Utils.containsWord(t.text, word, true))
                return true;
        }
        return false;
    },

    containsText: function (s) {
        s = s.toLowerCase();
        for (var i = 0; i < this.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t != null && t.text != null && t.text.toLowerCase().indexOf(s) >= 0)
                return true;
        }
        return false;
    },

    /**
    * Get Mol property
    * @function getProp
    * @param {string} k - the property name
    * @returns the property
    */
    getProp: function (k) {
        return this.props == null ? null : this.props[k];
    },

    /**
    * Set Mol property
    * @function setProp
    * @param {string} k - the property name
    * @param {object} v - the property value
    * @returns null
    */
    setProp: function (k, v) {
        if (v == null) {
            if (this.props != null)
                delete this.props[k];
        }
        else {
            if (this.props == null)
                this.props = {};
            this.props[k] = v + "";
        }
    },

    /**
    * Set RGfile
    * @function setRgfile
    * @param {string} rgfile - the input rgfile
    * @returns the Mol object
    */
    setRgfile: function (rgfile) {
        return null;
    },

    _setParent: function (m) {
        for (var i = 0; i < this.atoms.length; ++i)
            this.atoms[i]._parent = m;
        for (var i = 0; i < this.bonds.length; ++i)
            this.bonds[i]._parent = m;
        for (var i = 0; i < this.graphics.length; ++i)
            this.graphics[i]._parent = m;
    },

    _setGroup: function (g) {
        for (var i = 0; i < this.atoms.length; ++i)
            this.atoms[i].group = g;
        for (var i = 0; i < this.bonds.length; ++i)
            this.bonds[i].group = g;
    },

    toggleAtom: function (p, tor) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.toggle(p, tor))
                return a;

            if (a.rgroup != null) {
                var list = a.rgroup.mols;
                for (var j = 0; j < list.length; ++j) {
                    var r = list[j].toggleAtom(p, tor);
                    if (r != null)
                        return r;
                }
            }
        }
        return null;
    },

    toggle: function (p, tor) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            if (a.toggle(p, tor))
                return a;

            if (a.rgroup == null)
                continue;

            if (a.rgroup.toggle(p, tor))
                return a.rgroup;

            var list = a.rgroup.mols;
            for (var j = 0; j < list.length; ++j) {
                var r = list[j].toggle(p, tor);
                if (r != null)
                    return r;
            }
        }

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.toggle(p, tor))
                return this.bonds[i];
        }

        for (var i = this.graphics.length - 1; i >= 0; --i) {
            var g = this.graphics[i];
            if (g.toggle(p, tor))
                return this.graphics[i];
        }
        return null;
    },

    /**
    * Set Rxnfile
    * @function setRxnfile
    * @param {string} rxnfile - the input rxnfile
    * @returns the Mol object
    */
    setRxnfile: function (rxnfile) {
        return this;
    },

    setRxnV3000: function (lines) {
        return this;
    },

    readCtabs: function (lines, i, n, list, endtoken) {
        for (var k = 0; k < n; ++k) {
            var m = new JSDraw2.Mol();
            var pos = {};
            m.setMolV3000(lines, i, true, pos, endtoken);
            i = pos.i;
            if (!m.isEmpty())
                list.push(m);
        }
        return i;
    },

    setRxnV2000: function (lines) {
        return this;
    },

    setRxn: function (rxn, bondlength) {
        return this;
    },

    /**
    * Get Rxnfile
    * @function getRxnfile
    * @param {bool} groupbyplus - indicate if grouping reactants/products by explicit plus signs
    * @param {bool} v3000 - indicate if rendering the rxnfile in V3000 format
    * @returns a string
    */
    getRxnfile: function (groupbyplus, v3000) {
        var rxn = this.parseRxn(true, groupbyplus);
        if (rxn == null)
            return null;

        if (v3000)
            return this.getRxnV3000(rxn);
        else
            return this.getRxnV2000(rxn);
    },

    getAllBrackets: function () {
        var list = [];
        for (var j = 0; j < this.graphics.length; ++j) {
            var b = this.graphics[j];
            if (JSDraw2.Bracket.cast(b) != null)
                list.push(b);
        }
        return list;
    },

    getAllTexts: function () {
        var list = [];
        for (var j = 0; j < this.graphics.length; ++j) {
            var b = this.graphics[j];
            if (JSDraw2.Text.cast(b) != null)
                list.push(b);
        }
        return list;
    },

    getRxnV2000: function (rxn) {
        return null;
    },

    getRxnV3000: function (rxn, groupbyplus) {
        return null;
    },

    /**
    * Get JSDraw xml file format
    * @function getXml
    * @param {number} width - the width of the view
    * @param {number} height - the height of the view
    * @param {bool} viewonly - in viewonly mode
    * @returns a string
    */
    getXml: function (width, height, viewonly, svg, len) {
        return this._getXml(width, height, viewonly, svg, len);
    },

    getHtml: function (width, height, viewonly, svg, len) {
        return this.getXml(width, height, viewonly, svg, len);
    },

    _getXml: function (width, height, viewonly, svg, len, inside) {
        return null;
    },

    /**
    * Set Secptrum JDX data
    * @function setJdx
    * @param {string} data - JDX string
    * @returns a Mol object
    */
    setJdx: function (data, bondlength) {
        return this;
    },

    /**
    * Set JSDraw xml file format
    * @function setXml
    * @param {string} xml - the input JSDraw html/xml string
    * @returns a Mol object
    */
    setXml: function (xml) {
        return this;
    },

    setHtml: function (xml) {
        return this.setXml(xml);
    },

    toScreen: function (screenBondLength) {
        var len = this.medBondLength();
        if (!(len > 0))
            len = 1.56;

        var scale = screenBondLength / len;
        this.scale(scale);
        return scale;
    },

    /**
    * Scale the molecule
    * @function scale
    * @param {number} scale - the scaling factor
    * @param {Point} origin - the origin of scaling
    * @returns null
    */
    scale: function (scale, origin) {
        if (!(scale > 0))
            return;

        for (var i = 0; i < this.atoms.length; ++i) {
            var a = this.atoms[i];
            a.p.scale(scale, origin);
            if (a.rgroup != null) {
                if (a.rgroup != null)
                    a.rgroup.scale(scale, origin);
                for (var j = 0; j < a.rgroup.mols.length; ++j)
                    a.rgroup.mols[j].scale(scale, origin);
            }
        }

        for (var i = 0; i < this.graphics.length; ++i)
            this.graphics[i].scale(scale, origin);
    },

    /**
    * Flip the molecule around an X axis
    * @function flipX
    * @param {number} x - the x axis
    * @returns null
    */
    flipX: function (x) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var p = this.atoms[i].p;
            p.x = x - (p.x - x);
        }
        for (var i = 0; i < this.graphics.length; ++i)
            this.graphics[i].flipX(x);
    },

    /**
    * Flip the molecule around a Y axis
    * @function flipY
    * @param {number} y - the y axis
    * @returns null
    */
    flipY: function (y) {
        for (var i = 0; i < this.atoms.length; ++i) {
            var p = this.atoms[i].p;
            p.y = y - (p.y - y);
        }
        for (var i = 0; i < this.graphics.length; ++i)
            this.graphics[i].flipY(y);
    },

    clearFlag: function () {
        for (var i = 0; i < this.atoms.length; ++i) {
            this.atoms[i].f = null;
            this.atoms[i].ringclosures = null;
        }
        for (var i = 0; i < this.bonds.length; ++i)
            this.bonds[i].f = null;
    },

    _connectFragsByPlus: function (frags, bondlen) {
        return null;
    },

    _splitFrags: function (frags) {
        for (var i = 0; i < frags.length; ++i) {
            var ss = frags[i].splitFragments();
            if (ss.length > 0) {
                frags.splice(i, 1);
                for (var k = 0; k < ss.length; ++k)
                    frags.splice(i, 0, ss[k]);
                i += ss.length - 1;
            }
        }
    },

    _connectNextLine: function (frags, rect, above, arrow, bondlen) {
        return null;
    },

    detectRxn: function (arrow) {
        return null;
    },

    _findCloseTexts: function (t, texts, dy, ret) {
        for (var k = 0; k < texts.length; ++k) {
            var x = texts[k];
            if (x == null)
                continue;

            var r1 = t.rect();
            var r2 = x.rect();
            if (Math.abs(r1.top - r2.top) < dy || Math.abs(r1.top - r2.bottom()) < dy ||
                        Math.abs(r1.bottom() - r2.top) < dy || Math.abs(r1.bottom() - r2.bottom()) < dy) {
                var overlap = Math.min(r1.right(), r2.right()) - Math.max(r1.left, r2.left);
                if (overlap >= Math.min(r1.width, r2.width) / 2) {
                    ret.push(x);
                    texts[k] = null;
                }
            }
        }
    },

    parseRxn2: function () {
        return null;
    },

    /**
    * Test if the molecule is a reaction
    * @function isRxn
    * @returns true or false
    */
    isRxn: function () {
        return null;
    },

    _groupByPlus: function (rxn) {
        if (rxn == null)
            return rxn;

        var pluses = [];
        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i].T == 'PLUS')
                pluses.push(this.graphics[i]);
        }

        if (pluses.length == 0) {
            if (rxn.reactants.length > 1) {
                for (var i = 1; i < rxn.reactants.length; ++i)
                    rxn.reactants[0].mergeMol(rxn.reactants[i]);
                rxn.reactants = [rxn.reactants[0]];
            }
            if (rxn.products.length > 1) {
                for (var i = 1; i < rxn.products.length; ++i)
                    rxn.products[0].mergeMol(rxn.products[i]);
                rxn.products = [rxn.products[0]];
            }
        }
        else {
            // order by x
            var xx = [];
            for (var i = 0; i < pluses.length; ++i) {
                var x = pluses[i].p.x;
                var p = xx.length;
                for (var k = 0; k < xx.length; ++k) {
                    if (x < xx[k]) {
                        p = k;
                        break;
                    }
                }

                xx.splice(p, 0, x);
            }

            rxn.reactants = this._groupByPlus2(xx, rxn.reactants);
            rxn.products = this._groupByPlus2(xx, rxn.products);
        }
        return rxn;
    },

    _groupByPlus2: function (pluses, mols) {
        var list = [];
        var n = pluses.length;
        for (var i = 0; i < mols.length; ++i) {
            var m = mols[i];
            var cx = mols[i].center().x;
            var f = false;
            for (var k = 0; k < n; ++k) {
                if (cx < pluses[k]) {
                    if (list[k] == null)
                        list[k] = m;
                    else
                        list[k].mergeMol(m);
                    f = true;
                    break;
                }
            }

            if (!f) {
                if (list[n] == null)
                    list[n] = m;
                else
                    list[n].mergeMol(m);
            }
        }

        var ret = [];
        for (var i = 0; i < list.length; ++i) {
            if (list[i] != null)
                ret.push(list[i]);
        }
        return ret;
    },

    /**
    * Parse the molecule as a reaction
    * @function parseRxn
    * @returns a Reaction object: { reactants, products, arrow, above, below }
    */
    parseRxn: function (copygraphics, groupbyplus) {
        var rxn = this._parseRxn();
        if (groupbyplus)
            rxn = this._groupByPlus(rxn);

        //        if (rxn != null && copygraphics) {
        //            var brackets = this.getAllBrackets();
        //            var texts = this.getAllTexts();
        //            this._addGraphicsRxnMol(rxn.reactants, brackets, texts);
        //            this._addGraphicsRxnMol(rxn.products, brackets, texts);
        //        }

        return rxn;
    },

    _addGraphicsRxnMol: function (mols, brackets, texts) {
        for (var i = 0; i < mols.length; ++i) {
            var m = mols[i];
            for (var k = 0; k < brackets.length; ++k) {
                var b = brackets[k];
                if (b != null && b.allAtomsIn(m)) {
                    m.graphics.push(b);
                    brackets[k] = null;
                }
            }
            for (var k = 0; k < texts.length; ++k) {
                var b = texts[k];
                if (b != null && b.allAnchorsIn(m)) {
                    m.graphics.push(b);
                    brackets[k] = null;
                }
            }
        }
    },

    _parseRxn: function () {
        return null;
    },

    _hasOverlap: function (left, right, rect) {
        var l = rect.left;
        var r = rect.right();
        return l < right && r > left;
    },

    _sortTextByTop: function (texts) {
        if (texts == null || texts.length == 0)
            return texts;

        var yy = [];
        var sorted = [];
        for (var i = 0; i < texts.length; ++i) {
            var y = texts[i]._rect.top;
            var p = yy.length;
            for (var k = 0; k < yy.length; ++k) {
                if (y < yy[k]) {
                    p = k;
                    break;
                }
            }

            yy.splice(p, 0, y);
            sorted.splice(p, 0, texts[i]);
        }

        return sorted;
    },

    /**
    * Get the whole fragment containing an input atom
    * @function getFragment
    * @param {Atom} a - the input atom
    * @returns a Mol object
    */
    getFragment: function (a, parent) {
        this.setAtomBonds();
        this.clearFlag();

        var tree = this._getTree(a).tree;
        var path = [];
        tree.list(path, "breadthfirst");

        var m = new JSDraw2.Mol();
        for (var k = 0; k < path.length; ++k) {
            var b = path[k];
            if (b.a != null && b.ringclosure == null)
                m._addAtom(b.a, parent);
            if (b.b != null)
                m._addBond(b.b, parent);
        }
        return m;
    },

    /**
    * Split it into fragments
    * @function splitFragments
    * @returns an array of Mol
    */
    splitFragments: function (skipHiddenAtoms) {
        this.clearFlag();

        var fragid = -1;
        var bonds = scil.Utils.cloneArray(this.bonds);
        while (bonds.length > 0) {
            var b = bonds[0];
            if (skipHiddenAtoms) {
                if (b.a1.hidden || b.a2.hidden) {
                    bonds.splice(0, 1);
                    continue;
                }
            }
            b.f = b.a1.f = b.a2.f = ++fragid;
            bonds.splice(0, 1);

            while (true) {
                var n = 0;
                for (var i = bonds.length - 1; i >= 0; --i) {
                    var b = bonds[i];
                    if (b.a1.hidden || b.a2.hidden) {
                        bonds.splice(i, 1);
                        continue;
                    }

                    if (b.f == null && (b.a1.f == fragid || b.a2.f == fragid)) {
                        b.f = b.a1.f = b.a2.f = fragid;
                        bonds.splice(i, 1);
                        ++n;
                    }
                }

                if (n == 0)
                    break;
            }
        }

        var frags = [];
        for (var k = 0; k <= fragid; ++k) {
            var m = new JSDraw2.Mol();
            frags.push(m);

            for (var i = 0; i < this.atoms.length; ++i) {
                if (this.atoms[i].f == k)
                    m._addAtom(this.atoms[i], this);
            }

            for (var i = 0; i < this.bonds.length; ++i) {
                if (this.bonds[i].f == k)
                    m._addBond(this.bonds[i], this);
            }
        }

        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i].f == null) {
                if (skipHiddenAtoms && this.atoms[i].hidden)
                    continue;

                var m = new JSDraw2.Mol();
                frags.push(m);
                m._addAtom(this.atoms[i], this);
            }
        }

        // brackets
        for (var i = 0; i < this.graphics.length; ++i) {
            var br = JSDraw2.Bracket.cast(this.graphics[i]);
            if (br == null)
                continue;

            for (var k = 0; k < frags.length; ++k) {
                if (br.atoms == null || br.atoms.length == 0)
                    continue;
                if (frags[k].containsAllAtoms(br.atoms)) {
                    frags[k].graphics.push(br);
                    for (var j = 0; j < this.graphics.length; ++j) {
                        var t = JSDraw2.Text.cast(this.graphics[j]);
                        if (t != null && t.anchors != null && t.anchors.length == 1 && t.anchors[0] == br)
                            frags[k].graphics.push(t);
                    }
                }
            }
        }

        // attached texts
        for (var i = 0; i < this.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t == null || t.anchors == null || t.anchors.length == 0)
                continue;

            for (var k = 0; k < frags.length; ++k) {
                if (frags[k].containsAllAtoms(t.anchors))
                    frags[k].graphics.push(t);
            }
        }


        // set chiral flags
        for (var i = 0; i < frags.length; ++i) {
            var frag = frags[i];
            for (var j = 0; j < frag.atoms.length; ++j) {
                var g = frag.atoms[j].group;
                if (g != null && g.type == "chiral") {
                    frag.chiral = true;
                    break;
                }
            }
        }

        for (var i = 0; i < frags.length; ++i)
            frags[i].bondlength = this.bondlength;

        return frags;
    },

    containsAllAtoms: function (atoms) {
        if (atoms == null || atoms.length == 0)
            return false;
        for (var i = 0; i < atoms.length; ++i) {
            if (scil.Utils.indexOf(this.atoms, atoms[i]) < 0)
                return false;
        }

        return true;
    },

    /**
    * Check if the Mol contains an atom
    * @function containsAtom
    * @param {Atom} a - the input atom
    * @returns true or false
    */
    containsAtom: function (a) {
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i] == a)
                return true;
        }
        return false;
    },

    setAtomBonds: function (clear) {
        for (var i = 0; i < this.atoms.length; ++i)
            this.atoms[i].bonds = null;

        if (clear)
            return;

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];

            if (b.a1.bonds == null)
                b.a1.bonds = [];
            b.a1.bonds.push(b);

            if (b.a2.bonds == null)
                b.a2.bonds = [];
            b.a2.bonds.push(b);
        }
    },

    setBondOrders: function () {
        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            b.order = b.valence();
        }

        if (DEBUG.enable) {
            for (var i = 0; i < this.bonds.length; ++i) {
                var b = this.bonds[i];
                DEBUG.print(b.a1.id + "-" + b.a2.id + " " + b.order);
            }
        }

        var rings = this._getRings();
        var ars = [];
        while (rings.length > 0) {
            var n = 0;
            for (var i = rings.length - 1; i >= 0; --i) {
                var r = rings[i];
                if (this.isAromaticRing(r)) {
                    ++n;
                    ars.push(r);
                    rings.splice(i, 1);
                    for (var k = 0; k < r.length; ++k)
                        r[k].order = 1.5;
                }
            }

            if (n == 0)
                break;
        }

        return { arrings: ars, rings: rings };
    },

    isAromaticRing: function (r) {
        if (r.length == 6) {
            var b1 = r[0];
            for (var k = 1; k <= r.length; ++k) {
                var b2 = r[k == r.length ? 0 : k];
                if (!(b1.order == 1 && b2.order == 2 ||
                    b1.order == 2 && b2.order == 1 ||
                    b1.order == 1.5 && b2.order >= 1 && b2.order <= 2 ||
                    b2.order == 1.5 && b1.order >= 1 && b1.order <= 2)) {
                    return false;
                }
                b1 = b2;
            }

            return true;
        }

        if (r.length == 5) {
            var b1 = r[0];
            for (var k = 1; k <= r.length; ++k) {
                var b2 = r[k == r.length ? 0 : k];
                if (b1.order == 1 && b2.order == 1) {
                    if (b1.a1 == b2.a1 || b1.a1 == b2.a2)
                        v = b1.a1;
                    else if (b1.a2 == b2.a1 || b1.a2 == b2.a2)
                        v = b1.a2;

                    if (v != null &&
                        (r[(k + 1) % 5].order == 2 || r[(k + 1) % 5].order == 1.5) &&
                            r[(k + 2) % 5].order == 1 &&
                            (r[(k + 3) % 5].order == 2 || r[(k + 3) % 5].order == 1.5)) {
                        if (v.elem == "N" || v.elem == "O" || v.elem == "S" || v.elem == "P") {
                            return true;
                        }
                        else if (v.elem == "C") {
                            for (var i = 0; i < v.bonds.length; ++i) {
                                var order = v.bonds[i].order;
                                if (order == 1.5 || order == 2)
                                    return true;
                            }
                        }
                    }

                    return false;
                }
                b1 = b2;
            }

            return false;
        }

        return false;
    },

    prepareScreen: function () {
        var atoms = JSDraw2.FormulaParser.getAtomStats(this).elements;
        var allrings = this.setBondOrders();

        var bonds = { 0: 0, 1: 0, 1.5: 0, 2: 0, 3: 0 };
        for (var i = 0; i < this.bonds.length; ++i)
            ++bonds[this.bonds[i].order];

        var rings = { n5: 0, a5: 0, n6: 0, a6: 0 };
        for (var i = 0; i < allrings.arrings.length; ++i) {
            if (allrings.arrings[i].length == 5)
                ++rings.a5;
            else if (allrings.arrings[i].length == 6)
                ++rings.a6;
        }
        for (var i = 0; i < allrings.rings.length; ++i) {
            if (allrings.rings[i].length == 5)
                ++rings.n5;
            else if (allrings.rings[i].length == 6)
                ++rings.n6;
        }

        return { atoms: atoms, bonds: bonds, rings: rings };
    },

    clearAtomMap: function (ai) {
        var n = 0;
        if (ai == null) {
            for (var i = 0; i < this.atoms.length; ++i) {
                if (this.atoms[i].atommapid != null) {
                    ++n;
                    this.atoms[i].atommapid = null;
                }
            }
        }
        else {
            for (var i = 0; i < this.atoms.length; ++i) {
                if (ai == this.atoms[i].atommapid) {
                    ++n;
                    this.atoms[i].atommapid = null;
                }
            }
        }
        return n;
    },

    getMaxMapId: function () {
        var maxid = 0;
        var list = this.atoms;
        for (var i = 0; i < list.length; ++i) {
            if (list[i].atommapid != null && list[i].atommapid >= maxid)
                maxid = list[i].atommapid;
        }
        return maxid + 1;
    },

    screen: function (target, fullstructure) {
        if (this.stats == null)
            this.stats = this.prepareScreen();
        if (target.stats == null)
            target.stats = target.prepareScreen();

        var atomsq = this.stats.atoms;
        var atomst = target.stats.atoms;
        var at = atomst["*"] == null ? 0 : atomst["*"];
        at += atomst["A"] == null ? 0 : atomst["A"];
        at += atomst["X"] == null ? 0 : atomst["X"];
        at += atomst["Q"] == null ? 0 : atomst["Q"];
        at += atomst["L"] == null ? 0 : atomst["L"];
        for (var e in atomsq) {
            if (e == "H" || e == "*" || e == "A" || e == "X" || e == "Q" || e == "L")
                continue;

            if (fullstructure && !(atomsq[e] == atomst[e]) || !fullstructure && !(atomsq[e] <= atomst[e] + at))
                return false;
        }

        var bondsq = this.stats.bonds;
        var bondst = target.stats.bonds;
        for (var e in bondsq) {
            if (fullstructure && !(bondsq[e] == bondst[e]) || !fullstructure && !(bondsq[e] <= bondst[e]))
                return false;
        }

        return fullstructure &&
            this.stats.rings.a5 == target.stats.rings.a5 &&
            this.stats.rings.n5 == target.stats.rings.n5 &&
            this.stats.rings.a6 == target.stats.rings.a6 &&
            this.stats.rings.n6 == target.stats.rings.n6 ||
            !fullstructure &&
            this.stats.rings.a5 <= target.stats.rings.a5 &&
            this.stats.rings.n5 <= target.stats.rings.n5 &&
            this.stats.rings.a6 <= target.stats.rings.a6 &&
            this.stats.rings.n6 <= target.stats.rings.n6;
    },

    /**
    * Perform a full-structure search
    * @function fullstructureMatch
    * @param {Mol} target - the target mol
    * @returns true or false
    */
    fullstructureMatch: function (target, matchstereobonds) {
        if (target == null || this.atoms.length != target.atoms.length || this.bonds.length != target.bonds.length || this.getMolWeight() != target.getMolWeight())
            return false;
        return this.aamap(target, true, null, matchstereobonds) != null;
    },

    getBrackets: function () {
        var list = [];
        for (var i = 0; i < this.graphics.length; ++i) {
            var b = JSDraw2.Bracket.cast(this.graphics[i]);
            if (b != null) {
                list.push(b);
                b.sgrouptexts = this.getSgroupTexts(b);
            }
        }
        return list;
    },

    // todo: match included atoms as well
    matchBrackets: function (target) {
        var list1 = this.getBrackets();
        var list2 = target == null ? [] : target.getBrackets();
        if (list1.length != list2.length)
            return false;

        for (var i = 0; i < list1.length; ++i) {
            var f = false;
            for (var k = 0; k < list2.length; ++k) {
                if (list1[i].sgrouptexts == list2[k].sgrouptexts) {
                    f = true;
                    break;
                }
            }
            if (f != null)
                return false;
        }

        return true;
    },

    /**
    * Perform a sub-structure search using the Mol as a query
    * @function substructureMatch
    * @param {Mol} target - the target mol
    * @returns true or false
    */
    substructureMatch: function (target) {
        return this.aamap(target, false) != null;
    },

    /**
    * Perform atom-by-atom mapping using the Mol as a query
    * @function aamap
    * @param {Mol} target - the target mol
    * @param {bool} fullstructure - indicate if performing a full-structure search
    * @param {bool} highlighting - indicate if highlighting mapped atoms and bonds
    * @returns the map result as a dictionary
    */
    aamap: function (target, fullstructure, highlighting, matchsterebonds) {
        var map = this.aamap2(target, fullstructure, matchsterebonds);

        if (highlighting) {
            target.setColor(map == null ? null : "black");
            if (map != null) {
                for (var i = 0; i < map.atoms.length; ++i)
                    map.atoms[i].t.color = "red";
                for (var i = 0; i < map.bonds.length; ++i)
                    map.bonds[i].t.color = "red";
            }
        }

        return map;
    },

    aamap2: function (target, fullstructure, matchsterebonds) {
        if (DEBUG.enable) {
            DEBUG.clear();
        }

        if (!this.screen(target, fullstructure)) {
            if (DEBUG.enable)
                DEBUG.print("screen failed");
            return null;
        }

        var path = this._bfPath();
        target.setAtomBonds();
        target.clearFlag();
        this.clearFlag();

        var i = 0;
        while (i < path.length) {
            var f = false;
            var n = path[i];

            if (n.b == null) { // start of new fragment
                for (var j = (n.f == null ? 0 : (n.f + 1)); j < target.atoms.length; ++j) {
                    var t = target.atoms[j];
                    n.f = j;
                    if (t.f == null && JSDraw2.Atom.match(t, n.a)) {
                        f = true;
                        n.a.f = t;
                        t.f = n.a;
                        break;
                    }
                }
            }
            else if (n.ringclosure != null) { // ring closure
                var b = target.findBond(n.b.a1.f, n.b.a2.f);
                if (b != null && n.b.order == b.order && (!matchsterebonds || n.b.type == b.type)) {
                    f = true;
                    b.f = n.b;
                    n.b.f = b;
                }
            }
            else {
                var st = n.f == null ? 0 : n.f + 1;
                var t = n.startAtom().f;
                for (var k = st; k < t.bonds.length; ++k) {
                    n.f = k;
                    var b = t.bonds[k];
                    var oa = b.otherAtom(t);
                    if (b.f == null && oa.f == null && n.b.order == b.order && (!matchsterebonds || n.b.type == b.type) && JSDraw2.Atom.match(n.a, oa)) {
                        f = true;
                        n.a.f = oa;
                        oa.f = n.a;
                        n.b.f = b;
                        b.f = n.b;
                        break;
                    }
                }
            }

            if (f) {
                // step next
                ++i;
                if (DEBUG.enable) {
                    var s = '';
                    if (n.a != null)
                        s += n.a.id + " -> " + n.a.f.id + " ";
                    if (n.b != null)
                        s += n.b.a1.id + "-" + n.b.a2.id + " -> " + n.b.f.a1.id + "-" + n.b.f.a2.id;
                    DEBUG.print(s);
                }
            }
            else {
                // then back-trace
                if (n.b != null && n.b.f != null) {
                    n.b.f.f = null;
                    n.b.f = null;
                }
                if (n.a != null && n.a.f != null) {
                    n.a.f.f = null;
                    n.a.f = null;
                }
                n.f = null;

                if (--i < 0) {
                    if (DEBUG.enable)
                        DEBUG.print("failed");
                    return null;
                }
                n = path[i];
                if (n.b != null && n.b.f != null) {
                    n.b.f.f = null;
                    n.b.f = null;
                }
                if (n.a != null && n.a.f != null) {
                    n.a.f.f = null;
                    n.a.f = null;
                }

                if (DEBUG.enable)
                    DEBUG.print("trace back");
            }
        }

        if (DEBUG.enable)
            DEBUG.print("succeed");

        var atommap = [];
        for (var i = 0; i < this.atoms.length; ++i)
            atommap.push({ q: this.atoms[i], t: this.atoms[i].f });

        var bondmap = [];
        for (var i = 0; i < this.bonds.length; ++i)
            bondmap.push({ q: this.bonds[i], t: this.bonds[i].f });

        return { atoms: atommap, bonds: bondmap };
    },

    _setAromaticFlag: function () {
        for (var i = 0; i < this.atoms.length; ++i)
            this.atoms[i].aromatic = false;

        for (var i = 0; i < this.bonds.length; ++i) {
            var b = this.bonds[i];
            if (b.type == JSDraw2.BONDTYPES.DELOCALIZED)
                b.a1.aromatic = b.a2.aromatic = true;
        }
    },

    /**
    * Get SMILES
    * @function getSmiles
    * @returns a string
    */
    getSmiles: function () {
        return null;
    },

    _getSmiles: function () {
        return null;
    },

    _getRings: function () {
        //        if (DEBUG.enable) {
        //            DEBUG.clear();
        //        }

        var rings = [];

        this.setAtomBonds();
        this.clearFlag();
        for (var i = 0; i < this.atoms.length; ++i) {
            this.clearFlag();
            for (var j = 0; j < i; ++j)
                this.atoms[j].f = "ex";
            var start = this.atoms[i];
            var ret = this._getTree(start);
            if (ret.ri == 0)
                continue;

            var path = [];
            ret.tree.list(path, "breadthfirst");

            for (var k = 0; k < path.length; ++k) {
                var b = path[k];
                if (b.depth > 3)
                    break;

                if (b.ringclosure != null) {
                    var ring = [b.b];
                    rings.push(ring);

                    var a = b.startAtom();
                    var n = k;
                    while (a != start) {
                        for (var j = n - 1; j > 0; --j) {
                            var t = path[j];
                            if (t.a == a) {
                                ring.push(t.b);
                                a = t.startAtom();
                                n = j;
                                break;
                            }
                        }
                    }

                    a = b.a;
                    n = k;
                    while (a != start) {
                        for (var j = n - 1; j > 0; --j) {
                            var t = path[j];
                            if (t.a == a) {
                                ring.splice(0, 0, t.b);
                                a = t.startAtom();
                                n = j;
                                break;
                            }
                        }
                    }
                }
            }
        }

        //        if (DEBUG.enable) {
        //            for (var i = 0; i < rings.length; ++i) {
        //                DEBUG.print("ring:" + i);
        //                var r = rings[i];
        //                for (var j = 0; j < r.length; ++j) {
        //                    var s = " " + r[j].a1.id + "-" + r[j].a2.id;
        //                    DEBUG.print(s);
        //                }
        //            }
        //        }
        return rings;
    },

    _bfPath: function () {
        var ss = [];
        var trees = this._getTrees();
        for (var i = 0; i < trees.length; ++i)
            trees[i].list(ss, "breadthfirst");
        return ss;
    },

    _getTrees: function () {
        this.setAtomBonds();
        this.clearFlag();

        var starts = [];
        var ri = 0;
        while (true) {
            var start = null;
            for (var i = 0; i < this.atoms.length; ++i) {
                var a = this.atoms[i];
                if (a.f == null && !a.isMarkedStereo()) {
                    start = a;
                    break;
                }
            }

            if (start == null) {
                for (var i = 0; i < this.atoms.length; ++i) {
                    var a = this.atoms[i];
                    if (a.f == null/* && !a.isMarkedStereo() */) {
                        start = a;
                        break;
                    }
                }
            }

            if (start == null)
                break;

            var ret = this._getTree(start, ri);
            starts.push(ret.tree);
            ri = ret.ri;
        }

        return starts;
    },

    // breadthfirst
    _getTree: function (a, ri) {
        if (ri == null)
            ri = 0;

        var start = new JSDraw2.BA(null, a, null);
        start.depth = 0;

        start.a.f = true;
        var stack = new JSDraw2.Stack();
        stack.push(start);

        var ba;
        while ((ba = stack.popHead()) != null) {
            var bonds = ba.a.bonds;
            if (bonds == null)
                continue;

            for (var i = 0; i < bonds.length; ++i) {
                var b = bonds[i];
                if (b.f)
                    continue;
                b.f = true;

                var next = null;
                var oa = b.otherAtom(ba.a);
                if (oa.f == "ex")
                    continue;

                if (oa.f == null) {
                    oa.f = true;
                    next = new JSDraw2.BA(b, oa, null);
                    stack.push(next);
                }
                else {
                    ++ri;
                    if (oa.f == true && oa.ringclosures == null)
                        oa.ringclosures = [];
                    oa.ringclosures.push({ ri: ri, next: new JSDraw2.BA(b, ba.a, ri) });
                    next = new JSDraw2.BA(b, oa, ri);
                }
                ba.addNext(next);
            }
        }

        return { tree: start, ri: ri };
    },

    // depth-first
    _getPath: function (b) {
        var stack = new JSDraw2.Stack();
        stack.push({ b: b, a: b.a1.bonds.length > b.a2.bonds.length ? b.a1 : b.a2 });

        b.a1.f = true;
        var path = [];
        while ((b = stack.pop()) != null) {
            if (b.b.f)
                continue;

            path.push(b);
            if (b.a.f)
                b.ringclosure = true;
            b.b.f = b.a.f = true;

            var bonds = b.a.bonds;
            for (var i = bonds.length - 1; i >= 0; --i) {
                if (!bonds[i].f)
                    stack.push({ b: bonds[i], a: bonds[i].otherAtom(b.a) });
            }
        }

        return path;
    },

    /**
    * Get molecular formula
    * @function getFormula
    * @param {bool} html - indicate if rendering the formula in HTML format
    * @returns a string
    */
    getFormula: function (html) {
        var rxn = this.parseRxn();
        if (rxn == null)
            return this._getFormula(html);

        var s = "";
        if (rxn.arrow != null) {
            for (var i = 0; i < rxn.reactants.length; ++i)
                s += (i > 0 ? " + " : "") + rxn.reactants[i]._getFormula(html);
            s += html ? " &rarr; " : " ---> ";
            for (var i = 0; i < rxn.products.length; ++i)
                s += (i > 0 ? " + " : "") + rxn.products[i]._getFormula(html);
            return s;
        }
        else {
            for (var i = 0; i < rxn.reactants.length; ++i)
                s += (i > 0 ? " + " : "") + rxn.reactants[i]._getFormula(html);
        }
        return s;
    },

    _getFormula: function (html) {
        var m = this.expandSuperAtoms();
        var stats = JSDraw2.FormulaParser.getAtomStats(m);
        return JSDraw2.FormulaParser.stats2mf(stats, html);
    },

    /**
    * Get molecular weight
    * @function getMolWeight
    * @returns a number
    */
    getMolWeight: function () {
        var mw = this.getMixtureMW();
        if (mw > 0)
            return mw;

        if (this.hasGenericAtom())
            return null;

        var m = this.expandSuperAtoms();
        var stats = JSDraw2.FormulaParser.getAtomStats(m);
        var sum = JSDraw2.FormulaParser.stats2mw(stats);
        return sum == null ? null : Math.round(sum * 10000) / 10000;
    },

    getMixtureMW: function () {
        for (var i = 0; i < this.graphics.length; ++i) {
            var br = JSDraw2.Bracket.cast(this.graphics[i]);
            if (br == null || !(br.type == "" || br.type == null))
                continue;

            var t = this.getSgroupText(br, "POLYMER_MW");
            if (t == null)
                continue;

            var s = scil.Utils.trim(t.text);
            if (s != null && scil.Utils.startswith(s, "mw=")) {
                var n = s.substr(3);
                return parseFloat(n);
            }
        }
        return null;
    },

    /**
    * Get exact mass
    * @function getExactMass
    * @returns a number
    */
    getExactMass: function () {
        if (this.hasGenericAtom())
            return null;

        var m = this.expandSuperAtoms();
        var stats = JSDraw2.FormulaParser.getAtomStats(m);
        var sum = JSDraw2.FormulaParser.stats2em(stats);
        return sum == null ? null : Math.round(sum * 10000) / 10000;
    },

    getAllBonds: function (a) {
        var ret = [];
        var bonds = this.bonds;
        for (var i = 0; i < bonds.length; ++i) {
            if (bonds[i].a1 == a || bonds[i].a2 == a)
                ret.push(bonds[i]);
        }
        return ret;
    },

    getAllBondAtoms: function (a) {
        var ret = [];
        var bonds = this.bonds;
        for (var i = 0; i < bonds.length; ++i) {
            if (bonds[i].a1 == a)
                ret.push(bonds[i].a2);
            else if (bonds[i].a2 == a)
                ret.push(bonds[i].a1);
        }
        return ret;
    },

    countSelected: function () {
        var n = 0;
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i].selected)
                ++n;
        }
        for (var i = 0; i < this.bonds.length; ++i) {
            if (this.bonds[i].selected)
                ++n;
        }
        for (var i = 0; i < this.graphics.length; ++i) {
            if (this.graphics[i].selected)
                ++n;
        }
        return n;
    },

    setSgroup: function (br, fieldtype, v, x, y) {
        if (v == "")
            v = null;

        if (fieldtype == "BRACKET_TYPE" && v == "mul" && br.subscript != null && br.subscript != "") {
            v = br.subscript;
            br.subscript = null;
        }

        var t = this.getSgroupText(br, fieldtype);
        if (v == null) {
            if (t != null) {
                this.delGraphics(t);
                return t;
            }
        }
        else {
            if (t != null) {
                if (t.text != v) {
                    t.text = v;
                    return t;
                }
            }
            else {
                var r = new JSDraw2.Rect(x, y, 0, 0);
                t = new JSDraw2.Text(r, v);
                t.fieldtype = fieldtype;
                t.anchors.push(br);
                br._parent.addGraphics(t);
                return t;
            }
        }

        return null;
    },

    getSgroupText: function (br, fieldtype) {
        for (var i = 0; i < this.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t != null && t.fieldtype == fieldtype && t.anchors.length == 1 && t.anchors[0] == br)
                return t;
        }
        return null;
    },

    getSgroupTexts: function (br) {
        var ss = [];
        for (var i = 0; i < this.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t != null && t.anchors.length == 1 && t.anchors[0] == br)
                ss.push(t.text);
        }

        if (ss.length == 0)
            return null;

        ss.sort();
        return scil.Utils.array2str(ss, "; ");
    },

    removeTags: function (br, fieldtypes) {
        var n = 0;
        for (var i = this.graphics.length - 1; i >= 0; --i) {
            var t = JSDraw2.Text.cast(this.graphics[i]);
            if (t != null && t.anchors.length == 1 && t.anchors[0] == br && fieldtypes.indexOf(t.fieldtype + ",") >= 0) {
                this.delGraphics(t);
                ++n;
            }
        }
        return n;
    }
});

JsMol = JSDraw2.Mol;
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Point class - define a position on the screen
* @class scilligence.JSDraw2.Point
*/
JSDraw2.Point = scilligence.extend(scilligence._base, {
    /**
    @property {number} x
    */
    /**
    @property {number} y
    */

    /**
    * @constructor Point
    * @param {number} x
    * @param {number} y
    */
    constructor: function (x, y) {
        this.x = isNaN(x) ? 0 : x;
        this.y = isNaN(y) ? 0 : y;
    },

    /**
    * Check if the x, y values are valid number
    * @function isValid
    * @returns true or false
    */
    isValid: function () {
        return !isNaN(this.x) && !isNaN(this.y);
    },

    /**
    * Get the length from the Point to the origin (0, 0)
    * @function length
    * @returns a number
    */
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
    * Get the distance from this Point to another Point (p)
    * @function distTo
    * @param {Point} p - the other point
    * @returns a number
    */
    distTo: function (p) {
        var dx = this.x - p.x;
        var dy = this.y - p.y;
        return Math.sqrt(dx * dx + dy * dy);
    },

    /**
    * Test if this point is on the line composing of p1-p2
    * @function onLine
    * @param {Point} p1 - the first point of the line
    * @param {Point} p2 - the second point of the line
    * @param {number} tor - the tolerance
    * @returns true or false
    */
    onLine: function (p1, p2, tor) {
        var d2 = p1.distTo(p2);
        var d = p1.distTo(this) + p2.distTo(this) - d2;
        return Math.abs(d) <= tor * (50 / d2);
    },

    inTriangle: function (v1, v2, v3) {
        var b1 = JSDraw2.Point.sign(this, v1, v2) < 0.0;
        var b2 = JSDraw2.Point.sign(this, v2, v3) < 0.0;
        var b3 = JSDraw2.Point.sign(this, v3, v1) < 0.0;
        return b1 == b2 && b2 == b3;
    },

    flip: function (p1, p2) {
        var a0 = p2.angleTo(p1);
        var a = this.angleTo(p1) - a0;
        return this.rotateAround(p1, -2 * a);
    },

    /**
    * Move the Point
    * @function offset
    * @param {number} dx - offset x
    * @param {number} dy - offset y
    * @returns the Point itself
    */
    offset: function (dx, dy) {
        this.x += dx;
        this.y += dy;
        return this;
    },

    offset2: function (d) {
        this.x += d.x;
        this.y += d.y;
        return this;
    },

    /**
    * Scale the point around an origin
    * @function offset
    * @param {number} scale - the scale factor
    * @param {Point} origin - the origin
    * @returns the Point itself
    */
    scale: function (s, origin) {
        if (origin != null) {
            this.x = (this.x - origin.x) * s + origin.x;
            this.y = (this.y - origin.y) * s + origin.y;
        }
        else {
            this.x *= s;
            this.y *= s;
        }
        return this;
    },

    /**
    * Reverse the point
    * @function reverse
    * @returns the Point itself
    */
    reverse: function () {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    },

    /**
    * Clone the point
    * @function clone
    * @returns a new Point object
    */
    clone: function () {
        return new JSDraw2.Point(this.x, this.y);
    },

    /**
    * Test if this Point equals to the other one
    * @function equalsTo
    * @param {Point} p - the other Point
    * @returns true or false
    */
    equalsTo: function (p) {
        return p != null && this.x == p.x && this.y == p.y;
    },

    /**
    * Get the angle of the point from X axis
    * @function angle
    * @returns a number in degree
    */
    angle: function () {
        var a = Math.atan2(this.y, this.x) * 180 / Math.PI;
        return a < 0 ? (a + 360) : a;
    },

    /**
    * Get the angle with a Point as the origin
    * @function angleTo
    * @param {Point} origin - the origin
    * @returns a number in degree
    */
    angleTo: function (origin) {
        var a = Math.atan2(this.y - origin.y, this.x - origin.x) * 180 / Math.PI;
        return a < 0 ? (a + 360) : a;
    },

    /**
    * Get the angle of p1-(this)-p2
    * @function angleAsOrigin
    * @param {Point} p1 - the first point
    * @param {Point} p2 - the second point
    * @returns a number in degree
    */
    angleAsOrigin: function (p1, p2) {
        var v1 = p1.clone().offset(-this.x, -this.y);
        var v2 = p2.clone().offset(-this.x, -this.y);
        var a = v2.angle() - v1.angle();
        return a < 0 ? (a + 360) : a;
    },

    middleAngle: function (p1, p2) {
        var a1 = p1.angleTo(this);
        var a2 = p2.angleTo(this);
        var mid = (a1 + a2) / 2;
        if (Math.abs(a1 - a2) > 180) {
            mid += 180;
            if (mid >= 360)
                mid -= 360;
        }
        return mid;
    },

    /**
    * Rotate the point around the origin
    * @function rotate
    * @param {number} deg - the degree to be rotated
    * @returns the Point itself
    */
    rotate: function (deg) {
        var d = this.length();
        if (d == 0)
            return this;
        var a = this.angle();
        this.x = d * Math.cos((a + deg) * Math.PI / 180);
        this.y = d * Math.sin((a + deg) * Math.PI / 180);
        return this;
    },

    /**
    * Rotate the point around a point
    * @function rotateAround
    * @param {Point} origin - the origin
    * @param {number} deg - the degree to be rotated
    * @returns the Point itself
    */
    rotateAround: function (origin, deg, len) {
        this.offset(-origin.x, -origin.y)
            .rotate(deg)
            .offset(origin.x, origin.y);
        if (len > 0)
            this.setLength(len, origin);
        return this;
    },

    setLength: function (len, origin) {
        if (origin == null)
            return this.scale(len / this.length());

        this.offset(-origin.x, -origin.y);
        this.scale(len / this.length());
        return this.offset(origin.x, origin.y);
    },

    toString: function (scale) {
        if (!(scale > 0))
            scale = 1.0;
        return (this.x * scale).toFixed(3) + " " + (-this.y * scale).toFixed(3);
    },

    shrink: function (origin, delta) {
        var d = this.distTo(origin);
        var s = (d - delta) / d;
        this.x = (this.x - origin.x) * s + origin.x;
        this.y = (this.y - origin.y) * s + origin.y;
        return this;
    },

    equalMove: function (start) {
        var d = Math.abs(this.x - start.x);
        if (this.y > start.y)
            this.y = start.y + d;
        else
            this.y = start.y - d;
    }
});

scil.apply(JSDraw2.Point, {
    fromString: function (s) {
        var ss = s.split(' ');
        if (ss.length != 2)
            return null;
        var x = parseFloat(ss[0]);
        var y = -parseFloat(ss[1]);
        if (isNaN(x) || isNaN(y))
            return null;

        return new JSDraw2.Point(x, y);
    },

    centerOf: function (p1, p2) {
        return new JSDraw2.Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
    },

    sign: function (p1, p2, p3) {
        return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
    },

    _onSegment: function (p, q, r) {
        if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))
            return true;

        return false;
    },

    _orientation: function (p, q, r) {
        // See 10th slides from following link for derivation of the formula
        // http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf
        var val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);

        if (val == 0)
            return 0;  // colinear

        return (val > 0) ? 1 : 2; // clock or counterclock wise
    },

    intersect: function (p1, q1, p2, q2) {
        // Find the four orientations needed for general and
        // special cases
        var o1 = this._orientation(p1, q1, p2);
        var o2 = this._orientation(p1, q1, q2);
        var o3 = this._orientation(p2, q2, p1);
        var o4 = this._orientation(p2, q2, q1);

        // General case
        if (o1 != o2 && o3 != o4)
            return true;

        // Special Cases
        // p1, q1 and p2 are colinear and p2 lies on segment p1q1
        if (o1 == 0 && this._onSegment(p1, p2, q1))
            return true;

        // p1, q1 and p2 are colinear and q2 lies on segment p1q1
        if (o2 == 0 && this._onSegment(p1, q2, q1))
            return true;

        // p2, q2 and p1 are colinear and p1 lies on segment p2q2
        if (o3 == 0 && this._onSegment(p2, p1, q2))
            return true;

        // p2, q2 and q1 are colinear and q1 lies on segment p2q2
        if (o4 == 0 && this._onSegment(p2, q1, q2))
            return true;

        return false; // Doesn't fall in any of the above cases
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Rect class - define a Rectangle on the screen
* @class scilligence.JSDraw2.Rect
*/
JSDraw2.Rect = scilligence.extend(scilligence._base, {
    /**
    @property {number} left
    */
    /**
    @property {number} top
    */
    /**
    @property {number} width
    */
    /**
    @property {number} height
    */

    /**
    * @constructor Rect
    * @param {number} left
    * @param {number} top
    * @param {number} width
    * @param {number} height
    */
    constructor: function (left, top, width, height) {
        this.left = isNaN(left) ? 0 : left;
        this.top = isNaN(top) ? 0 : top;
        this.width = isNaN(width) ? 0 : width;
        this.height = isNaN(height) ? 0 : height;
    },

    /**
    * Set Rect based on two points
    * @function set
    * @param {Point} p1 - the first point
    * @param {Point} p2 - the second point
    * @returns the Rect itelf
    */
    set: function (p1, p2) {
        this.left = Math.min(p1.x, p2.x);
        this.top = Math.min(p1.y, p2.y);
        this.width = Math.abs(p1.x - p2.x);
        this.height = Math.abs(p1.y - p2.y);
        return this;
    },

    /**
    * Get the top-left corner of the Rect
    * @function topleft
    * @returns a Point object
    */
    topleft: function () {
        return new JSDraw2.Point(this.left, this.top);
    },

    /**
    * Get the top-right corner of the Rect
    * @function topright
    * @returns a Point object
    */
    topright: function () {
        return new JSDraw2.Point(this.right(), this.top);
    },

    /**
    * Get the bottom-left corner of the Rect
    * @function bottomleft
    * @returns a Point object
    */
    bottomleft: function () {
        return new JSDraw2.Point(this.left, this.bottom());
    },

    /**
    * Get the bottom-right corner of the Rect
    * @function bottomright
    * @returns a Point object
    */
    bottomright: function () {
        return new JSDraw2.Point(this.right(), this.bottom());
    },

    fourPoints: function() {
        return [this.topleft(), this.topright(), this.bottomleft(), this.bottomright()];
    },

    /**
    * Clone this Rect
    * @function clone
    * @returns a new Rect object
    */
    clone: function () {
        return new JSDraw2.Rect(this.left, this.top, this.width, this.height);
    },

    /**
    * Check if the Rect is empty
    * @function isEmpty
    * @returns true or false
    */
    isEmpty: function () {
        return !(this.width > 0 && this.height > 0);
    },

    /**
    * Test if the Rect area contains a Point
    * @function contains
    * @param {Point} p - the point to be tested
    * @returns true or false
    */
    contains: function (p) {
        return p.x >= this.left && p.x <= this.right() && p.y >= this.top && p.y <= this.bottom();
    },

    /**
    * Get the right coordinate
    * @function right
    * @returns a number
    */
    right: function () {
        return this.left + this.width;
    },

    /**
    * Get the bottom coordinate
    * @function bottom
    * @returns a number
    */
    bottom: function () {
        return this.top + this.height;
    },

    /**
    * Get the center of the Rect
    * @function center
    * @returns the center as a Point object
    */
    center: function () {
        return new JSDraw2.Point(this.left + this.width / 2, this.top + this.height / 2);
    },

    centerLeft: function () {
        return new JSDraw2.Point(this.left, this.top + this.height / 2);
    },

    centerRight: function () {
        return new JSDraw2.Point(this.right(), this.top + this.height / 2);
    },

    centerTop: function () {
        return new JSDraw2.Point(this.left + this.width / 2, this.top);
    },

    centerBottom: function () {
        return new JSDraw2.Point(this.left + this.width / 2, this.bottom());
    },

    /**
    * Offset the rect
    * @function offset
    * @param {number} dx - the x offset
    * @param {number} dy - the y offset
    * @returns the rect itself
    */
    offset: function (dx, dy) {
        this.left += dx;
        this.top += dy;
        return this;
    },

    /**
    * Scale the rect
    * @function scale
    * @param {number} s - the scaling factor
    * @param {Point} origin - the base Point
    * @returns the rect itself
    */
    scale: function (s, origin) {
        if (origin != null) {
            this.left = (this.left - origin.x) * s + origin.x;
            this.top = (this.top - origin.y) * s + origin.y;
        }
        else {
            this.left *= s;
            this.top *= s;
        }
        this.width *= s;
        this.height *= s;
        return this;
    },

    /**
    * Union another Point
    * @function unionPoint
    * @param {Point} p - the Point to be unioned
    * @returns the rect itself
    */
    unionPoint: function (p) {
        if (p.x < this.left) {
            this.width += this.left - p.x;
            this.left = p.x;
        }
        else if (p.x > this.right()) {
            this.width += p.x - this.right();
        }

        if (p.y < this.top) {
            this.height += this.top - p.y;
            this.top = p.y;
        }
        else if (p.y > this.bottom()) {
            this.height += p.y - this.bottom();
        }
        return this;
    },

    /**
    * Union another Rect
    * @function union
    * @param {Rect} r - the Rect to be unioned
    * @returns the rect itself
    */
    union: function (r) {
        if (r == null)
            return;
        var right = this.right();
        var bottom = this.bottom();

        if (r.left < this.left)
            this.left = r.left;
        if (r.top < this.top)
            this.top = r.top;

        this.width = Math.max(right, r.right()) - this.left;
        this.height = Math.max(bottom, r.bottom()) - this.top;
        return this;
    },

    /**
    * Inflate the Rect
    * @function inflate
    * @param {number} dx - the delta in x direction
    * @param {number} dy - the delta in y direction
    * @returns the rect itself
    */
    inflate: function (dx, dy) {
        if (dy == null)
            dx = dy;
        if (this.width + 2 * dx < 0)
            dx = -this.width / 2;
        if (this.height + 2 * dy < 0)
            dy = -this.height / 2;

        this.offset(-dx, -dy);
        this.width += 2 * dx;
        this.height += 2 * dy;

        return this;
    },

    distance2Point: function (p) {
        var r = this.right();
        var b = this.bottom();
        var d = new JSDraw2.Point(this.left, this.top).distTo(p);
        d = this._minDist(d, p, this.left + this.width / 2, this.top);
        d = this._minDist(d, p, r, this.top);
        d = this._minDist(d, p, r, this.top + this.height / 2);
        d = this._minDist(d, p, r, b);
        d = this._minDist(d, p, this.left + this.width / 2, b);
        d = this._minDist(d, p, this.left, b);
        d = this._minDist(d, p, this.left, this.height / 2);
        return d;
    },

    _minDist: function (d, p, x, y) {
        return Math.min(d, new JSDraw2.Point(x, y).distTo(p));
    },

    cross: function (p1, p2) {
        var c1 = this.contains(p1);
        var c2 = this.contains(p2);
        if (c1 && c2)
            return 0;
        else if (c1 && !c2)
            return -2;
        else if (!c1 && c2)
            return 2;

        var a = p2.angleTo(p1);
        var aa = [];
        aa[0] = new JSDraw2.Point(this.left, this.top).angleTo(p1) - a;
        aa[1] = new JSDraw2.Point(this.right(), this.top).angleTo(p1) - a;
        aa[2] = new JSDraw2.Point(this.right(), this.bottom()).angleTo(p1) - a;
        aa[3] = new JSDraw2.Point(this.left, this.bottom()).angleTo(p1) - a;
        for (var i = 0; i < aa.length; ++i) {
            if (aa[i] < 0)
                aa[i] += 360;
        }
        aa.sort(function (a, b) { return a - b; });

        if (aa[0] < 90 && aa[3] > 270)
            return 1;
        if (aa[0] > 90 && aa[0] < 180 && aa[3] > 180 && aa[3] < 270)
            return -1;
        return 0;
    },

    /**
    * Convert the Rect into a string
    * @function toString
    * @param {number} scale - the scale factor
    * @returns a string
    */
    toString: function (scale) {
        if (!(scale > 0))
            scale = 1.0;
        return (this.left * scale).toFixed(3) + " " +
            (-this.bottom() * scale).toFixed(3) + " " +
            (this.width * scale).toFixed(3) + " " +
            (this.height * scale).toFixed(3);
    },

    cornerTest: function (p, tor) {
        if (Math.abs(p.x - this.left) < tor && Math.abs(p.y - this.top) < tor)
            return "topleft";
        if (Math.abs(p.x - this.right()) < tor && Math.abs(p.y - this.top) < tor)
            return "topright";
        if (Math.abs(p.x - this.left) < tor && Math.abs(p.y - this.bottom()) < tor)
            return "bottomleft";
        if (Math.abs(p.x - this.right()) < tor && Math.abs(p.y - this.bottom()) < tor)
            return "bottomright";
        return null;
    },

    moveCorner: function (corner, d) {
        switch (corner) {
            case "topleft":
                this.set(this.topleft().offset(d.x, d.y), this.bottomright());
                break;
            case "topright":
                this.set(this.topright().offset(d.x, d.y), this.bottomleft());
                break;
            case "bottomleft":
                this.set(this.bottomleft().offset(d.x, d.y), this.topright());
                break;
            case "bottomright":
                this.set(this.bottomright().offset(d.x, d.y), this.topleft());
                break;
        }
    }
});

JSDraw2.Rect.fromString = function (s) {
    if (s == null)
        return null;
    var ss = s.split(' ');
    if (ss.length != 4)
        return null;
    var left = parseFloat(ss[0]);
    var top = parseFloat(ss[1]);
    var wd = parseFloat(ss[2]);
    var ht = parseFloat(ss[3]);
    if (isNaN(left) || isNaN(top) || isNaN(wd) || isNaN(ht))
        return null;
    return new JSDraw2.Rect(left, -top - ht, wd, ht);
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Stack class - define Stack data structure
* @class scilligence.JSDraw2.Stack
* <pre>
* <b>Example:</b>
*    var stack = JSDraw2.Stack(50);
*    stack.push("Hydrogen");
*    stack.push("Exygen");
*
*    var item = stack.pop();
* </pre>
*/
JSDraw2.Stack = scilligence.extend(scilligence._base, {
    /**
    * @constructor Stack
    * @param {number} capacity
    */
    constructor: function (capacity) {
        this._items = [];
        this._capacity = capacity;
    },

    /**
    * Get an item by its index
    * @function item
    * @param {number} i - the index
    * @returns the item
    */
    item: function (i) {
        return this._items[i];
    },

    /**
    * Clear all items
    * @returns null
    */
    clear: function () {
        this._items = [];
    },

    /**
    * Get item count
    * @function length
    * @returns a number
    */
    length: function () {
        return this._items.length;
    },

    isEmpty: function () {
        return this._items.length == 0;
    },

    /**
    * Push a new item at the end of stack
    * @function push
    * @param {object} i - the item
    * @returns null
    */
    push: function (i) {
        if (this._items.length > this._capacity)
            this._items.splice(0, 1);
        this._items.push(i);
    },

    /**
    * Pop out the top item in the stack
    * @function pop
    * @returns the item
    */
    pop: function () {
        if (this._items.length == 0)
            return null;
        return this._items.pop();
    },

    popHead: function () {
        if (this._items.length == 0)
            return null;
        var i = this._items[0];
        this._items.splice(0, 1);
        return i;
    }
});



scil.Deque = scil.apply(scil._base, {
    constructor: function () {
        this.items = [];
    },

    pushRange: function (list) {
        if (list == null)
            return;

        for (var i = 0; i < list.length; ++i)
            this.push(list[i]);
    },

    push: function (n) {
        this.items.push(n);
    },

    pop: function () {
        if (this.items.length == 0)
            return null;

        var r = this.items[0];
        this.items.splice(0, 1);
        return r;
    },

    length: function () {
        return this.items.length;
    },

    clear: function () {
        this.items = [];
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.SuperAtoms = {
    sdf: "\nMolEngine02241412152D\n\n  6  6  0  0  0  0            999 V2000\n    1.3510    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    0.7800    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    2.3400    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.7020    0.7800    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.7020    2.3400    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.3510    3.1200    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  2  0  0  0  0\n  2  3  1  0  0  0  0\n  1  4  1  0  0  0  0\n  4  5  2  0  0  0  0\n  5  6  1  0  0  0  0\n  6  3  2  0  0  0  0\nM  END\n> <T>\nBenzene\n\n$$$$\n\nMolEngine02241412152D\n\n  6  6  0  0  0  0            999 V2000\n    1.3510    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    0.7800    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    2.3400    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.3510    3.1200    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.7020    2.3400    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.7020    0.7800    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  1  0  0  0  0\n  4  5  1  0  0  0  0\n  5  6  1  0  0  0  0\n  6  1  1  0  0  0  0\nM  END\n> <T>\nHexane\n\n$$$$\n\nMolEngine02241412152D\n\n  5  5  0  0  0  0            999 V2000\n    0.0000    0.4821    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.4836    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.4006    1.2621    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.4836    2.5242    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    2.0421    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  1  0  0  0  0\n  4  5  1  0  0  0  0\n  5  1  1  0  0  0  0\nM  END\n> <T>\nPentane\n\n$$$$\n\nMolEngine02241412152D\n\n  3  3  0  0  0  0            999 V2000\n    0.7800    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    1.3510    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.5600    1.3510    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  1  3  1  0  0  0  0\n  2  3  1  0  0  0  0\nM  END\n> <T>\nPropane\n\n$$$$\n\nMolEngine02241412152D\n\n  4  4  0  0  0  0            999 V2000\n    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    1.5600    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.5600    1.5600    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.5600    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  1  0  0  0  0\n  4  1  1  0  0  0  0\nM  END\n> <T>\nButane\n\n$$$$\n\nMolEngine02241412152D\n\n  7  7  0  0  0  0            999 V2000\n    0.0000    0.9727    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.2196    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.7405    0.3471    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.4174    1.7527    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.7405    3.1581    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.2196    3.5054    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    2.5327    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  1  0  0  0  0\n  4  5  1  0  0  0  0\n  5  6  1  0  0  0  0\n  6  7  1  0  0  0  0\n  7  1  1  0  0  0  0\nM  END\n> <T>\nHeptane\n\n$$$$\n\nMolEngine02241412152D\n\n  8  8  0  0  0  0            999 V2000\n    0.0000    1.1031    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.1031    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.6631    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.7660    1.1031    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.7660    2.6631    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.6631    3.7662    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.1031    3.7662    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.0000    2.6631    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  1  0  0  0  0\n  4  5  1  0  0  0  0\n  5  6  1  0  0  0  0\n  6  7  1  0  0  0  0\n  7  8  1  0  0  0  0\n  8  1  1  0  0  0  0\nM  END\n> <T>\nOctane\n\n$$$$\n",

    dict: null,
    reversible: {},
    AminoAcids: {},
    DNAs: {},
    RNAs: {},
    templates: {},
    nterminals: {},
    cterminals: {},
    customtemplates: {},

    listFunctionalGroups: function (parent) {
        this.read();
        var cols = [{ key: 'name', caption: 'Name', width: 200 }, { key: 'molfile', type: "structure", caption: 'Structure'}];
        var jss = new JSDraw2.Table(null, { columns: cols, toolbar: ["search"] }, parent);

        var list = [];
        for (var name in this.dict)
            list.push({ name: name, molfile: this.dict[name] == null ? null : this.dict[name].getMolfile() });
        jss.setJson({ rows: list });

    },

    filter: function (q, n) {
        if (q == null || q == "")
            return null;

        var ret = [];
        q = q.toLowerCase();
        var len = q.length;
        for (var k in this.dict) {
            if (k.length >= len && k.substr(0, len).toLowerCase() == q) {
                ret.push(k);
                if (ret.length >= n)
                    break;
            }
        }
        return ret;
    },

    get: function (name) {
        this.read();
        var m = this.dict[name];
        if (m == null)
            m = this.nterminals[name];
        if (m == null)
            m = this.cterminals[name];
        return m == null ? null : m.clone();
    },

    getDNA: function (name) {
        this.read();
        return this.DNAs[name];
    },

    getRNA: function (name) {
        this.read();
        return this.RNAs[name];
    },

    getAA: function (name) {
        this.read();
        return this.AminoAcids[name];
    },

    getTemplate: function (name) {
        this.read();
        return this.templates[name];
    },

    hasCustomTemplates: function (name) {
        this.read();
        for (var k in this.customtemplates)
            return true;
        return false;
    },

    getCustomTemplate: function (name) {
        this.read();
        return this.customtemplates[name];
    },

    // COOH --> HOOC, CO2H --> HO2C, n-But --> n-But, Boc --> Boc
    reverseLabel: function (s) {
        this.read();
        if (this.get(s) != null)
            return this.reverseLabel2(s);

        var c = s.substr(0, 1);
        var s1 = s.substr(1);
        if ((c == "O" || c == "S") && this.get(s1) != null)
            return this.reverseLabel2(s1) + c;

        return s;
    },

    reverseLabel2: function (s) {
        if (this.reversible[s] == null)
            return s;

        var ret = "";
        for (var i = s.length - 1; i >= 0; --i) {
            var n = 1;
            for (var j = i; j >= 0; --j) {
                var c = s.charCodeAt(j);
                if (c >= 65 && c <= 90)
                    break;
                else
                    ++n;
            }
            i -= n - 1;
            ret += s.substr(i, n);
        }
        return ret;
    },

    guessOne: function (name) {
        this.read();

        name = name.toLowerCase();
        for (var k in this.dict) {
            if (k.toLowerCase() == name)
                return k;
        }

        return null;
    },

    read: function () {
        if (this.dict != null)
            return;
        this.dict = {};
        this.addSdf(this.sdf);

        if (JSDraw2.defaultoptions != null)
            this.addSdf(JSDraw2.defaultoptions.abbreviations);
        this.addSdf(JSDraw2.abbreviations);

        if (this.onAfterRead != null)
            this.onAfterRead();
    },

    addSdf: function (sdf) {
        if (sdf == null || sdf == "")
            return;

        var unknown = 0;
        var ss = sdf.split("$$$$");
        for (var k = 0; k < ss.length; ++k) {
            var r = JSDraw2.Table.readSdfRecord(ss[k], true);
            if (r == null)
                break;

            var template = r.props["T"];
            var customtemplate = r.props["CT"];
            var strname = r.props["Name"];
            var m = new JSDraw2.Mol();
            m.setMolfile(r.molfile);
            //this.normalize(m);
            if (template != null) {
                this.templates[template] = m;
            }
            else if (customtemplate != null) {
                this.customtemplates[customtemplate] = m;
            }
        }
    },

    _getAttachAtoms: function (m) {
        var list = [];
        if (m != null) {
            for (var i = 0; i < m.atoms.length; ++i) {
                var a = m.atoms[i];
                for (var k = 0; k < a.attachpoints.length; ++k)
                    list[a.attachpoints[k] - 1] = { apo: a.attachpoints[k], a: a };
            }
        }
        return list;
    },

    _alignMol: function (dest, a, src, a0, len) {
        if (len > 0)
            src.setBondLength(len);

        var bonds = dest.getNeighborBonds(a);
        if (bonds.length == 0) {
            src.offset(a.p.x - a0.p.x, a.p.y - a0.p.y);
        }
        else if (bonds.length == 1) {
            // offset to reference atom
            src.offset(a.p.x - a0.p.x, a.p.y - a0.p.y);

            b = bonds[0];
            // rotate to the reversed direction
            var deg = b.otherAtom(a).p.angleTo(a.p);
            var bs = src.getNeighborBonds(a0);
            if (bs.length == 1)
                src.rotate(a.p, deg + 60 - a0.p.angleTo(bs[0].otherAtom(a0).p));
            else if (bs.length == 2)
                src.rotate(a.p, deg + 180 - a0.p.middleAngle(bs[0].otherAtom(a0).p, bs[1].otherAtom(a0).p));
        }
        else if (bonds.length == 2) {
            // offset to reference atom
            src.offset(a.p.x - a0.p.x, a.p.y - a0.p.y);

            // rotate to the reversed direction
            var deg = a.p.middleAngle(bonds[0].otherAtom(a).p, bonds[1].otherAtom(a).p);
            var bs = src.getNeighborBonds(a0);
            if (bs.length == 1)
                src.rotate(a.p, deg + 60 - a0.p.angleTo(bs[0].otherAtom(a0).p));
            else if (bs.length == 2)
                src.rotate(a.p, deg + 180 - a0.p.middleAngle(bs[0].otherAtom(a0).p, bs[1].otherAtom(a0).p));
        }
        else {
            return false;
        }

        return true;
    }
};

﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.FormulaParser = {
    parse: function (s, orphan, bonds) {
        if (scil.Utils.isNullOrEmpty(s))
            return null;

        var salt = null;
        var p = s.indexOf('.');
        if (p > 0) {
            // e.g. --COOH.2HCl
            salt = s.substr(p + 1);
            s = s.substr(0, p);
        }

        var m = this._parse(s, orphan, bonds);
        if (m == null && orphan)
            m = this.pareFormulaAsSalt(s);

        if (m == null || m.atoms.length == 0)
            return null;

        if (!scil.Utils.isNullOrEmpty(salt)) {
            var m2 = this.pareFormulaAsSalt(salt);
            if (m2 == null || m2.atoms.length == 0)
                return null;

            var a1 = m.atoms[m.atoms.length - 1];
            var a2 = m2.atoms[0];
            m.mergeMol(m2);
            var b = new JSDraw2.Bond(a1, a2);
            b.type = JSDraw2.BONDTYPES.DUMMY;
            m.addBond(b);
        }

        JSDraw2.SuperAtoms.normalize(m);
        return m;
    },

    pareFormulaAsSalt: function (salt) {
        if (scil.Utils.isNullOrEmpty(salt))
            return null;

        var coef = 1;
        var s2 = salt.replace(/^[0-9]+/, "");
        if (s2.length < salt.length) {
            coef = parseInt(salt.substr(0, salt.length - s2.length));
            salt = s2;
        }
        if (coef < 1)
            return null;

        // --COOH.NH4+
        var m = null;
        var salt2 = salt.replace(/[+|-][1-9]?$/, "");
        var charge = this.parseCharge(salt.substr(salt2.length));
        salt = salt2;

        // strip H's
        var elem = salt.replace(/[H][0-9]{0,10}/g, "");
        m = this.molFromAtom(elem, false, charge);
        if (m == null) {
            var s2 = salt.replace(/^[A-Z][a-z]?/, "");
            if (s2.length < salt.length) {
                elem = salt.substr(0, salt.length - s2.length);
                m = this._parse(s2);
                if (m == null)
                    return null;
                var atts = JSDraw2.SuperAtoms._getAttachAtoms(m);
                if (atts == null || atts.length != 1)
                    return null;
                var a1 = atts[0].a;
                a1.attachpoints = [];
                if (elem != "H") {
                    var a2 = new JSDraw2.Atom(atts[0].a.p.clone(), elem);
                    var b = new JSDraw2.Bond(a1, a2);
                    m.addAtom(a2);
                    m.addBond(b);
                }
            }
        }

        if (m == null || m.atoms.length == 0)
            return null;

        var m0 = m.clone();
        for (var i = 1; i < coef; ++i) {
            var a1 = m.atoms[m.atoms.length - 1];
            var m3 = m0.clone();
            var a2 = m3.atoms[0];
            m.mergeMol(m3);
            var b = new JSDraw2.Bond(a1, a2);
            b.type = JSDraw2.BONDTYPES.DUMMY;
            m.addBond(b);
        }

        return m;
    },

    parseSalt: function (s) {
        if (scil.Utils.isNullOrEmpty(s))
            return null;

        var caps = s; // s.toUpperCase();
        var salts = JSDraw2.defaultoptions.salts || JSDraw2.salts;
        if (salts != null && salts[caps] != null) {
            if (salts[caps] == "")
                return { coef: 1, mf: null, mw: 0, s: s };
        }

        var s2 = "";
        if (!JSDraw2.FormulaParser.ignoresaltcoef) {
            var patt = /^[0-9]{0,10}[\.]?[0-9]{0,9}[ ]?/;
            var s2 = patt.exec(s) + "";
            if (s2.length == s.length)
                return null;
        }

        var coef = 1.0;
        if (s2 != "") {
            coef = parseFloat(s2);
            if (isNaN(coef))
                coef = 1.0;
        }
        s = s.substr(s2.length);
        caps = s; // s.toUpperCase();

        var mf = null;
        var mw = null;
        var salts = JSDraw2.defaultoptions.salts || JSDraw2.salts;
        if (salts != null && salts[caps] != null) {
            mf = salts[caps];
            mw = this.mf2mw(mf, true);
        }
        else {
            mf = s;
            mw = this.mf2mw(mf, true);

            // I#12284
            if (mw == null || mw == 0)
                return null;
        }

        return { coef: coef, mf: coef == 1 ? mf : coef + "(" + mf + ")", mw: Math.round(mw * (coef > 0 ? coef : 1) * 1000) / 1000, s: coef == 1 ? s : coef + s, stats: this.mf2Stats(mf, true) };
    },

    parseCharge: function (s) {
        if (scil.Utils.isNullOrEmpty(s))
            return 0;
        if (s == "+" || s == "++" || s == "+++")
            return s.length;
        else if (s == "-" || s == "--" || s == "---")
            return -s.length;

        if (s.length > 1 && (s.substr(s.length - 1) == '+' || s.substr(s.length - 1) == '-'))
            s = s.substr(s.length - 1) + s.substr(0, s.length - 1);
        return parseInt(s);
    },

    stripHs: function (s) {
        if (s == null || s.length <= 1)
            return s;
        var s2 = s.replace(/[+|-][1-9]?$/, "");
        var charge = s.substr(s2.length);
        if (/^[A-Z][a-z]?[H][0-9]{0,2}$/.test(s2)) {
            var elem = /^[A-z][a-z]?/.exec(s);
            var e = JSDraw2.PT[elem];
            if (e != null && e.m != null)
                return elem + charge;
        }
        else if (/^[H][0-9]{0,2}[A-Z][a-z]?$/.test(s2)) {
            var elem = /[A-z][a-z]?$/.exec(s);
            var e = JSDraw2.PT[elem];
            if (e != null && e.m != null)
                return elem + charge;
        }
        return s;
    },

    mergeStats: function (dest, from, coef) {
        if (dest == null)
            dest = { elements: {}, charges: 0, isotopes: {} };

        if (from != null) {
            if (coef == null)
                coef = 1;
            for (var e in from.elements) {
                if (dest.elements[e] == null)
                    dest.elements[e] = from.elements[e] * coef;
                else
                    dest.elements[e] += from.elements[e] * coef;
            }
            for (var e in from.isotopes) {
                if (dest.isotopes[e] == null)
                    dest.isotopes[e] = {};
                var iso = dest.isotopes[e];
                var iso2 = from.isotopes[e];
                for (var i in iso2) {
                    if (iso[i] == null)
                        iso[i] = iso2[i] * coef;
                    else
                        iso[i] += iso2[i] * coef;
                }
            }

            if (from.charges != null)
                dest.charges += from.charges * coef;
        }

        return dest;
    },

    getAtomStats: function (mol) {
        if (mol == null)
            return null;

        var ret = { elements: {}, charges: 0, isotopes: {}, bios: [] };

        var hs = 0;
        var multicenterHs = 0;
        for (var i = 0; i < mol.atoms.length; ++i) {
            var a = mol.atoms[i];
            if (a.elem == "5'") {
                if (ret.elements["H"] == null)
                    ret.elements["H"] = 1;
                else
                    ++ret.elements["H"];
            }
            else if (a.elem == "3'") {
                if (ret.elements["H"] == null)
                    ret.elements["H"] = 1;
                else
                    ++ret.elements["H"];
                if (ret.elements["O"] == null)
                    ret.elements["O"] = 1;
                else
                    ++ret.elements["O"];
            }
            else if (a.bio != null) {
                switch (a.bio.type) {
                    case JSDraw2.BIO.ANTIBODY:
                    case JSDraw2.BIO.PROTEIN:
                    case JSDraw2.BIO.GENE:
                    case JSDraw2.BIO.DNA:
                    case JSDraw2.BIO.RNA:
                        var se = new JSDraw2.SequenceEditor();
                        se.setXml(a.bio.sequences);
                        ret.bios.push({ mw: se.getMolWeight() });
                        break;
                }
            }
            else if (a.elem == "@") {
                var list = mol.getAllBonds(a);
                var dummy = 0;
                var sum = 0;
                for (var k = 0; k < list.length; ++k) {
                    if (list[k].type == JSDraw2.BONDTYPES.DUMMY) {
                        ++dummy;
                    }
                    else {
                        var val = list[k].valence();
                        if (val > 0)
                            sum += Math.floor(val);
                    }
                }
                if (dummy > 0)
                    multicenterHs += sum;
            }
            else if (a.elem == "#") {
                var salt = this.parseSalt(a.alias);
                if (salt != null)
                    this.mergeStats(ret, salt.stats, salt.coef);
            }
            else {
                var e = a.elem;
                if (a.isotope > 0) {
                    var n = ret.isotopes[e];
                    if (n == null)
                        ret.isotopes[e] = {};
                    var iso = ret.isotopes[e];
                    if (iso[a.isotope] == null)
                        iso[a.isotope] = 1;
                    else
                        iso[a.isotope] = iso[a.isotope] + 1;
                }
                else {
                    var n = ret.elements[e];
                    if (n == null)
                        ret.elements[e] = 1;
                    else
                        ret.elements[e] = n + 1;
                }
                hs += a.hcount;
            }
            ret.charges += a.charge;
        }

        hs -= multicenterHs;
        if (hs > 0) {
            if (ret.elements["H"] != null)
                ret.elements["H"] = hs + ret.elements["H"];
            else
                ret.elements["H"] = hs;
        }

        return ret;
    },

    stats2mw: function (stats) {
        if (stats == null)
            return null;

        var sum = 0;
        for (var k in stats.elements) {
            if (k == "D")
                sum += JSDraw2.PT["H"].iso[2] * stats.elements[k];
            else if (k == "T")
                sum += JSDraw2.PT["H"].iso[3] * stats.elements[k];
            else {
                var e = JSDraw2.PT[k];
                if (e == null || e.m == null)
                //continue;
                    return null;
                sum += e.m * stats.elements[k];
            }
        }

        if (stats.bios != null) {
            for (var i = 0; i < stats.bios.length; ++i)
                sum += stats.bios[i].mw;
        }

        sum += this._isotopemass(stats.isotopes);
        if (sum > 0)
            sum = scil.Utils.round(sum, 4);
        return sum;
    },

    stats2em: function (stats) {
        if (stats == null)
            return null;

        var sum = 0;
        for (var k in stats.elements) {
            var e = JSDraw2.PT[k];
            if (e == null || e.em == null)
            //continue;
                return null;
            sum += e.em * stats.elements[k];
        }

        sum += this._isotopemass(stats.isotopes);
        return sum;
    },

    _isotopemass: function (isotopes2) {
        if (isotopes2 == null)
            return 0;

        var sum = 0;
        for (var k in isotopes2) {
            var e = JSDraw2.PT[k];
            if (e == null || e.m == null)
                continue;

            var isotopes = isotopes2[k];
            for (var i in isotopes) {
                var m = e.iso[i];
                sum += (m == null ? e.m : m) * isotopes[i];
            }
        }
        return sum;
    },

    stats2mf: function (stats, html) {
        if (stats == null)
            return;

        var s = "";
        if (stats.elements["C"] != null) {
            s += "C";
            if (stats.elements["C"] > 1)
                s += (html ? "<sub>" + stats.elements["C"] + "</sub>" : stats.elements["C"]);
        }
        if (stats.elements["H"] != null) {
            s += "H";
            if (stats.elements["H"] > 1)
                s += (html ? "<sub>" + stats.elements["H"] + "</sub>" : stats.elements["H"]);
        }

        for (var e in stats.elements) {
            if (e != "C" && e != 'H' && e != 'R') {
                s += e;
                if (stats.elements[e] > 1)
                    s += (html ? "<sub>" + stats.elements[e] + "</sub>" : stats.elements[e]);
            }
        }

        for (var e in stats.isotopes) {
            var isotopes = stats.isotopes[e];
            for (var iso in isotopes) {
                if (html)
                    s += "<sup>" + iso + "</sup>" + e;
                else
                    s += "{" + iso + "}" + e;
                if (isotopes[iso] > 1)
                    s += (html ? "<sub>" + isotopes[iso] + "</sub>" : isotopes[iso]);
            }
        }

        var r = stats.elements['R'];
        if (r > 0) {
            s += 'R';
            if (r > 1)
                s += (html ? "<sub>" + r + "</sub>" : r);
        }

        if (stats.charges != 0) {
            var c = Math.abs(stats.charges);
            var t = (stats.charges > 0 ? "+" : "-") + (c > 1 ? c : '');
            if (html)
                s += "<sup>" + t + "</sup>";
            else
                s += t;
        }
        return s;
    },

    mf2mw: function (mf, issalt) {
        var stats = this.mf2Stats(mf, issalt);
        return this.stats2mw(stats);
    },

    normMF: function (mf) {
        var stats = this.mf2Stats(mf);
        return this.stats2mf(stats);
    },

    mf2Stats: function (mf, issalt) {
        if (mf == null || mf == "")
            return null;

        var charges = 0;
        var mf2 = mf.replace(/(([+|-][0-9]{0,2})|([ ][0-9]{0,2}[+|-]))$/, "");
        if (mf2.length < mf.length) {
            charges = this.parseCharge(mf.substr(mf2.length));
        }

        var ret = this.mf2Stats2(mf2);
        if (ret != null && charges != 0) {
            // I#10049
            if (issalt)
                charges = this.calcSaltCharges(ret, charges);

            ret.charges += charges;
        }

        return ret;
    },

    calcSaltCharges: function (ret, charges) {
        if (JSDraw2.defaultoptions.calcsaltcharges != true)
            return charges;

        if (charges >= 1) {
            if (charges > 1) {
                for (var k in ret.elements)
                    ret.elements[k] /= charges * 1.0;
            }

            if (ret.elements["H"] == null)
                ret.elements["H"] = 0;
            --ret.elements["H"];
            charges = 0;
        }

        return charges;
    },

    mf2Stats2: function (s) {
        var m = JSDraw2.SuperAtoms.get(s);
        if (m != null)
            return this.getAtomStats(m);

        var ret = { elements: {}, charges: 0 };

        var numpat = /^[0-9]+/;
        var sum = 0;
        var p;
        while ((p = s.indexOf('(')) >= 0) {
            if (p > 0) {
                var stats = this._mf2Stats(s.substr(0, p));
                if (stats == null)
                    return null;
                ret = this.mergeStats(ret, stats);
            }

            s = s.substr(p);

            var f = false;
            var n = 0;
            for (var i = 1; i < s.length; ++i) {
                var c = s.charCodeAt(i);
                if (c == 40) { // (
                    ++n;
                }
                else if (c == 41) { // )
                    if (n == 0) {
                        var bracket = s.substr(1, i - 1);
                        s = s.substr(i + 1);
                        var sub = s.match(numpat);
                        var k = 1;
                        if (sub != null && sub.length == 1) {
                            s = s.substr(sub[0].length);
                            k = parseInt(sub[0]);
                        }

                        var stats = this.mf2Stats2(bracket);
                        if (stats == null)
                            return null;
                        ret = this.mergeStats(ret, stats, k);

                        f = true;
                        break;
                    }
                    else {
                        --n;
                    }
                }
            }

            if (!f)
                return null;
        }

        var stats = this._mf2Stats(s);
        if (stats == null)
            return null;
        ret = this.mergeStats(ret, stats);
        return ret;
    },

    _mf2Stats: function (s) {
        var patt = /^[A-Z][a-z]?[0-9]{0,9}/;
        var patt2 = /^[A-Z][a-z]?/;

        var ret = { elements: {}, charges: 0 };
        while (s != "") {
            var c = patt.exec(s);
            if (c == null)
                return null;

            var s2 = c[0];
            if (s2 == "")
                return null;

            var symb = patt2.exec(s2)[0];
            var e = JSDraw2.PT[symb == "D" || symb == "T" ? "H" : symb];
            var n = symb.length == s2.length ? 1 : parseInt(s2.substr(symb.length));

            var stats = { elements: {}, charges: 0 };
            if (e == null) {
                var m = JSDraw2.SuperAtoms.get(symb);
                if (m == null || !(m.mw > 0))
                    return null;
                stats = this.getAtomStats(m);
            }
            else {
                if (!(e.m > null))
                    return null;
                else
                    stats.elements[symb] = 1;
            }
            ret = this.mergeStats(ret, stats, n);
            s = s.substr(s2.length);
        }
        return ret;
    },

    molFromAtom: function (elem, addAttachPoint, charge) {
        var s2 = elem.replace(/[+|-][1-9]?$/, "");
        if (s2.length < elem.length) {
            charge = this.parseCharge(elem.substr(s2.length));
            elem = s2;
        }

        var e = JSDraw2.PT[elem];
        if (e != null && e.a > 0) {
            m = new JSDraw2.Mol();
            var a = new JSDraw2.Atom(new JSDraw2.Point(0, 0), elem);
            if (charge != null)
                a.charge = charge;
            m.addAtom(a);
            if (addAttachPoint)
                a.attachpoints = [1];
            return m;
        }

        return null;
    },

    _parse: function (s, orphan, bonds) {
        if (scil.Utils.isNullOrEmpty(s))
            return null;

        if (new RegExp("^[\(][^\(\)]+[\)]$").test(s))
            s = s.substr(1, s.length - 2);

        var s2 = this.stripHs(s);
        var m = this.molFromAtom(s2, true);
        if (m != null)
            return m;

        var tokens = { O: ["O"], S: ["S"], Se: ["Se"], Te: ["Te"], Y: ["Y"], NH: ["N"], PH: ["P"], CO: ["C", "^=O"], CO2: ["C", "^=O", "O"], CH2: ["C"], C2H4: ["C", "C"], C3H6: ["C", "C", "C"], C4H8: ["C", "C", "C", "C"], C5H10: ["C", "C", "C", "C", "C"] };
        if (orphan)
            tokens.H = [];

        if (scil.Utils.startswith(s, '(')) {
            var p = s.indexOf(')');
            if (p > 0) {
                var s1 = s.substr(1, p - 1);
                var t = s.substr(p + 1);
                var s2 = t.replace(/^[0-9]+/, "");
                var repeat = 1;
                if (s2.length < t.length)
                    repeat = parseInt(t.substr(0, t.length - s2.length));
                var ret = this._parseConnectors(s1, orphan);
                if (ret != null && ret.remained == "") {
                    var atoms = [];
                    for (var i = 0; i < repeat; ++i)
                        atoms = atoms.concat(ret.atoms);
                    m = this._connect(atoms, s2);
                    if (m != null)
                        return m;
                }
            }
        }

        m = JSDraw2.SuperAtoms.get(s);
        if (m != null)
            return m;

        m = this.molFromAtom(s, true);
        if (m != null)
            return m;

        for (var k in tokens) {
            var m = this._tryFormula(k, tokens[k], s);
            if (m != null)
                return m;
        }

        if (s.length >= 3) {
            var elem = s.substr(0, 2);
            var e = JSDraw2.PT[elem];
            if (e != null && JSDraw2.PT.isMetal(e.a) &&
                (e != JSDraw2.PT.K && e != JSDraw2.PT.Na && e != JSDraw2.PT.Rb && e != JSDraw2.PT.Cs &&
                    e != JSDraw2.PT.Fr && e != JSDraw2.PT.Sb))
                return this._tryFormula(elem, [elem], s);
        }

        // Common Formula: --CnH[n*2]--, --CnH[n*2+1], --CnH[n*2-1], and --CnH[n*2-3]
        if (bonds == 1 || bonds == 2) {
            var reg = /^C[0-9]+H[0-9]+$/;
            if (reg.test(s)) {
                var p = s.indexOf('H');
                var cs = parseInt(s.substr(1, p - 1));
                var hs = parseInt(s.substr(p + 1));
                if (cs > 0 && (bonds == 2 && cs * 2 == hs /* --CnH[n*2]-- */ || bonds == 1 && (cs * 2 + 1 == hs /* --CnH[n*2+1]-- */ || cs * 2 - 1 == hs /* --CnH[n*2-1]-- */ || cs * 2 - 3 == hs /* --CnH[n*2-3]-- */))) {
                    var m = new JSDraw2.Mol();
                    var a1 = new JSDraw2.Atom(new JSDraw2.Point(0, 0), 'C');
                    var a2 = null;
                    a1.attachpoints = [1];
                    m.addAtom(a1);
                    for (var i = 1; i < cs; ++i) {
                        var y = i % 2 == 1 ? 0.5 : 0;
                        a2 = new JSDraw2.Atom(new JSDraw2.Point(a1.p.x + 1, y), 'C');
                        m.addAtom(a2);

                        var b = new JSDraw2.Bond(a1, a2);
                        if (i == cs - 1) {
                            if (cs * 2 - 1 == hs) /* --CnH[n*2-1]-- */
                                b.type = JSDraw2.BONDTYPES.DOUBLE;
                            else if (cs * 2 - 3 == hs) /* --CnH[n*2-3]-- */
                                b.type = JSDraw2.BONDTYPES.TRIPLE;
                        }
                        m.addBond(b);

                        a1 = a2;
                    }

                    if (bonds == 2)
                        (a2 == null ? a1 : a2).attachpoints = [2];

                    return m;
                }
            }
        }

        return null;
    },

    _parseConnectors: function (s, orphan) {
        var tokens = { O: ["O"], S: ["S"], Se: ["Se"], Te: ["Te"], Y: ["Y"], NH: ["N"], PH: ["P"], CO: ["C", "=O"], CO2: ["C", "=O", "O"], CH2: ["C"], C2H4: ["C", "C"], C3H6: ["C", "C", "C"], C4H8: ["C", "C", "C", "C"], C5H10: ["C", "C", "C", "C", "C"] };
        if (orphan)
            tokens.H = [];

        var atoms = [];
        while (s.length > 0) {
            var findone = false;
            for (var k in tokens) {
                if (scil.Utils.startswith(s, k)) {
                    atoms = atoms.concat(tokens[k]);
                    s = s.substr(k.length);
                    findone = true;
                    break;
                }
            }

            if (!findone)
                break;
        }

        return atoms.length == 0 ? null : { atoms: atoms, remained: s };
    },

    _tryFormula: function (prefix, atoms, s) {
        if (!scil.Utils.startswith(s, prefix, true))
            return null;

        return this._connect(atoms, s.substr(prefix.length));
    },

    _connect: function (atoms, name) {
        var m = JSDraw2.SuperAtoms.get(name);
        if (m == null) {
            m = this._parse(name, null, 1);
            if (m == null)
                m = this.molFromAtom(name, false);
        }

        if (m == null)
            return;
        m = m.clone();

        var atts = JSDraw2.SuperAtoms._getAttachAtoms(m);
        if (atts == null || atts.length != 1)
            return null;

        var a1 = atts[0].a;
        var a2 = null;
        var branch = null;
        a1.attachpoints = [];
        for (var i = atoms.length - 1; i >= 0; --i) {
            var c = atoms[i];

            if (c.substr(0, 1) == "^") {
                branch = c.substr(1);
                continue;
            }

            // I#12074
            a1 = this._connectAtom(a1, c, m);
            if (branch != null) {
                this._connectAtom(a1, branch, m);
                branch = null;
            }
        }

        a1.attachpoints = [1];
        return m;
    },

    _connectAtom: function (a1, c, m) {
        var doublebond = false;
        if (c.substr(0, 1) == "=") {
            c = c.substr(1);
            doublebond = true;
        }

        var p = a1.p.clone();
        p.offset(1, 0);
        var a2 = new JSDraw2.Atom(p, c);
        var b = new JSDraw2.Bond(a1, a2);
        if (doublebond)
            b.type = JSDraw2.BONDTYPES.DOUBLE;
        m.addAtom(a2);
        m.addBond(b);
        return a2;
    }
};
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.Toolbar = scil.extend(scil._base, {
    constructor: function (editor) {
        this.toolbar = null;
        this.editor = editor;
        this.options = editor.options;
        this.toptoolbarTbody = null;
        this.BORDERSTYLE = "solid 1px #ccc";
        this.toolbarbkcolor = "#fcfcfc";
    },

    destroy: function () {
    },

    getButtons: function () {
        return this.toolbar.getElementsByTagName("img");
    },

    show: function (f) {
        this.toolbarrow.style.display = f ? "" : "none";
    },

    createToolbars: function (div) {
        var elems = ["H", "C", "N", "O", "S", "P", "F", "Cl", "Br", "..."];
        if (this.options.query)
            elems.push("&#9679;");

        var style = { border: this.BORDERSTYLE, background: JSDraw2.Skin.jsdraw.bkcolor };

        var me = this.editor;
        var mainbody = scil.Utils.createTable(null, 0, 0, style);
        this.toolbar = mainbody;
        dojo.connect(mainbody.parentNode, "onclick", function (e) { me.onSelBtn(e == null ? window.event : e); e.preventDefault(); });
        scil.Utils.unselectable(mainbody.parentNode);

        var background = JSDraw2.Skin.jsdraw.bkcolor;
        if (this.options.skin == "si")
            background += " url(" + JSDraw2.Skin.jsdraw.toolbarbk + ") repeat-x ";
        else if (JSDraw2.Skin.jsdraw.bkimg != null)
            background += " url(" + JSDraw2.Skin.jsdraw.bkimg + ") repeat-x ";
        var tr = scilligence.Utils.createElement(mainbody, "tr", null, { background: background });
        this.toolbarrow = tr;

        var s = scilligence.Utils.imgTag("jsdraw.gif", null, "title='" + this.res("About JSDraw") + "' style='width:" + this.options.btnsize + "px;height:" + this.options.btnsize + "px;' cmd='jsdraw'");
        if (!this.isSkinW8())
            scilligence.Utils.createElement(tr, "td", s, { paddingLeft: "3px" });

        var tbody = scilligence.Utils.createTable(scilligence.Utils.createElement(tr, "td"), 0, 0, { marginTop: (this.options.skin == "si" ? "8px" : "2px"), marginBottom: "1px" });
        if (scilligence.Utils.isTouch && !scilligence.Utils.isIE)
            dojo.connect(tbody.parentNode, "ontouchmove", function (e) { e.preventDefault(); });
        if (this.isSkinW8()) {
            tbody.parentNode.align = this.options.toolbaralign == null ? 'center' : this.options.toolbaralign;
            if (this.options.toolbarleftmargin != null)
                tbody.parentNode.style.marginLeft = this.options.toolbarleftmargin;
        }
        this.toptoolbarTbody = tbody;
        this.recreateTopToolbar();

        tr = scilligence.Utils.createElement(mainbody, 'tr');
        if (!this.isSkinW8()) {
            td = scilligence.Utils.createElement(tr, 'td', null, { verticalAlign: "top", backgroundPosition: "left" });
            tbody = scilligence.Utils.createTable(td, 1, null, { color: "#000" });
            var style = { width: this.options.btnsize + "px", height: this.options.btnsize + "px", fontWeight: "bold", cursor: 'default', textAlign: 'center', verticalAlign: 'middle', padding: "2px" };
            if (this.options.scale != 1)
                style.fontSize = (this.options.scale * 100) + "%";
            for (var i = 0; i < elems.length; ++i) {
                var r = scilligence.Utils.createElement(tbody, 'tr');
                var d = scilligence.Utils.createElement(r, 'td', elems[i], style, { cmd: elems[i] });
                if (elems[i] == "...")
                    d.setAttribute('title', this.res("Element Periodic Table"));
                else if (elems[i] == "&#9679;")
                    d.setAttribute('title', this.res("Atom Properties"));
                this.editor.connectHandlers.push(dojo.connect(d, "onmouseover", function () { this.style.backgroundColor = JSDraw2.Skin.jsdraw.hovercolor; }));
                this.editor.connectHandlers.push(dojo.connect(d, "onmouseout", function () { this.style.backgroundColor = ''; }));
            }
        }
        td = scilligence.Utils.createElement(tr, "td", null, { borderTop: this.BORDERSTYLE, borderLeft: this.BORDERSTYLE });
        if (this.isSkinW8()) {
            td.colSpan = 2;
            td.style.borderLeft = "";
        }

        div.parentNode.insertBefore(mainbody.parentNode, div);
        td.appendChild(div);
        div.style.border = "";

        this.editor.maintable = mainbody.parentNode;
    },

    _makePluginFun: function (fn) {
        var me = this.editor;
        return function (e) {
            fn(me);
            (e.srcElement || e.target).setAttribute("jsdrawactivate", "false");
            e.preventDefault();
        }
    },

    recreateTopToolbar: function () {
        var width = this.editor.dimension.x;
        var tbody = this.toptoolbarTbody;
        var buttons = this.createButtons(width);
        var jsdtb = "__jsd_tb_" + this.editor.id;
        var me = this;

        scilligence.Utils.removeAll(tbody);

        var tr = scilligence.Utils.createElement(tbody, "tr");
        var tr2 = null;
        if (this.isSkinW8())
            tr2 = scilligence.Utils.createElement(tbody, "tr", null, { height: "6px", fontsize: "1px" });

        for (var i = 0; i < buttons.length; ++i) {
            var b = buttons[i];
            this.createButton(tr, tr2, b, jsdtb);
        }

        var plugins = JSDraw2.defaultoptions.plugins;
        if (this.options.plugins != null) {
            if (plugins == null)
                plugins = this.options.plugins;
            else
                plugins = plugins.concat(this.options.plugins);
        }
        if (plugins != null) {
            var w = Math.round(2 * this.options.btnsize / 20);
            var nleft = 0;
            var nright = 0;
            for (var i = 0; i < plugins.length; ++i) {
                var plugin = plugins[i];
                if (plugin.location == "left") {
                    if (nleft++ == 0) {
                        td = scilligence.Utils.createElement(null, "td", "<img src='" + scil.Utils.imgSrc("img/sep.gif") + "' alt='separator' style='margin:0 " + w + "px 0 " + w + "px;'>");
                        tr.insertBefore(td, tr.firstChild);
                        tr2.insertBefore(scilligence.Utils.createElement(null, "td"), tr2.firstChild);
                    }
                    td = scilligence.Utils.createElement(null, "td");
                    tr.insertBefore(td, tr.firstChild);
                    tr2.insertBefore(scilligence.Utils.createElement(null, "td"), tr2.firstChild);
                }
                else {
                    if (nleft++ == 0) {
                        td = scilligence.Utils.createElement(tr, "td", "<img src='" + scil.Utils.imgSrc("img/sep.gif") + "' alt='separator' style='margin:0 " + w + "px 0 " + w + "px;'>");
                        scilligence.Utils.createElement(tr2, "td");
                    }
                    td = scilligence.Utils.createElement(tr, "td");
                    scilligence.Utils.createElement(tr2, "td");
                }
                this.createBtnImg(td, plugins[i].iconurl, null, null, plugins[i].tooltips, null, plugins[i].width, plugins[i].label);
                this.editor.connectHandlers.push(dojo.connect(td, "onclick", this._makePluginFun(plugins[i].onclick)));
            }
        }
    },

    createButtons: function (width) {
        var buttons = [];

        var bonds = [{ c: "triple", t: "Triple bond", label: "Triple" },
                { c: "up", t: "Wedge bond", label: "Up" }, { c: "down", t: "Hash bond", label: "Down" }, { c: "wiggly", t: "Wiggle bond", label: "Wiggle" },
                { c: "delocalized", t: "Delocalized bond", label: "Delocalized" }, { c: "either", t: "Either double bond", label: "Either" },
                { c: "boldhash", t: "Hashed bond", label: "Hashed" }, { c: "bold", t: "Bold bond", label: "Bold" },
                { c: "dummy", t: "Ionic bond", label: "Ionic" }, { c: "unknown", t: "Dotted bond", label: "Dotted"}];
        if (this.options.query)
            bonds.concat([{ c: "singledouble", t: "Single or Double", label: "Single" }, { c: "singlearomatic", t: "Single or Aromatic" }, { c: "doublearomatic", t: "Double or Aromatic"}]);

        var smallscreen = this.isSkinW8() && width <= 400;

        var filesubmenus = [];
        if (this.options.showfilemenu != false) {
            filesubmenus.push({ c: "save", t: "Export", label: "Export" });
            filesubmenus.push({ c: "open", t: "Import", label: "Import" });
        }

        var selecttools = [{ c: "lasso", t: "Lasso Selection", label: "Lasso" },
            { c: "selfrag", t: "Select Fragment", label: "Fragment" }, { c: "selectall", t: "Select All", label: "All"}];

        var addabout = false;
        if (this.options.toolbarmode == "tlc") {
            buttons.push({ c: "new", t: "New", label: "New", sub: filesubmenus });
            buttons.push({ c: "tlctemplate", t: "Template", label: "Template" });
            buttons.push({ c: "|" });
            buttons.push({
                c: "spot-circle", t: "Circle Spot", label: "Circle", sub: [
                    { c: "spot-hellipse", t: "Horizontal Ellipse Spot", label: "Ellipse" },
                    { c: "spot-vellipse", t: "Vertical Ellipse Spot", label: "Ellipse" },
                    { c: "spot-halfellipseup", t: "Half-Ellipse Spot", label: "Ellipse" },
                    { c: "spot-halfellipsedown", t: "Half-Ellipse Spot", label: "Ellipse" },
                    { c: "spot-blowingup", t: "Blowing-up Spot", label: "Blowing" },
                    { c: "spot-blowingdown", t: "Blowing-down Spot", label: "Blowing" },
                    { c: "spot-crescentup", t: "Crescent Spot", label: "Crescent" },
                    { c: "spot-crescentdown", t: "Crescent Spot", label: "Crescent" }
                ]
            });
            buttons.push({ c: "eraser", t: "Eraser", label: "Eraser" });
            buttons.push({ c: "|" });
            buttons.push({ c: "tlc", t: "TLC Plate", label: "TLC" });
            buttons.push({ c: "tlcnumber", t: "Number Plate", label: "Number" });
            buttons.push({ c: "electrophoresis", t: "Electrophoresis Gel Plate", label: "Electrophoresis" });
            buttons.push({ c: "|" });
            buttons.push({ c: "text", t: "Text/Atom Label", label: "Text" });
            buttons.push({ c: "|" });
            buttons.push({ c: "undo", t: "Undo", label: "Undo" });
            buttons.push({ c: "redo", t: "Redo", label: "Redo" });
            buttons.push({ c: "|" });
            buttons.push({ c: "center", t: "Move to center", label: "Center" });
            buttons.push({ c: "zoomin", t: "Zoom in", label: "Zoom" });
            buttons.push({ c: "zoomout", t: "Zoom out", label: "Zoom" });

            addabout = true;
        }
        else if (this.options.toolbarmode == "spectrum") {
            buttons.push({ c: "new", t: "New", label: "New", sub: filesubmenus });
            buttons.push({ c: "|" });
            buttons.push({ c: "assaycurve", t: "Assay Curve", label: "Assay" });
            buttons.push({ c: "spectrum", t: "Spectrum", label: "Spectrum" });
            buttons.push({ c: "|" });
            buttons.push({ c: "eraser", t: "Eraser", label: "Eraser" });
            buttons.push({ c: "|" });
            buttons.push({ c: "select", t: "Box Selection", label: "Box", sub: selecttools });
            buttons.push({ c: "|" });
            buttons.push({ c: "undo", t: "Undo", label: "Undo" });
            buttons.push({ c: "redo", t: "Redo", label: "Redo" });
            buttons.push({ c: "|" });
            buttons.push({ c: "center", t: "Move to center", label: "Center" });
            buttons.push({ c: "zoomin", t: "Zoom in", label: "Zoom" });
            buttons.push({ c: "zoomout", t: "Zoom out", label: "Zoom" });

            addabout = true;
        }
        else if (this.options.toolbarmode == "workflow") {
            buttons.push({ c: "new", t: "New", label: "New", sub: filesubmenus });
            buttons.push({ c: "|" });
            buttons.push({ c: "select", t: "Box Selection", label: "Box", sub: selecttools });
            buttons.push({ c: "moveview", t: "Move/View", label: "Move" });
            buttons.push({ c: "zoombox", t: "Zoom Box", label: "Zoom" });
            buttons.push({ c: "|" });
            buttons.push({ c: "rectangle", t: "Rectangle", label: "Rectangle" });
            buttons.push({ c: "diamond", t: "Diamond", label: "Diamond" });
            buttons.push({ c: "ellipse", t: "Ellipse", label: "Ellipse" });
            buttons.push({ c: "dreversed", t: "D Reversed", label: "D Reversed" });
            buttons.push({ c: "dshape", t: "D Shapre", label: "D Shapre" });
            buttons.push({ c: "|" });
            buttons.push({ c: "arrow", t: "Reaction arrow", label: "Reaction" });
            buttons.push({ c: "text", t: "Text/Atom Label", label: "Text" });
            buttons.push({ c: "|" });
            buttons.push({ c: "eraser", t: "Eraser", label: "Eraser" });
            buttons.push({ c: "|" });
            buttons.push({ c: "undo", t: "Undo", label: "Undo" });
            buttons.push({ c: "redo", t: "Redo", label: "Redo" });
            buttons.push({ c: "|" });
            buttons.push({ c: "center", t: "Move to center", label: "Center" });
            buttons.push({ c: "zoomin", t: "Zoom in", label: "Zoom" });
            buttons.push({ c: "zoomout", t: "Zoom out", label: "Zoom" });

            addabout = true;
        }
        else if (this.options.toolbarmode == "helm") {
            org.helm.webeditor.Interface.getHelmToolbar(buttons, filesubmenus, selecttools, this.options);
            if (this.options.showabout != false)
                addabout = true;
        }
        else {
            if (this.options.pastechemdraw) {
                filesubmenus.push({ c: "pastechemdraw", t: "Paste ChemDraw, ISIS/Draw...", label: "Paste" });
                filesubmenus.push({ c: "copychemdraw", t: "Copy ChemDraw, ISIS/Draw, Word...", label: "Copy" });
            }

            if (this.isSkinW8()) {
                filesubmenus.push({ c: "about", t: "About JSDraw", label: "About" });
                buttons.push({ c: "new", t: "New", label: "New", sub: filesubmenus });
            }
            else {
                buttons.push({ c: "new", t: "New", sub: filesubmenus, label: "New" });
            }

            if (scilligence.Utils.serviceAvailable() && JSDraw2.Security.kEdition != "Lite")
                buttons.push({ c: "n2s", t: "Name to Structure", label: "N2S", sub: [{ c: "cleanup", t: "Clean up", label: "Clean"}] });
            if (buttons.length > 0)
                buttons.push({ c: "|" });

            if (!this.options.appmode) {
                selecttools.push({ c: "copy", t: "Copy", label: "Copy" });
                selecttools.push({ c: "cut", t: "Cut", label: "Cut" });
                selecttools.push({ c: "paste", t: "Paste", label: "Paste" });
            }

            buttons.push({ c: "select", t: "Box Selection", label: "Box", sub: selecttools });
            buttons.push({ c: "center", t: "Move to center", label: "Center", sub: smallscreen ? null : [{ c: "zoomin", t: "Zoom in", label: "Zoom" }, { c: "zoomout", t: "Zoom out", label: "Zoom" }, { c: "rotate", t: "Rotate", label: "Rotate" }, { c: "fliph", t: "Flip Horizontal", label: "Flip" }, { c: "flipv", t: "Flip Vertical", label: "Flip"}] });
            buttons.push({ c: "moveview", t: "Move/View", label: "Move", sub: [{ c: "zoombox", t: "Zoom Box", label: "Zoom"}] });
            buttons.push({ c: "|" });

            buttons.push({ c: "eraser", t: "Eraser", label: "Eraser" });
            if (!this.options.appmode)
                buttons.push({ c: "undo", t: "Undo", label: "Undo", sub: [{ c: "redo", t: "Redo", label: "Redo"}] });
            buttons.push({ c: "|" });
            buttons.push({ c: "single", t: "Single bond", label: "Single" });
            buttons.push({ c: "double", t: "Double bond", label: "Double", sub: bonds });
            buttons.push({ c: "chain", t: "Chain Tool", label: "Chain" });
            buttons.push({ c: "|" });

            var i = 0;
            var last = null;
            JSDraw2.SuperAtoms.read();
            var templateicons = { benzene: 1, hexane: 1, pentane: 1, propane: 1, butane: 1, heptane: 1, octane: 1 };
            for (var k in JSDraw2.SuperAtoms.templates) {
                ++i;
                var name = k;
                var c = templateicons[k.toLowerCase()] ? k.toLowerCase() : "template";
                if (i <= 3) {
                    last = { c: c, cmd: "template." + k, label: name, t: name };
                    buttons.push(last);
                }
                else {
                    if (last.sub == null)
                        last.sub = [];
                    last.sub.push({ c: c, cmd: "template." + k, label: name, t: name });
                }
            }

            if (JSDraw2.SuperAtoms.hasCustomTemplates() && this.options.showcustomtemplates != false)
                last.sub.push({ c: "templates", cmd: "template.[custom]", label: "Templates", t: "Custom Templates" });

            buttons.push({ c: "|" });
            if (this.isSkinW8()) {
                var elements = [{ c: "e-H", t: "Element H", label: "Hydrogen" },
                    { c: "e-O", t: "Element O", label: "Oxygen" }, { c: "e-N", t: "Element N", label: "Nitrogen" }, { c: "e-S", t: "Element S", label: "Sulfur" },
                    { c: "e-P", t: "Element P", label: "Phosphorus" }, { c: "e-F", t: "Element F", label: "Fluorine" }, { c: "e-Cl", t: "Element Cl", label: "Chlorine" },
                    { c: "e-Br", t: "Element Br", label: "Bromine" }, { c: "e-more", t: "Element Periodic Table", label: "P.T."}];
                buttons.push({ c: "e-C", t: "Element C", label: "Carbon", sub: elements });
            }

            if (JSDraw2.Security.kEdition != "Lite") {
                buttons.push({
                    c: "text", t: "Text/Atom Label", label: "Text", sub: smallscreen ? null : [{ c: "sgroup", t: "SGroup - Tag Atom/Bond/Bracket", label: "SGroup" },
                        { c: "bracket", t: "Bracket", label: "Bracket" }, { c: "symbol", t: "Symbol", label: "Symbol"}]
                });
                buttons.push({
                    c: "rectangle", t: "Rectangle", label: "Rectangle", sub: [{ c: "diamond", t: "Diamond", label: "Diamond" }, { c: "ellipse", t: "Ellipse", label: "Ellipse" },
                        { c: "dreversed", t: "D Reversed", label: "D Reversed" }, { c: "dshape", t: "D Shapre", label: "D Shapre" },
                        { c: "curve", t: "Curve", label: "Curve" }, { c: "tlc", t: "TLC Plate", label: "TLC" }, { c: "tlctemplate", t: "Template", label: "Template" },
                        { c: "electrophoresis", t: "Electrophoresis Gel Plate", label: "Electrophoresis" }, { c: "assaycurve", t: "Assay Curve", label: "Assay" }, { c: "spectrum", t: "Spectrum", label: "Spectrum"}]
                });
            }

            buttons.push({ c: "chargep", t: "Increase charges", label: "Charge", sub: [{ c: "chargen", t: "Descrease charges", label: "Charge"}] });

            if (this.options.rxn && JSDraw2.Security.kEdition != "Lite") {
                buttons.push({ c: "|" });
                buttons.push({
                    c: "arrow", t: "Reaction arrow", label: "Reaction", sub: [{ c: "plus", t: "Reaction Plus", label: "Plus" }, { c: "rxn", t: "Clean up reaction", label: "Clean" },
                { c: "copyprod", t: "Copy reactants to products", label: "R->P" }, { c: "rxnmap", t: "Map reaction", label: "Map" }, { c: "rxnmap2", t: "Clear reaction map", label: "Clear"}]
                });
            }
            if (this.options.biology && JSDraw2.Security.kEdition != "Lite") {
                if (this.editor.helm != null)
                    org.helm.webeditor.Interface.addToolbar(buttons, null, null, this.options);
                buttons.push({ c: "seq", t: "Peptide Sequence", label: "Peptide", sub: [{ c: "helix", t: "DNA Sequence", label: "DNA" }, { c: "rna", t: "RNA Sequence", label: "RNA" }, { c: "antibody", t: "Antibody", label: "Antibody" }, { c: "protein", t: "Protein", label: "Protein" }, { c: "gene", t: "Gene", label: "Gene"}] });
            }

            if (this.isSkinW8() && this.options.inktools && !smallscreen) {
                buttons.push({ c: "|" });
                buttons.push({ c: "inkred", t: "Ink - Red", label: "Ink", sub: [{ c: "inkblue", t: "Ink - Blue", label: "Ink" }, { c: "inkgreen", t: "Ink - Green", label: "Ink" }, { c: "inkclear", t: "Clear Ink", label: "Clear1" }, { c: "inkclearall", t: "Clear All Inks", label: "Clear"}] });
            }

            if (JSDraw2.Security.kEdition != "Lite") {
                if (this.options.sendquery) {
                    buttons.push({ c: "|" });
                    var list = [{ c: "chemspider", t: "Search ChemSpider", label: "ChemSpider"}];
                    if (JSDraw2.defaultoptions.reaxys != false)
                        list.push({ c: "reaxys", t: "Search Reaxys", label: "Reaxys" });
                    buttons.push({ c: "pubchem", t: "Search PubChem", label: "PubChem", sub: list });
                }
            }

            if (this.options.usechemdraw)
                buttons.push({ c: "chemdraw", t: "ChemDraw Editor", label: "ChemDraw" });
        }

        if (JSDraw2.Fullscreen != null) {
            if (this.options.exitfullscreen) {
                buttons.push({ c: "|" });
                buttons.push({ c: "fullscreen2", t: "Regular Size", label: "Fullscreen" });
            }
            else if (this.options.fullscreen) {
                buttons.push({ c: "|" });
                buttons.push({ c: "fullscreen", t: "Fullscreen Size", label: "Fullscreen" });
            }
        }

        if (addabout) {
            buttons.push({ c: "|" });
            buttons.push({ c: "about", t: "About JSDraw", label: "About" });
        }

        if (this.isSkinW8())
            this.relayoutButtonsByWidth(buttons, width, this.options.plugins == null ? 0 : this.options.plugins.length);
        return buttons;
    },

    relayoutButtonsByWidth: function (buttons, width, nplugins) {
        var n = Math.round(width / (this.options.skin == "w8" ? 50 : 60)) - buttons.length - nplugins;
        if (n < 0 && n < -8) {
            for (var i = buttons.length - 1; i >= 0; --i) {
                if (buttons[i].c == "|")
                    buttons.splice(i, 1);
            }
            n = Math.round(width / (this.options.skin == "w8" ? 50 : 60)) - buttons.length - nplugins;
        }
        if (n == 0)
            return;

        if (n > 0) {
            for (var i = 0; i < buttons.length; ++i) {
                if (buttons[i].c == "ring5") {
                    var sub = buttons[i].sub;
                    for (var j = 0; j < n; ++j) {
                        buttons.splice(i + j + 1, 0, sub[0]);
                        sub.splice(0, 1);
                        buttons[i + j].sub = null;
                        if (sub.length == 0)
                            break;
                        else
                            buttons[i + j + 1].sub = sub;
                    }
                    break;
                }
            }
        }
        else if (n < 0) {
            n = -n;
            var ranks;
            if (this.options.toolbarmode == "workflow")
                ranks = ["zoomout", "zoombox", "redo", "zoomin", "eraser", "moveview"];
            else if (this.options.toolbarmode == "helm")
                ranks = ["zoombox", "zoomout", "zoomin", "redo", "eraser"];
            else
                ranks = ["double", "chain", "pubchem", "pentane", "hexane", "zoombox", "moveview", "zoomout", "zoomin", "redo", "n2s", "eraser", "seq", "chemdraw", "chargep", "rectangle", "arrow", "text"];

            for (var i = buttons.length - 1; i > 0; --i) {
                if (width < 500 && buttons[i].c == "|") {
                    buttons.splice(i, 1);
                    continue;
                }
                var rank = scil.Utils.indexOf(ranks, buttons[i].c);
                if (rank >= 0 && rank + 1 <= n) {
                    while (i > 0 && buttons[i - 1].c == "|") {
                        buttons.splice(i - 1, 1);
                        --i;
                    }
                    if (buttons[i - 1].sub == null)
                        buttons[i - 1].sub = [];
                    var sub = buttons[i - 1].sub;
                    if (this.options.skin == "si" && sub.length > 0)
                        sub.push("|");
                    sub.push(buttons[i]);
                    var list = buttons[i].sub;
                    buttons[i].sub = null;
                    if (list != null) {
                        for (var k = 0; k < list.length; ++k)
                            sub.push(list[k]);
                    }
                    buttons.splice(i, 1);
                }
            }
        }
    },

    res: function (s) {
        return JSDraw2.Language.res(s);
    },

    isSkinW8: function () {
        return this.options.skin == "w8" || this.options.skin == "si";
    },

    setHoverable: function (e) {
        this.editor.connectHandlers.push(dojo.connect(e, "onmouseover", function () { this.style.background = JSDraw2.Skin.jsdraw.hovercolor; }));
        this.editor.connectHandlers.push(dojo.connect(e, "onmouseout", function () { this.style.background = this.getAttribute("pushed") == null ? "" : JSDraw2.Skin.jsdraw.btnselcolor; }));
    },

    exchangeButton: function (parent, td) {
        if (this.options.skin == "si") {
            //parent.innerHTML
            //"<img style="margin-top: -5px;" src="src/../w8/Pentane.png"><div style="width: 42px; text-align: center; color: gray; overflow: hidden; font-size: 9px; margin-top: -11px; white-space: nowrap;">Pentane</div>"
            //td.innerHTML
            //"<table cellspacing="0" cellpadding="0"><tbody><tr><td><img style="margin-top: -5px;" src="src/../w8/Butane.png"></td><td><div style="width: 42px; text-align: center; color: gray; overflow: hidden; font-size: 9px; margin-top: -11px; white-space: nowrap;">Butane</div></td></tr></tbody></table>"
            var img1 = parent.childNodes[0];
            var txt1 = img1.nextSibling;

            var tds = td.childNodes[0].getElementsByTagName("td");
            var img2 = tds[0].childNodes[0];
            var txt2 = tds[1].childNodes[0];

            var src = img1.src;
            var subtitle = txt1.innerHTML;
            var cmd = dojo.attr(parent, "cmd");
            var title = dojo.attr(parent, "title");

            img1.src = img2.src;
            txt1.innerHTML = txt2.innerHTML;
            dojo.attr(parent, "cmd", dojo.attr(td, "cmd"));
            dojo.attr(parent, "title", dojo.attr(td, "title"));

            img2.src = src;
            txt2.innerHTML = subtitle;
            dojo.attr(td, "cmd", cmd);
            dojo.attr(td, "title", title);

        }
        else {
            var src = parent.src;
            var cmd = dojo.attr(parent, "cmd");
            var title = dojo.attr(parent, "title");
            var subtitle = parent.nextSibling != null ? parent.nextSibling.innerHTML : null;

            parent.src = td.src;
            dojo.attr(parent, "cmd", dojo.attr(td, "cmd"));
            dojo.attr(parent, "title", dojo.attr(td, "title"));
            if (td.nextSibling != null)
                parent.nextSibling.innerHTML = td.nextSibling.innerHTML;

            td.src = src;
            dojo.attr(td, "cmd", cmd);
            dojo.attr(td, "title", title);
            if (td.nextSibling != null)
                td.nextSibling.innerHTML = subtitle;
        }
    },

    createButton: function (tr, tr2, b, jsdtb) {
        var td;
        var img;
        var w = Math.round(2 * this.options.btnsize / 20);
        var tbid = jsdtb + "_" + b.c;
        if (b.c == "|") {
            td = scilligence.Utils.createElement(tr, "td", "<img src='" + scil.Utils.imgSrc("img/sep.gif") + "' style='margin:0 " + 2 * w + "px 0 " + 2 * w + "px;width:" + w + "px;vertical-align:middle;'>");
        }
        else {
            td = scilligence.Utils.createElement(tr, "td");
            var src = null;
            if (this.isSkinW8())
                src = "w8/" + b.c + ".png";
            else
                src = "img/" + b.c + ".gif";
            img = this.createBtnImg(td, (b.img != null ? b.img : scil.Utils.imgSrc(src)), tbid, b.cmd != null ? b.cmd : b.c, this.res(b.t), null, null, this.res(b.label));
        }

        if (b.hidden)
            td.style.display = "none";

        if (b.sub == null) {
            if (tr2 != null)
                scilligence.Utils.createElement(tr2, "td");
            return td;
        }

        var td1;
        if (this.options.skin == "si") {
            td1 = scil.Utils.createElement(img.parentNode.parentNode, "td", "&#9660;", { fontSize: "10px", color: "gray", borderTop: "solid 1px #ccc", borderRight: "solid 1px #ccc", borderBottom: "solid 1px #ccc" });
            this.setHoverable(td1);
        }
        else {
            if (tr2 == null)
                td1 = scilligence.Utils.createElement(tr, "td", "&#9660;", { fontSize: (this.options.btnsize / 2) + "px", verticalAlign: "bottom", color: "gray" });
            else
                td1 = scilligence.Utils.createElement(tr2, "td", null, { height: "10px", background: scil.Utils.imgSrc("w8/handle.png", true) + " no-repeat center center" });
        }

        if (b.hidden)
            td1.style.display = "none";

        if (scilligence.Utils.isTouch) {
            dojo.connect(td, "ontouchmove", function () { JSDraw2.Menu.open(tbid + "_sub"); });
            dojo.connect(td1, "onclick", function () { JSDraw2.Menu.open(tbid + "_sub"); });
        }
        else {
            if (window.navigator.msPointerEnabled) {
                dojo.connect(td, "onMSPointerMove", function (e) {
                    if (e.buttons == 1)
                        JSDraw2.Menu.open(tbid + "_sub");
                }, false);
            }
            if (this.isSkinW8()) {
                dojo.connect(td1, "onclick", function () {
                    JSDraw2.Menu.open(tbid + "_sub");
                });
                //if (!scilligence.Utils.isIE)
                //    dojo.connect(td, "onclick", function () { JSDraw2.Menu.close(); });
                td1.setAttribute("title", this.res("click to expand"));
                dojo.connect(td1, "onmouseover", function (e) { (e.target || e.srcElement).style.backgroundImage = scil.Utils.imgSrc("w8/handle2.png", true); });
                dojo.connect(td1, "onmouseout", function (e) { (e.target || e.srcElement).style.backgroundImage = scil.Utils.imgSrc("w8/handle.png", true); });
            }
            else {
                dojo.connect(td1, "onmouseover", function () { JSDraw2.Menu.open(tbid + "_sub"); });
                dojo.connect(td1, "onmouseout", function () { JSDraw2.Menu.closetime(); });
                dojo.connect(td1, "onclick", function () { JSDraw2.Menu.close(); });
            }
        }

        var tbody = scil.Utils.createTable(td, 0, 0,
            {
                display: "none", zIndex: 99999999, borderRadius: Math.round((this.options.skin == "si" ? 3 : 4) * this.options.btnsize / 40) + "px",
                position: "absolute", backgroundColor: this.options.skin == "si" ? this.toolbarbkcolor : JSDraw2.Skin.jsdraw.bkcolor, border: this.BORDERSTYLE, padding: "2px"
            });
        //if (this.options.skin == "w8" && !scilligence.Utils.isIE)
        //    tbody.parentNode.style.border = null;
        var table = tbody.parentNode;
        table.id = tbid + "_sub";
        table.onmouseover = JSDraw2.Menu.cancelclosetime;
        table.onmouseout = JSDraw2.Menu.closetime;

        var bs = b.sub;
        var leftmargin = 0;
        var singlerow = this.options.skin != "w8" || bs.length <= 5;
        if (!singlerow) {
            leftmargin = -(this.options.btnsize / 2 + 4);
            table.style.marginLeft = leftmargin + 'px';
        }
        if (scilligence.Utils.isIE && scilligence.Utils.isIE < 8 && !this.isSkinW8())
            table.style.margin = (this.options.btnsize + 4) + 'px 0 0 ' + (leftmargin - this.options.btnsize - 2) + 'px';

        var tr = null;
        for (var j = 0; j < bs.length; ++j) {
            var bn = bs[j];
            if (singlerow || j % 2 == 0)
                tr = scilligence.Utils.createElement(tbody, 'tr');
            td = scilligence.Utils.createElement(tr, "td");
            if (bn == "|") {
                scil.Utils.createElement(td, "hr", null, { margin: "5px 0 0 0", padding: 0 });
                continue;
            }
            if (j > 0 && this.isSkinW8())
                td.style.paddingTop = w + "px";
            var src = null;
            if (this.isSkinW8())
                src = "w8/" + bn.c + ".png";
            else
                src = "img/" + bn.c + ".gif";
            this.createBtnImg(td, (bn.img != null ? bn.img : scil.Utils.imgSrc(src)), null, bn.cmd != null ? bn.cmd : bn.c, this.res(bn.t), tbid, null, this.res(bn.label), true);
        }

        return td;
    },

    createBtnImg: function (td, src, tbid, cmd, title, parent, width, label, sub) {
        if (width == null)
            width = this.options.btnsize;
        var w = Math.round(2 * width / 20);
        if (this.options.skin == "si") {
            if (sub)
                td = scil.Utils.createElement(td, "div", null, { height: "32px" });
            var table = scil.Utils.createTable(td, 0, 0, sub ? null : { margin: "0 2px 0 2px", backgroundColor: this.toolbarbkcolor });
            var tr = scil.Utils.createElement(table, "tr");
            var td1 = scil.Utils.createElement(tr, "td", null, sub ? null : { border: "solid 1px " + JSDraw2.Skin.jsdraw.bkcolor });
            var td2 = null;
            var img = scilligence.Utils.createElement(td1, "img", null, { marginTop: "-5px" }, { src: src, alt: title });
            var styles = { marginTop: "-11px", width: width + "px", fontSize: "9px", textAlign: "center", color: "gray", whiteSpace: "nowrap", overflow: "hidden" };
            if (sub) {
                var td2 = scil.Utils.createElement(tr, "td");
                if (scil.Utils.isIE && scil.Utils.isIE < 8)
                    styles.fontSize = styles.marginTop = styles.width = null;
                styles.textAlign = "left";
                scil.Utils.createElement(td2, "div", label == null || label == "" ? "&nbsp;" : label, styles);
            }
            else {
                scil.Utils.createElement(td1, "div", label == null || label == "" ? "&nbsp;" : label, styles);
            }

            this.setHoverable(sub ? td : td1);
            if (title != null)
                (sub ? td : td1).setAttribute('title', title);
            if (cmd != null)
                (sub ? td : td1).setAttribute('cmd', cmd);
            if (parent != null)
                (sub ? td : td1).setAttribute('parent', parent);
            if (tbid != null)
                (sub ? td : td1).id = tbid;
            return img;
        }

        var style = { textAlign: "center", padding: this.isSkinW8() ? "2px 2px 0 2px" : "2px", verticalAlign: "middle", width: width + "px", height: this.options.btnsize + "px" };
        var img;
        if (this.isSkinW8()) {
            var button = this.options.buttonshape + ".png";
            style.background = "url(" + scil.Utils.imgSrc("w8/" + button) + ") center center no-repeat";
            img = scilligence.Utils.createElement(td, "img", null, style, { src: src, alt: title });
            scil.Utils.createElement(td, "div", label == null || label == "" ? "&nbsp;" : label, { width: width + "px", fontSize: "9px", textAlign: "center", color: "gray", whiteSpace: "nowrap", overflow: "hidden" });
        }
        else {
            img = scilligence.Utils.createElement(td, "img", null, style, { src: src, alt: title });
        }

        if (cmd != null)
            img.setAttribute('cmd', cmd);
        if (title != null)
            img.setAttribute('title', title);
        if (parent != null)
            img.setAttribute('parent', parent);
        if (tbid != null)
            img.id = tbid;
        if (this.isSkinW8()) {
            var me = this;
            this.editor.connectHandlers.push(dojo.connect(img, "onmouseover", function () { this.style.backgroundImage = scil.Utils.imgSrc("w8/" + me.options.buttonshape + "1.png", true); }));
            this.editor.connectHandlers.push(dojo.connect(img, "onmouseout", function () {
                this.style.backgroundImage = scil.Utils.imgSrc("w8/" + me.options.buttonshape + (this.getAttribute("pushed") == null ? "" : "0") + ".png", true);
            }));
        }
        else {
            this.setHoverable(img);
        }
        return img;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.Lasso = scilligence.extend(scilligence._base, {
    constructor: function (extra, linewidth, selecting) {
        this.surface = extra;
        this.linewidth = linewidth;
        this.list = selecting ? [] : null;

        this.lasthits = [];
        this.curhits = [];
        this.line = null;
    },

    hit: function (a) {
        if (scil.Utils.indexOf(this.lasthits, a) >= 0)
            return;

        a.selected = !a.selected;
        if (a.selected)
            a.drawSelect(this);
        else
            this.remove(a);
        this.curhits.push(a);
    },

    endHits: function(start, end) {
        this.lasthits = this.curhits;
        this.curhits = [];

        if (this.line != null)
            this.surface.remove(this.line);
        this.line = JSDraw2.Drawer.drawLine(this.surface, start, end, "#aaf", this.linewidth / 2);
    },

    draw: function (a, points) {
        if (points.x != null)
            points = [points];

        var nodes = [];
        for (var i = 0; i < points.length; ++i) {
            var p = points[i];
            var c = this.surface.createCircle({ cx: p.x, cy: p.y, r: this.linewidth * 2 }).setFill(JSDraw2.Editor.COLORSELECTED);
            nodes.push(c);
        }

        if (this.list != null)
            this.list.push({ a: a, nodes: nodes })
    },

    remove: function (a) {
        var nodes = null;
        for (var i = 0; i < this.list.length; ++i) {
            if (this.list[i].a == a) {
                nodes = this.list[i].nodes;
                this.list.splice(i, 1);
                break;
            }
        }

        if (nodes == null)
            return;

        for (var i = 0; i < nodes.length; ++i)
            this.surface.remove(nodes[i]);
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.Drawer = {
    kMinFontSize: 4,

    drawFormula: function (surface, p, reversed, s, color, fontsize) {
        //I#11940
        if (reversed) {
            var c = s.charAt(0);
            if (c >= '0' && c <= '9')
                reversed = false;
        }

        var rect = new JSDraw2.Rect();
        var ss = this.splitFormula(s);
        for (var i = 0; i < ss.length; ++i) {
            if (reversed) {
                if (ss[i].num != null) {
                    var r = this.drawWord(surface, rect, p, color, fontsize, ss[i].num, reversed, true);
                    if (rect.isEmpty())
                        rect = r;
                    else
                        rect.union(r);
                }
            }

            var r = this.drawWord(surface, rect, p, color, fontsize, ss[i].str, reversed, false);
            if (rect.isEmpty())
                rect = r;
            else
                rect.union(r);

            if (!reversed) {
                if (ss[i].num != null) {
                    r = this.drawWord(surface, rect, p, color, fontsize, ss[i].num, reversed, true);
                    if (rect.isEmpty())
                        rect = r;
                    else
                        rect.union(r);
                }
            }
        }

        return rect;
    },

    drawWord: function (surface, rect, p, color, fontsize, w, reversed, isnumber) {
        if (isnumber)
            fontsize /= 1.4;
        var n = this.drawLabel(surface, p, w, color, fontsize, false, reversed ? "end-anchor" : "start-anchor");
        var r = n._rect.clone();
        var nw = r.width / 2;

        var dx = 0;
        var dy = isnumber ? fontsize / 4 : 0;
        if (rect.isEmpty()) {
            // dx = -nw;
        }
        else if (reversed) {
            dx = -(p.x - rect.left) - nw;
            if (w == "I" || w == "i" || w == "l" || w == "r" || w == "f" || w == ".") {
                dx -= fontsize / 6.0;
                // r.width -= 4;
            }

            if (scil.Utils.isChrome)
                dx -= fontsize / 10.0;
        }
        else {
            dx = (rect.right() - p.x) + nw;
            if (w == "I" || w == "i" || w == "l" || w == "r" || w == "f" || w == ".") {
                dx += fontsize / 6.0;
                // r.width -= 4;
            }

            if (scil.Utils.isChrome)
                dx += fontsize / 10.0;
        }

        n.setTransform([dojox.gfx.matrix.translate(dx, dy)]);
        r.left += dx;
        r.top += dy;
        return r;
    },

    splitFormula: function (s) {
        if ((/^[A-Z]+$/.test(s) || /^[\(][^\(\)]+[\)]$/.test(s) || /^[\[][^\[\]]+[\]]$/.test(s)) && s != "COOH")
            return [{ str: s}];

        var ret = [];

        var bracket = 0;
        var number = false;
        var w = "";
        for (var i = 0; i < s.length; ++i) {
            var c = s.charAt(i);
            if (bracket > 0 || c == '(') {
                if (c == '(') {
                    if (bracket == 0) {
                        if (w != "") {
                            if (number && ret.length > 0)
                                ret[ret.length - 1].num = w;
                            else
                                ret.push({ str: w });
                        }
                        number = false;
                        w = "";
                    }

                    ++bracket;
                }
                else if (c == ')') {
                    --bracket;
                }

                w += c;
                if (bracket == 0) {
                    ret.push({ str: w });
                    w = "";
                }
            }
            else {
                if (c >= 'A' && c <= 'Z') {
                    if (w != "") {
                        if (number && ret.length > 0)
                            ret[ret.length - 1].num = w;
                        else
                            ret.push({ str: w });
                    }
                    number = false;
                    w = "";
                }
                else if (c >= '0' && c <= '9' && !number) {
                    if (w != "")
                        ret.push({ str: w });
                    number = true;
                    w = "";
                }
                w += c;
            }
        }

        if (w != "") {
            if (number && ret.length > 0)
                ret[ret.length - 1].num = w;
            else
                ret.push({ str: w });
        }
        return ret;
    },

    drawCurveArrow: function (surface, p1, p2, p1a, p2a, color, linewidth) {
        if (p1a == null || p2a == null) {
            var anchors = JSDraw2.Curve.calcAnchors(p1, p2);
            p1a = anchors.p1a;
            p2a = anchors.p2a;
        }

        surface.createPath("").moveTo(p1.x, p1.y)
            .curveTo(p1a.x, p1a.y, p2a.x, p2a.y, p2.x, p2.y)
            .setStroke({ color: color, width: linewidth, cap: "round" });
        JSDraw2.Drawer.drawArrowhead(surface, p2a, p2, color, linewidth);
    },

    drawCurve: function (surface, p1, p2, deg, r, color, linewidth) {
        var anchors = JSDraw2.Curve.calcAnchors(p1, p2, deg, r);
        var p1a = anchors.p1a;
        var p2a = anchors.p2a;

        surface.createPath("").moveTo(p1.x, p1.y)
            .curveTo(p1a.x, p1a.y, p2a.x, p2a.y, p2.x, p2.y)
            .setStroke({ color: color, width: linewidth, cap: "round" });
    },

    drawArrow: function (surface, p1, p2, color, linewidth, dottedline, arrowstyle) {
        if (arrowstyle == "dual") {
            var d = new JSDraw2.Point(p2.x - p1.x, p2.y - p1.y);
            var v = d.clone().rotate(90).setLength(linewidth);
            var tp1 = p1.clone().offset(d.x + v.x, d.y + v.y);
            var tp2 = p2.clone().offset(-d.x + v.x, -d.y + v.y);
            JSDraw2.Drawer.drawLine(surface, tp1, tp2, color, linewidth, dottedline);
            JSDraw2.Drawer.drawArrowhead2(surface, tp1, tp2, color, linewidth, "top");

            v = d.clone().rotate(-90).setLength(linewidth);
            tp1 = p1.clone().offset(d.x + v.x, d.y + v.y);
            tp2 = p2.clone().offset(-d.x + v.x, -d.y + v.y);
            JSDraw2.Drawer.drawLine(surface, tp1, tp2, color, linewidth, dottedline);
            JSDraw2.Drawer.drawArrowhead2(surface, tp2, tp1, color, linewidth, "top");
        }
        else if (arrowstyle == "reversible") {
            var d = new JSDraw2.Point(p2.x - p1.x, p2.y - p1.y);
            var v = d.clone().rotate(90).setLength(linewidth);
            var tp1 = p1.clone().offset(d.x * 0.6 + v.x, d.y * 0.6 + v.y);
            var tp2 = p2.clone().offset(-d.x + v.x, -d.y + v.y);
            JSDraw2.Drawer.drawLine(surface, tp1, tp2, color, linewidth, dottedline);
            JSDraw2.Drawer.drawArrowhead2(surface, tp1, tp2, color, linewidth, "top");

            v = d.clone().rotate(-90).setLength(linewidth);
            tp1 = p1.clone().offset(d.x + v.x, d.y + v.y);
            tp2 = p2.clone().offset(-d.x + v.x, -d.y + v.y);
            JSDraw2.Drawer.drawLine(surface, tp1, tp2, color, linewidth, dottedline);
            JSDraw2.Drawer.drawArrowhead2(surface, tp2, tp1, color, linewidth, "top");
        }
        else {
            if (arrowstyle == "solid") {
                var v = new JSDraw2.Point(p2.x - p1.x, p2.y - p1.y).setLength(linewidth * 4);
                JSDraw2.Drawer.drawLine(surface, p1, p2.clone().offset(-v.x, -v.y), color, linewidth, dottedline);
            }
            else {
                JSDraw2.Drawer.drawLine(surface, p1, p2, color, linewidth, dottedline);
            }
            JSDraw2.Drawer.drawArrowhead(surface, p1, p2, color, linewidth, arrowstyle);
        }
    },

    drawArrowhead: function (surface, p1, p2, color, linewidth, arrowstyle) {
        if (arrowstyle == "solid") {
            this.drawArrowhead2(surface, p1, p2, color, linewidth, arrowstyle);
        }
        else if (arrowstyle == "double") {
            this.drawArrowhead2(surface, p1, p2, color, linewidth);
            this.drawArrowhead2(surface, p2, p1, color, linewidth);
        }
        else if (arrowstyle == "none") {
        }
        else {
            this.drawArrowhead2(surface, p1, p2, color, linewidth);
        }
    },

    drawArrowhead2: function (surface, p1, p2, color, linewidth, as) {
        var v = p1.clone().offset(-p2.x, -p2.y).setLength(linewidth * 7);
        var deg = v.angle();
        var v1 = v.clone().rotate(25);
        var v2 = v.clone().rotate(-25);
        var a1 = p2.clone().offset(v1.x, v1.y);
        var a2 = p2.clone().offset(v2.x, v2.y);

        if (as == "solid") {
            JSDraw2.Drawer.drawTriangle(surface, a1, p2, a2, color);
        }
        else if (as == "top") {
            JSDraw2.Drawer.drawLine(surface, a1, p2, color, linewidth);
        }
        else if (as == "bottom") {
            JSDraw2.Drawer.drawLine(surface, a2, p2, color, linewidth);
        }
        else {
            JSDraw2.Drawer.drawLine(surface, a1, p2, color, linewidth);
            JSDraw2.Drawer.drawLine(surface, a2, p2, color, linewidth);
        }
    },

    drawTriangle: function (surface, p1, p2, p3, color) {
        var t = surface.createPath("").moveTo(p1.x, p1.y).lineTo(p2.x, p2.y).lineTo(p3.x, p3.y).lineTo(p1.x, p1.y);
        t.setFill(color);
        return t;
    },

    drawBracket: function (surface, r, color, linewidth, shape) {
        var m = linewidth * 3;
        var w = linewidth;

        switch (shape) {
            case "round":
                this.drawCurve(surface, r.topleft(), r.bottomleft(), -30, 0.3, color, linewidth);
                this.drawCurve(surface, r.topright(), r.bottomright(), 30, 0.3, color, linewidth);
                break;
            case "curly":
                break;
            default:
                JSDraw2.Drawer.drawLine(surface, r.topleft(), r.topleft().offset(m, 0), color, w);
                JSDraw2.Drawer.drawLine(surface, r.topleft(), r.bottomleft(), color, w);
                JSDraw2.Drawer.drawLine(surface, r.bottomleft(), r.bottomleft().offset(m, 0), color, w);

                JSDraw2.Drawer.drawLine(surface, r.topright(), r.topright().offset(-m, 0), color, w);
                JSDraw2.Drawer.drawLine(surface, r.topright(), r.bottomright(), color, w);
                JSDraw2.Drawer.drawLine(surface, r.bottomright(), r.bottomright().offset(-m, 0), color, w);
                break;
        }
    },

    drawDoubleArrow: function (surface, r, color, linewidth) {
        var m = linewidth * 3;
        var w = linewidth;

        this.drawLine(surface, r.topleft(), r.topright(), color, w);
        this.drawArrow(surface, r.topleft(), r.bottomleft(), color, w);
        this.drawArrow(surface, r.topright(), r.bottomright(), color, w);
    },

    drawLabel: function (surface, p, s, fontcolor, fontsize, opaque, align, offsetx, stroke) {
        var w = fontsize + 2;
        if (opaque) {
            var r = new JSDraw2.Rect(p.x - w / 2, p.y - w / 2, w, w);
            surface.createRect({ x: r.left, y: r.top, width: r.width, height: r.height })
                .setFill(opaque == true ? "#fff" : opaque);
        }

        var x = p.x + (offsetx == null ? 0 : offsetx);
        var y = p.y + w / 2 - 2;
        if (align == "start-anchor") {
            align = "start";
            x -= fontsize * 0.4;
        }
        if (align == "end-anchor") {
            align = "end";
            x += fontsize * 0.4;
            // s = JSDraw2.SuperAtoms.reverseLabel(s);
        }
        var args = { x: x, y: y, text: s, align: align == null ? "middle" : align };
        var t = null;
        if (dojox.gfx.renderer == "canvas") {
            t = surface.createText(args);
            t.shape.fontStyle = "bold " + (fontsize < this.kMinFontSize ? this.kMinFontSize : fontsize) /*Mac,Linux bug*/ + "px Arial";
            t.shape.fillStyle = fontcolor;
            t.shape.align = "center";

            t.mwidth = this.getTextWidth(surface, t);
            t.getTextWidth = function () { return t.mwidth; };
        }
        else {
            t = surface.createText(args)
                .setFont({ family: "Arial", size: (fontsize < this.kMinFontSize ? this.kMinFontSize : fontsize) /*Mac,Linux bug*/ + "px", weight: "normal" })
                .setFill(fontcolor);
            if (stroke != false)
                t.setStroke(fontcolor);
        }

        // space char causes hang-up issue
        if (/^[ ]+$/.test(s))
            t._rect = new JSDraw2.Rect(x, y, s.length * fontsize / 2, fontsize + 4);
        else
            t._rect = new JSDraw2.Rect(x, y, t.getTextWidth(), fontsize + 4);

        t._rect.top -= t._rect.height * 0.8;
        if (align == "end")
            t._rect.left -= t._rect.width;
        return t;
    },

    drawText2: function (surface, p, s, fontcolor, fontsize, rotatedeg) {
        var w = fontsize + 2;
        var t = null;
        if (dojox.gfx.renderer == "canvas") {
            t = surface.createText({ x: p.x, y: p.y + w / 2 - 2, text: s });
            t.shape.fontStyle = "bold " + (fontsize < this.kMinFontSize ? this.kMinFontSize : fontsize) /*Mac,Linux bug*/ + "px Arial";
            t.shape.fillStyle = fontcolor;
            t.shape.align = "center";

            t.mwidth = this.getTextWidth(surface, t);
            t.getTextWidth = function () { return t.mwidth; };
        }
        else {
            t = surface.createText({ x: p.x, y: p.y + w / 2 - 2, text: s, align: "middle" })
                .setFont({ family: "Arial", size: (fontsize < this.kMinFontSize ? this.kMinFontSize : fontsize) /*Mac,Linux bug*/ + "px", weight: "normal" })
                .setFill(fontcolor);
        }
        if (rotatedeg != null)
            t.setTransform([dojox.gfx.matrix.rotateAt(rotatedeg, p.x, p.y)]);
        return t;
    },

    drawText: function (surface, p, s, fontcolor, fontsize, align, italic) {
        if (align == null)
            align = "left";

        var t = null;
        if (dojox.gfx.renderer == "canvas") {
            t = surface.createText({ x: p.x, y: p.y + fontsize + 2, text: s });
            t.shape.fontStyle = (fontsize < this.kMinFontSize ? this.kMinFontSize : fontsize) /*Mac,Linux bug*/ + "px Arial";
            t.shape.fillStyle = fontcolor;
            t.shape.align = align;

            t.mwidth = this.getTextWidth(surface, t);
            t.getTextWidth = function () { return t.mwidth; };
        }
        else {
            var font = { family: "Arial", size: (fontsize < this.kMinFontSize ? this.kMinFontSize : fontsize) /*Mac,Linux bug*/ + "px", weight: "normal" };
            if (italic)
                font.style = "italic";
            t = surface.createText({ x: p.x, y: p.y + fontsize + 2, text: s, align: align })
                .setFont(font)
                .setFill(fontcolor);
        }

        if (align == "right") {
            var w = t.getTextWidth();
            t.setTransform([dojox.gfx.matrix.translate(-w, 0)]);
        }
        return t;
    },

    getTextWidth: function (surface, s) {
        var ctx = surface.surface.rawNode.getContext('2d');
        ctx.save();
        ctx.fillStyle = s.fillStyle;
        ctx.strokeStyle = s.fillStyle;
        ctx.font = s.fontStyle;
        ctx.textAlign = "center";
        //ctx.textBaseline = "bottom";
        var width = ctx.measureText(s.text).width / 6;
        ctx.restore();
        return width;
    },

    drawBasis: function (surface, p1, p2, color, linewidth) {
        this.drawLine(surface, p1, p2, color, linewidth);

        var d = new JSDraw2.Point(p2.x - p1.x, p2.y - p1.y).scale(1.0 / 6.0);
        var p = p1.clone().offset(-d.x * 0.5, -d.y * 0.5);
        for (var i = 0; i < 5; ++i) {
            p.offset(d.x, d.y);
            var t = p.clone().offset(d.x * 1.25, d.y * 1.25);
            t.rotateAround(p, -45);

            this.drawLine(surface, p, t, color, linewidth);
        }
    },

    drawCurves: function (surface, p1, p2, color, linewidth) {
        var path = surface.createPath();
        path.moveTo(p1.x, p1.y);

        var len = p1.distTo(p2);
        var n = Math.floor(len / linewidth);
        var d = new JSDraw2.Point(p2.x - p1.x, p2.y - p1.y).scale(1.0 / n);
        var v = new JSDraw2.Point(p2.x - p1.x, p2.y - p1.y).rotate(90).setLength(linewidth * 2);
        for (var k = 1; k <= n; k += 2) {
            var p = p1.clone().offset(d.x * k, d.y * k);
            var t1 = p.clone().offset(d.x, d.y);
            if (((k - 1) / 2) % 2 == 1)
                p.offset(v.x, v.y);
            else
                p.offset(-v.x, -v.y);
            path.qCurveTo(p.x, p.y, t1.x, t1.y);
        }
        path.setStroke({ color: color, width: linewidth });
    },

    drawLine: function (surface, p1, p2, color, linewidth, dotline, cap) {
        if (linewidth == null)
            linewidth = 1;

        if (dotline == null || dotline <= 1) {
            return surface.createLine({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y })
                .setStroke({ color: color, width: linewidth, cap: cap == null ? "round" : cap });
        }
        else {
            var len = p1.distTo(p2);
            var n = Math.floor(len / dotline);
            if (n % 2 == 0)
                --n;

            var d = p2.clone().offset(-p1.x, -p1.y).scale(1.0 / n);
            var d2 = d.clone().scale(0.3);
            var st = new JSDraw2.Point(((p2.x - p1.x) - d.x * n) / 2, ((p2.y - p1.y) - d.y * n) / 2);

            for (var k = 0; k < n; k += 2) {
                var t1 = p1.clone().offset(st.x + d.x * k + d2.x, st.y + d.y * k + d2.y);
                var t2 = t1.clone().offset(d.x - d2.x, d.y - d2.y);
                surface.createLine({ x1: t1.x, y1: t1.y, x2: t2.x, y2: t2.y })
                    .setStroke({ color: color, width: linewidth, cap: cap == null ? "round" : cap });
            }
        }
    },

    drawRect: function (surface, r, color, linewidth, radius, style) {
        if (r == null || r.isEmpty())
            return;
        var opts = { x: r.left, y: r.top, width: r.width, height: r.height };
        if (radius != null)
            opts.r = radius;
        if (style != null)
            opts.style = style;
        return surface.createRect(opts).setStroke({ color: color, width: linewidth });
    },

    drawDShape: function (surface, r, color, linewidth, reverse) {
        var rad = r.height / 2;
        var x = r.right() - rad;
        var y = r.center().y;
        var path = surface.createPath()
           .moveTo({ x: x, y: r.top })
           .arcTo(rad, rad, 0, false, true, this._calcPoint(x, y, rad, 180 / 2))
           .arcTo(rad, rad, 0, false, true, this._calcPoint(x, y, rad, 180))
            .lineTo({ x: r.left, y: r.bottom() })
            .lineTo({ x: r.left, y: r.top })
            .lineTo({ x: x, y: r.top })
           .closePath()
           .setStroke({ color: color, width: linewidth });

        if (reverse)
            path.setTransform([dojox.gfx.matrix.rotateAt(Math.PI, r.center().x, y)]);
        return path;
    },

    _calcPoint: function (x, y, rad, deg) {
        deg = (Math.PI / 180) * (360 - deg);
        return {
            x: Math.round((rad * -Math.sin(deg)) + x), y: Math.round(y - (rad * Math.cos(deg)))
        };
    },

    drawEllipse: function (surface, r, color, linewidth) {
        var c = r.center();
        return surface.createEllipse({ cx: c.x, cy: c.y, rx: r.width / 2, ry: r.height / 2 }).setStroke({ color: color, width: linewidth });
    },

    drawPie: function (surface, x, y, r, deg1, deg2) {
        var calcPoint = function (deg, rad) {
            deg = (Math.PI / 180) * (360 - deg);
            return { x: Math.round((r * -Math.sin(deg)) + x), y: Math.round(y - (r * Math.cos(deg)))
            };
        };
        return surface.createPath()
           .moveTo({ x: x, y: y })
           .lineTo(calcPoint(deg1))
           .arcTo(r, r, 0, false, true, calcPoint(deg2 / 2))
           .arcTo(r, r, 0, false, true, calcPoint(deg2))
           .lineTo({ x: x, y: y })
           .closePath()
           .setFill("#535353");
    },

    drawDiamond: function (surface, r, color, linewidth) {
        var c = r.center();
        var points = [
            { x: c.x, y: r.top },
            { x: r.right(), y: c.y },
            { x: c.x, y: r.bottom() },
            { x: r.left, y: c.y },
            { x: c.x, y: r.top }
        ];
        return surface.createPolyline(points).setStroke({ color: color, width: linewidth });
    },

    drawHexgon: function (surface, r, color, linewidth) {
        var c = r.center();
        var d = new JSDraw2.Point(0, r.width / 2);
        d.rotate(-30);
        var points = [
            { x: r.right(), y: c.y },
            { x: c.x + d.x, y: c.y - d.y },
            { x: c.x - d.x, y: c.y - d.y },
            { x: r.left, y: c.y },
            { x: c.x - d.x, y: c.y + d.y },
            { x: c.x + d.x, y: c.y + d.y },
            { x: r.right(), y: c.y }
        ];
        return surface.createPolyline(points).setStroke({ color: color, width: linewidth });
    },

    drawPentagon: function (surface, r, color, linewidth) {
        var c = r.center();
        var p1 = c.clone().offset(0, -r.width / 2);
        var p2 = p1.clone().rotateAround(c, 72);
        var p3 = p2.clone().rotateAround(c, 72);
        var p4 = p3.clone().rotateAround(c, 72);
        var p5 = p4.clone().rotateAround(c, 72);
        
        var points = [
            { x: p1.x, y: p1.y },
            { x: p2.x, y: p2.y },
            { x: p3.x, y: p3.y },
            { x: p4.x, y: p4.y },
            { x: p5.x, y: p5.y },
            { x: p1.x, y: p1.y },
        ];
        return surface.createPolyline(points).setStroke({ color: color, width: linewidth });
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.Language = {
    current: null,
    use: function (lang) {
    },

    res: function (s) {
        return s;
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.IDGenerator = scil.extend(scil._base, {
    constructor: function (start) {
        this.i = start > 0 ? start : 0;
        this.used = this.i == 0 ? null : {};
    },

    next: function (id) {
        if (this.used == null)
            return ++this.i;

        if (id > 0 && !this.used[id]) {
            this.used[id] = true;
            return id;
        }

        id = ++this.i;
        while (this.used[id])
            id = ++this.i;
        this.used[id] = true;
        return id;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.Skin = {
    jsdraw: {},
    jssdf: {},
    dialog: {},
    menu: {},

    reset: function () {
        this.jsdraw = { bkcolor: "#e1e1e1", bkimg: scil.Utils.imgSrc("img/hbg.gif"), toolbarbk: scil.Utils.imgSrc("img/toolbarbk.jpg"), hovercolor: "#eef", btnselcolor: "#bbf" };
        this.jssdf = { bgcolor: "#eee", headerimg: scil.Utils.imgSrc("img/header-bg.gif"), headercolor: "#eee", rowcolor: "#f96", oddcolor: "", evencolor: "#eee", border: "solid 1px #ccc" };
        scilligence.apply(this.jssdf, this.jsdraw);
        this.menu = { boxshadow: "5px 5px 15px 5px rgba(0,0,0,0.2)" };
        this.dialog = { bkimg: scil.Utils.imgSrc("img/dlgheader.gif"), bkcolor: "#6badf6", border: "1px solid #4f6d81", boxshadow: "5px 5px 20px 8px rgba(0,0,0,0.5)" };
    },

    red: function () {
        this.jsdraw = { bkcolor: "#ECCDDC", bkimg: scil.Utils.imgSrc("img/hbg-red.gif"), toolbarbk: scil.Utils.imgSrc("img/toolbarbk-red.jpg"), hovercolor: "#fCdDeC" };
        this.jssdf = { bgcolor: "#F8CEE8", headerimg: scil.Utils.imgSrc("img/header-bgred.gif"), headercolor: "#F8CEE8", rowcolor: "#FfeEf8", oddcolor: "", evencolor: "#eee", border: "solid 1px #ccc" };
        scilligence.apply(this.jssdf, this.jsdraw);
        this.dialog = { bkimg: scil.Utils.imgSrc("img/dlgheader-red.gif"), bkcolor: "#E7A6DF", border: "1px solid #4f6d81" };
    },

    green: function () {
        this.jsdraw = { bkcolor: "#C7EEDF", bkimg: scil.Utils.imgSrc("img/hbg-green.gif"), toolbarbk: scil.Utils.imgSrc("img/toolbarbk-green.jpg"), hovercolor: "#d7fEeF" };
        this.jssdf = { bgcolor: "#CCF8E8", headerimg: scil.Utils.imgSrc("img/header-bggreen.gif"), headercolor: "#CCF8E8", rowcolor: "#dCFff8", oddcolor: "", evencolor: "#eee", border: "solid 1px #ccc" };
        scilligence.apply(this.jssdf, this.jsdraw);
        this.dialog = { bkimg: scil.Utils.imgSrc("img/dlgheader-green.gif"), bkcolor: "#95D09C", border: "1px solid #4f6d81" };
    },

    blue: function () {
        this.jsdraw = { bkcolor: "#CDD0EC", bkimg: scil.Utils.imgSrc("img/hbg-blue.gif"), toolbarbk: scil.Utils.imgSrc("img/toolbarbk-blue.jpg"), hovercolor: "#dDe0fC" };
        this.jssdf = { bgcolor: "#DCDFF6", headerimg: scil.Utils.imgSrc("img/header-bgblue.gif"), headercolor: "#DCDFF6", rowcolor: "#eCeFFf", oddcolor: "", evencolor: "#eee", border: "solid 1px #ccc" };
        scilligence.apply(this.jssdf, this.jsdraw);
        this.dialog = { bkimg: scil.Utils.imgSrc("img/dlgheader-blue.gif"), bkcolor: "#8BB6CC", border: "1px solid #4f6d81" };
    },

    yellow: function () {
        this.jsdraw = { bkcolor: "#ECECCD", bkimg: scil.Utils.imgSrc("img/hbg-yellow.gif"), toolbarbk: scil.Utils.imgSrc("img/toolbarbk-yellow.jpg"), hovercolor: "#fCfCdD" };
        this.jssdf = { bgcolor: "#F4F4E1", headerimg: scil.Utils.imgSrc("img/header-bgyellow.gif"), headercolor: "#F4F4E1", rowcolor: "#F4F4B8", oddcolor: "", evencolor: "#eee", border: "solid 1px #ccc" };
        scilligence.apply(this.jssdf, this.jsdraw);
        this.dialog = { bkimg: scil.Utils.imgSrc("img/dlgheader-yellow.gif"), bkcolor: "#C8BA8F", border: "1px solid #4f6d81" };
    },

    menu: { highlightcolor: "#c60", color: "blue" },
    form: {
        labelstyles: { backgroundColor: "#eef", border: "solid 1px #dde", textAlign: "left", verticalAlign: "top", whiteSpace: "nowrap" },
        fieldcolor: "blue",
        rowselectcolor: "#aaf"
    }
};

JSDraw2.Skin.reset();
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Editor class - define an Editor object.
*<pre>
* <b>Example:</b>
*   &lt;html&gt;
*   &lt;head&gt;
*   &lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/dojo/1.11.2/dojo/dojo.js"&gt;&lt;/script&gt;
*   &lt;script type="text/javascript" src='http://[PATH]/Scilligence.JSDraw2.js'&gt;&lt;/script&gt;
*   &lt;/head&gt;
*   &lt;body&gt;
*   &lt;div id='ed'&gt;&lt;/div&gt;
*   &lt;script type='text/javascript'&gt;
*     dojo.ready(function() {
*       // create a JSDraw Editor
*       var editor = new JSDraw2.Editor("ed", { skin: "w8", width: 800, height: 400 });
*
*       // create a JSDraw viewer
*       //var editor = new JSDraw2.Editor("ed", { skin: "w8", width: 800, height: 400, viewonly: true });
*
*       // create a JSDraw popup Editor
*       //var editor = new JSDraw2.Editor("ed", { skin: "w8", width: 800, height: 400, popup: true });
*     });
*   &lt;/script&gt;
*   &lt;/body&gt;
*   &lt;/html&gt;
* </pre>
* @class scilligence.JSDraw2.Editor
*/
JSDraw2.Editor = scilligence.extend(scilligence._base, {
    /**
    @property {Mol} atoms Mol object
    */
    /**
    @property {bool} chiral Molecule Chiral Flag
    */

    /**
    * Called when the structure is changed
    * @event {bool} ondatachange 
    * @param {Editor} editor this Editor
    * @return null
    */

    /**
    * Constructor a JSDraw Editor
    * @constructor Editor
    * @param {string} dv - the id of the div placeholder
    * @param {dictionary} options - the options for the editor:<ul>
    * <li>background - background color </li>
    * <li>biology - Set this flag to false to hide seqence button</li>
    * <li>buttonshape - circle, or square</li>
    * <li>data - actual data</li>
    * <li>dataformat - data format. It can be molfile, rxnfile, html</li>
    * <li>height</li>
    * <li>focusbox - indicate if show focusing box if focused. default: true </li>
    * <li>focuscolor - the border color when focused </li>
    * <li>inktools - set this flag to false to hide ink tools</li>
    * <li>highlighterrors - set this flag to false not to highlight errors in reb box</li>
    * <li>ondatachange - datachange event handler</li>
    * <li>plugins - plugins, as an array [{iconurl, tooltips, onclick}, ...]</li>
    * <li>popup - Create a viewer, and double-click to show popup editor</li>
    * <li>popupheight - Popup Editor height</li>
    * <li>popupwidth - Popup Editor width</li>
    * <li>query - Set this flag to false to disable query atoms (A, R, X, Q, *, etc.) in periodic table</li>
    * <li>removeHydrogens - Remove hydrogen atoms before show the structure</li>
    * <li>rxn - Set this flag to false to disable reaction buttons on toolbar</li>
    * <li>scale - A factore to zoom the whole editor, including toolbars. This is useful for iPad applications</li>
    * <li>sendquery - Set this flag to false to hide PubChem, ChemSpider search button</li>
    * <li>skin - set this to "w8" to display the editor in JSDraw2 mode; leave this parameter to empty to display editor in classic mode (2.0)</li>
    * <li>showcarbon - all or terminal</li>
    * <li>showfilemenu - set this flag to false to hide file menus</li>
    * <li>showimplicithydrogens - Set flag to false to hide implicit hydrogens</li>
    * <li>showtoolbar - set this flag to false not to show toolbar</li>
    * <li>viewonly</li>
    * <li>width</li>
    * </ul>
    */
    constructor: function (dv, options) {
        this.disableundo = JSDraw2.speedup.disableundo;

        this.T = "DRAW";
        JSDraw2.Editor.COLORCURRENT = [0, 255, 0, 0.5];
        JSDraw2.Editor.COLORSELECTED = [0, 0, 255, 0.5];
        this.options = options == null ? {} : options;
        this.chiral = null;

        if (JSDraw2.Editor._id == null) {
            JSDraw2.Editor._id = 0;
            JSDraw2.Editor._allitems = {};
        }

        ++JSDraw2.Editor._id;
        if ((typeof dv) == "string")
            dv = dojo.byId(dv);
        if (dv == null)
            return;

        this.ptElement = null;
        this.connectHandlers = [];
        this.maintable = null;
        this.div = dv;
        if (this.div.id == null || this.div.id.length == 0)
            this.div.id = "__JSDraw_" + JSDraw2.Editor._id;
        this.id = this.div.id;

        JSDraw2.Editor._allitems[this.id] = this;
        if (JSDraw2.defaultoptions == null)
            JSDraw2.defaultoptions = {};

        if (this.options.popup == null)
            this.options.popup = scil.Utils.isAttTrue(this.div, "popup");
        if (this.options.viewonly == null)
            this.options.viewonly = scil.Utils.isAttTrue(this.div, "viewonly");
        if (this.options.removehydrogens == null)
            this.options.removehydrogens = JSDraw2.defaultoptions.removehydrogens != null ? JSDraw2.defaultoptions.removehydrogens : scil.Utils.isAttTrue(this.div, "removehydrogens");
        if (this.options.query == null)
            this.options.query = JSDraw2.defaultoptions.query != null ? JSDraw2.defaultoptions.query : !scil.Utils.isAttFalse(this.div, "query");
        if (this.options.rxn == null)
            this.options.rxn = JSDraw2.defaultoptions.rxn != null ? JSDraw2.defaultoptions.rxn : !scil.Utils.isAttFalse(this.div, "rxn");
        if (this.options.biology == null)
            this.options.biology = JSDraw2.defaultoptions.biology != null ? JSDraw2.defaultoptions.biology : !scil.Utils.isAttFalse(this.div, "biology");
        if (this.options.sendquery == null)
            this.options.sendquery = JSDraw2.defaultoptions.sendquery != null ? JSDraw2.defaultoptions.sendquery : !scil.Utils.isAttFalse(this.div, "sendquery");
        if (this.options.showtoolbar == null)
            this.options.showtoolbar = JSDraw2.defaultoptions.showtoolbar != null ? JSDraw2.defaultoptions.showtoolbar : !scil.Utils.isAttFalse(this.div, "showtoolbar");
        if (this.options.showcustomtemplates == null)
            this.options.showcustomtemplates = JSDraw2.defaultoptions.showcustomtemplates != null ? JSDraw2.defaultoptions.showcustomtemplates : !scil.Utils.isAttFalse(this.div, "showcustomtemplates");
        if (this.options.usechemdraw == null)
            this.options.usechemdraw = JSDraw2.defaultoptions.usechemdraw != null ? JSDraw2.defaultoptions.usechemdraw : scil.Utils.isAttTrue(this.div, "usechemdraw");
        if (this.options.showcarbon == null)
            this.options.showcarbon = JSDraw2.defaultoptions.showcarbon;
        if (this.options.pastechemdraw == null)
            this.options.pastechemdraw = JSDraw2.defaultoptions.pastechemdraw;
        if (this.options.width > 0)
            this.div.style.width = this.options.width + "px";
        if (this.options.height > 0)
            this.div.style.height = this.options.height + "px";
        if (this.options.ondatachange == null)
            this.options.ondatachange = dojo.attr(this.div, "ondatachange");
        if (this.options.data == null)
            this.options.data = dojo.attr(this.div, "data");
        if (this.options.dataformat == null)
            this.options.dataformat = dojo.attr(this.div, "dataformat");
        if (this.options.showimplicithydrogens == null)
            this.options.showimplicithydrogens = JSDraw2.defaultoptions.showimplicithydrogens != null ? JSDraw2.defaultoptions.showimplicithydrogens : !scil.Utils.isAttFalse(this.div, "showimplicithydrogens");
        if (this.options.inktools == null)
            this.options.inktools = JSDraw2.defaultoptions.inktools != null ? JSDraw2.defaultoptions.inktools : !scil.Utils.isAttFalse(this.div, "inktools");
        if (this.options.highlighterrors == null)
            this.options.highlighterrors = JSDraw2.defaultoptions.highlighterrors != null ? JSDraw2.defaultoptions.highlighterrors : !scil.Utils.isAttFalse(this.div, "highlighterrors");
        if (this.options.skin == null) {
            this.options.skin = JSDraw2.defaultoptions.skin != null ? JSDraw2.defaultoptions.skin : dojo.attr(this.div, "skin");
            if (this.options.skin == null)
                this.options.skin = "w8"
        }
        if (this.options.monocolor == null)
            this.options.monocolor = scil.Utils.isAttTrue(this.div, "monocolor");
        if (this.options.fullscreen == null)
            this.options.fullscreen = JSDraw2.defaultoptions.fullscreen != null ? JSDraw2.defaultoptions.fullscreen : scil.Utils.isAttTrue(this.div, "fullscreen");

        if (this.options.buttonshape == null)
            this.options.buttonshape = JSDraw2.defaultoptions.buttonshape != null ? JSDraw2.defaultoptions.buttonshape : dojo.attr(this.div, "buttonshape");
        if (this.options.buttonshape == null || this.options.buttonshape == "")
            this.options.buttonshape = scil.Utils.isIE ? "circle" : "square";
        if (this.options.buttonshape == "square")
            this.options.buttonshape = "btnrec";
        else if (this.options.buttonshape == "circle")
            this.options.buttonshape = "btncir";

        if (this.options.tlcplate)
            this.options.toolbarmode = "tlc";
        else if (this.options.helmtoolbar)
            this.options.toolbarmode = "helm";
        else if (this.options.workflow)
            this.options.toolbarmode = "workflow";

        if (!(this.options.scale > 0)) {
            if (JSDraw2.defaultoptions.scale != null) {
                this.options.scale = JSDraw2.defaultoptions.scale;
            }
            else {
                var s = dojo.attr(this.div, "scale");
                if (!isNaN(s))
                    this.options.scale = parseFloat(s);
                //if (!(this.options.scale > 0))
                //    this.options.scale = this.isSkinW8() ? 1.3 : 1.0;
            }
        }
        this.options.btnsize = this.isSkinW8() ? 42 : (20 * this.options.scale);

        if (this.options.data == null) {
            var molfile = dojo.attr(this.div, "molfile");
            if (molfile != null) {
                this.options.data = molfile;
                this.options.dataformat = "molfile";
            }
        }
        if (this.options.data == null) {
            var rxnfile = dojo.attr(this.div, "rxnfile");
            if (rxnfile != null) {
                this.options.data = rxnfile;
                this.options.dataformat = "rxnfile";
            }
        }

        if (this.options.skin == "w8")
            JSDraw2.Skin.jsdraw = { bkcolor: "#fff" };

        this.movingresolution = this.options.movingresolution > 0 ? this.options.movingresolution : 6;

        this.bondlength = JSDraw2.Editor.BONDLENGTH;
        this.tor = JSDraw2.Editor.TOR;
        this.linewidth = JSDraw2.Editor.LINEWIDTH;
        this.fontsize = JSDraw2.Editor.FONTSIZE;
        this.angleStop = JSDraw2.Editor.ANGLESTOP;
        var rect = scil.Utils.styleRect(this.div);
        this.dimension = new JSDraw2.Point(rect.width, rect.height);
        if (!(this.dimension.x > 0))
            this.dimension.x = this.div.offsetWidth == 0 ? 650 : this.div.offsetWidth;
        if (!(this.dimension.y > 0))
            this.dimension.y = this.div.offsetHeight == 0 ? 320 : this.div.offsetHeight;

        this.div.style.textAlign = "left";
        this.div.style.cursor = "default";
        this.div.style.width = this.dimension.x + "px";
        this.div.style.height = this.dimension.y + "px";

        if (scil.helm != null && this.options.helm != false)
            this.helm = new scil.helm.Plugin(this);

        this.m = new JSDraw2.Mol(this.options.showimplicithydrogens);
        this.status = null;
        this.modified = false;
        this.toolbar = null;

        this.touching = null;
        this.start = null;
        this.lastmove = null;
        this.end = null;
        this.curObject = null;
        this.curButton = null;
        this.movingClone = null;
        this.resizing = null;
        this.texteditor = { input: null, text: null, atom: null };
        this.rotating = null,
        this.mousedownPoint = null;
        this._lastMousedownTm = null;
        this.lassolast = null;
        this.chaintool = null;
        this.activated = false;
        this.ink = null;
        JSDraw2.Security._check();

        this.undocapacity = 10;
        this._undostack = new JSDraw2.Stack(this.undocapacity);
        this._redostack = new JSDraw2.Stack(this.undocapacity);

        if (!this.setMol(this.options.data)) {
            switch ((this.options.dataformat + "").toLowerCase()) {
                case "mol":
                case "molfile":
                    this.setMolfile(this.options.data);
                    break;
                case "molbase64":
                    this.setMolbase64(this.options.data);
                    break;
                case "rxn":
                case "rxnfile":
                    this.setRxnfile(this.options.data);
                    break;
                case "rxnbase64":
                    this.setRxnbase64(this.options.data);
                    break;
                case "jdx":
                    this.setJdx(this.options.data);
                    break;
                case "html":
                case "xml":
                case "jsdraw":
                    this.setXml(this.options.data == null ? this.div : this.options.data);
                    break;
                case "helm":
                    this.setHelm(this.options.data == null ? this.div : this.options.data);
                    break;
                case "molurl":
                    this.download(this.options.data, "mol");
                    break;
                case "rxnurl":
                    this.download(this.options.data, "rxn");
                    break;
                case "xmlurl":
                    this.download(this.options.data, "xml");
                    break;
                case "jdxurl":
                    this.download(this.options.data, "jdx");
                    break;
                default:
                    this.setXml(this.div);
            }
        }

        var hastoolbar = !this.options.popup && !this.options.viewonly;
        this.div.innerHTML = "";
        if (this.options.background != null)
            this.div.style.background = this.options.background;
        else
            this.div.style.background = "#fff";
        if (hastoolbar && this.options.showtoolbar) {
            if (this.isSkinW8()) {
                this.dimension.y -= 70;
            }
            else {
                this.dimension.x -= 28;
                this.dimension.y -= 24;
            }
        }
        dojo.style(this.div, { width: this.dimension.x + "px", height: this.dimension.y + "px" });

        var me = this;
        if (!this.options.viewonly || this.options.popup == true) {
            if (scil.Utils.serviceAvailable() && scil.DnDFile != null) {
                new scil.DnDFile(this.div, {
                    url: JSDrawServices.url + "?cmd=openjsd",
                    onupload: function (args) {
                        if (!scil.Utils.isChemFile(scil.Utils.getFileExt(args.filename))) return false;
                    },
                    callback: function (ret) {
                        me.activate(true); JSDraw2.JSDrawIO.jsdFileOpen2(me, ret);
                    }
                });
            }
        }

        if (hastoolbar) {
            this.toolbar = new JSDraw2.Toolbar(this);
            this.toolbar.createToolbars(this.div);
            if (!this.options.showtoolbar)
                this.toolbar.show(false);

            if (window.navigator.msPointerEnabled) {
                dojo.connect(this.div, "onselectstart", function (e) { e.preventDefault(); });

                // only caption multi-touch. one-point touch is handler by mouse-down/move/up
                dojo.connect(this.div, "onMSPointerDown", function (e) { e = scilligence.mstouch.down(e); if (e != null && e.touches.length > 1) me.touchStart(e); else me.resetGesture(); });
                dojo.connect(this.div, "onMSPointerMove", function (e) { e = scilligence.mstouch.move(e); if (e != null && e.touches.length > 1) me.touchMove(e); });
                dojo.connect(this.div, "onMSPointerUp", function (e) { e = scilligence.mstouch.up(e); if (e != null && e.touches.length > 1) me.touchEnd(e); });

                dojo.connect(this.div, "onMSGestureHold", function (e) { me.showContextMenu(e); e.preventDefault(); });
                //this.div.addEventListener("MSGestureStart", function (e) { me.gestureStart(e); }, false);
                //this.div.addEventListener("MSGestureChange", function (e) { me.gestureChange(e); }, false);
                //this.div.addEventListener("MSGestureEnd", function (e) { me.gestureEnd(e); }, false);
            }

            if (scil.Utils.isTouch) {
                this.activate(false, false);
                this.connectHandlers.push(dojo.connect(document.body, 'ontouchstart', function (e) { return me.bodyTouchStart(e); }));
                this.connectHandlers.push(dojo.connect(this.maintable, 'onclick', function (e) { return me.touchClick(e); }));
                this.connectHandlers.push(dojo.connect(this.div, 'ontouchstart', function (e) { return me.touchStart(e); }));
                this.connectHandlers.push(dojo.connect(this.div, 'ontouchmove', function (e) { return me.touchMove(e); }));
                this.connectHandlers.push(dojo.connect(this.div, 'ontouchend', function (e) { return me.touchEnd(e); }));
            }
            else {
                this.activate(false, false);
                this.connectHandlers.push(dojo.connect(document, 'onmousedown', function (e) { return me.bodyMouseDown(e); }));
                //this.connectHandlers.push(dojo.connect(document, 'onclick', function (e) { me.bodyClick(e); }));
                this.connectHandlers.push(dojo.connect(document, 'onkeydown', function (e) { me.keydown(e); }));
                this.connectHandlers.push(dojo.connect(this.div, 'onmousedown', function (e) { me.mousedown(e); }));
                this.connectHandlers.push(dojo.connect(this.div, 'onmousemove', function (e) { me.mousemove(e); }));
                this.connectHandlers.push(dojo.connect(this.div, 'onmouseup', function (e) { me.mouseup(e); }));
                if (scil.Utils.isFirefox)
                    this.connectHandlers.push(dojo.connect(this.div, 'onwheel', function (e) { me.mousewheel(e); }));
                else
                    this.connectHandlers.push(dojo.connect(this.div, 'onmousewheel', function (e) { me.mousewheel(e); }));
            }

            dojo.attr(this.div, '__ajaxform', '1');
        }
        else {
            if (this.options.popup) {
                if (scil.Utils.isTouch) {
                    this.connectHandlers.push(dojo.connect(this.div, 'ontouchstart', function (e) { if (!scil.Utils.isTouchDblClick(e)) return; me.dblclick(); e.preventDefault(); return false; }));
                } else {
                    this.connectHandlers.push(dojo.connect(this.div, 'ondblclick', function (e) { me.dblclick(); }));
                }
            }

            if (!scil.Utils.isTouch) {
                this.connectHandlers.push(dojo.connect(this.div, 'onmousedown', function (e) { me.mousedown(e, true); }));
                this.connectHandlers.push(dojo.connect(this.div, 'onmousemove', function (e) { me.mousemove(e, true); }));
                this.connectHandlers.push(dojo.connect(this.div, 'onmouseup', function (e) { me.mouseup(e, true); }));
                if (scil.Utils.isFirefox)
                    this.connectHandlers.push(dojo.connect(this.div, 'DOMMouseScroll', function (e) { me.mousewheel(e); }));
                else
                    this.connectHandlers.push(dojo.connect(this.div, 'onmousewheel', function (e) { me.mousewheel(e, true); }));
            }
        }
        this.connectHandlers.push(dojo.connect(this.div, 'onresize', function () { if (!me._clearing) me.onResize(); }));

        dojo.style(this.div, { userSelect: "none", oUserSelect: "none", MozUserSelect: "none", khtmlUserSelect: "none", webkitUserSelect: "none" });

        // guarantee all parents are visible
        var parents = null;
        if (scil.Utils.isIE && (scil.Utils.isIE < 9 || dojox.gfx.renderer != "svg"))
            parents = this._showAllParents(this.div);
        this.surface = dojox.gfx.createSurface(this.div, this.dimension.x, this.dimension.y);
        if (parents != null) {
            //this.surface.rowNode.setAttribute("unselectable", "on");
            this._hideElements(parents);
        }

        if (scil.Utils.isSilverlight == null)
            scil.Utils.isSilverlight = this.div.firstChild != null && this.div.firstChild.type == "application/x-silverlight";

        if (scil.Utils.isSilverlight) {
            if (this.options.popup) {
                // this.connectHandlers.push(dojo.connect(this.div, 'onmousedown', function (e) { me.mousedown2(e); e.preventDefault(); }));
                this.div.style.position = "relative";
                var zindex = parseInt(this.div.zIndex + "");
                if (isNaN(zindex))
                    zindex = 0;
                scil.Utils.createElement(this.div, "div", null, { position: "absolute", left: 0, top: 0, background: "white", filter: "alpha(opacity=1)", width: this.dimension.x + "px", height: this.dimension.y + "px", zIndex: zindex + 1 });
            }
            else if (hastoolbar) {
                this.surface.connect("onkeydown", function (e) { me.keydown(e); });
            }
        }

        if (this.options.showcontextmenu != false) {
            scil.Utils.disableContextMenu(this.div);
            //scil.Utils.disableContextMenu(this.surface);
        }

        this.modified = false;
        //this.activate(true);

        if (this.options.scale > 0) {
            var s = 30 / this.bondlength * this.options.scale;
            if (s != 1)
                this.scale(this.options.scale);
            this.fitToWindow();
        }
        this.redraw();
        this.loaded = true;

        if (hastoolbar) {
            if (this.options.toolbarmode == "tlc")
                this.doCmd("tlc");
            else
                this.doCmd("select");

            if (!this.options.appmode && !scil.Utils.isIE) // except IE, I#10205
                scil.connect(document, "onpaste", function (e) { if (me.doPaste(e)) e.preventDefault(); });
        }
        else {
            this.doCmd("moveview");
        }
    },

    doPaste: function (s) {
        if (!this.activated)
            return false;

        if (this.texteditor.ed != null && this.texteditor.ed.input != null && this.texteditor.ed.input.style.display != "none")
            return false;

        var maxZindex = scil.Utils.getMaxZindex();
        var zindex = scil.Utils.getZindex(this.div);
        if (maxZindex > zindex)
            return false;

        var clipboard = s;
        if (clipboard != null && clipboard.clipboardData != null)
            s = clipboard.clipboardData.getData("text/plain");

        var m = null;
        if (!scil.Utils.isNullOrEmpty(s)) {
            m = new JSDraw2.Mol();
            m.setXml(s);
            if (m.isEmpty())
                m = null;
        }

        if (m == null)
            m = JSDraw2.Editor.getClipboard();

        if (m == null) {
            // try ajax paste
            if (clipboard != null && clipboard.clipboardData != null && JSDrawServices != null && JSDrawServices.url != null) {
                var rtf = clipboard.clipboardData.getData("text/rtf");
                if (!scil.Utils.isNullOrEmpty(rtf)) {
                    var me = this;
                    scil.Utils.ajax(JSDrawServices.url + "?cmd=paste.rtf2jsdraw", function (ret) {
                        if (ret == null && ret.jsdraw == null)
                            return;
                        var m = new JSDraw2.Mol();
                        if (m.setXml(JSDraw2.Base64.decode(ret.jsdraw)) == null)
                            return;
                        var f = me.pasteMol(m);
                        if (f)
                            me.refresh();
                    }, { rtf: rtf });
                }
            }
            return false;
        }

        var ret = this.pasteMol(m);
        if (ret)
            this.refresh();
        return true;
    },

    _showAllParents: function (e) {
        var ret = { display: [], visibility: [], visvalues: [] };
        while (e != null && e.style != null) {
            if (e.style.display == "none") {
                ret.display.push(e);
                e.style.display = "";
            }
            if (e.style.visibility != "" && e.style.visibility != null && e.style.visibility != "visible") {
                ret.visibility.push(e);
                ret.visvalues.push(e.style.visibility);
                e.style.visibility = "visible";
            }
            e = e.parentNode;
        }
        return ret;
    },

    _hideElements: function (ret) {
        if (ret == null)
            return;
        for (var i = 0; i < ret.display.length; ++i)
            ret.display[i].style.display = "none";
        for (var i = 0; i < ret.visibility.length; ++i)
            ret.visibility[i].style.visibility = ret.visvalues[i];
    },

    reset: function () {
        this.clear(true);
        this._undostack.clear();
        this._redostack.clear();

        if (this.options.toolbarmode == "tlc")
            this.doCmd("tlc");
        else
            this.doCmd("select");
    },

    /**
    * Push the current status into undo stack
    * @function pushundo
    * @returns null
    */
    pushundo: function (m, action) {
        if (this.disableundo)
            return;

        if (m == null && action != null && this.lastaction == action)
            return;

        this.lastaction = action;
        this._redostack.clear();
        this._undostack.push(m == null ? this.clone() : m);
    },

    /**
    * Undo once
    * @function undo
    * @returns null
    */
    undo: function () {
        if (this.disableundo)
            return;

        var m = this._undostack.pop();
        if (m == null)
            return false;

        this._redostack.push(this.clone());
        this.restoreClone(m);
        this.setModified(true);
        return true;
    },

    restoreClone: function (m) {
        this._setmol(m.mol);
        this.resetScale(m);
    },


    /**
    * Redo once
    * @function redo
    * @returns null
    */
    redo: function () {
        if (this.disableundo)
            return;

        var m = this._redostack.pop();
        if (m == null)
            return false;

        this._undostack.push(this.clone());
        this._setmol(m.mol);
        this.resetScale(m);
        this.setModified(true);
        return true;
    },

    /**
    * Copy
    * @function copy
    * @returns null
    */
    copy: function (m) {
        if (m == null) {
            m = this.m.clone(true);
            m.bondlength = this.bondlength;
        }
        JSDraw2.Editor.setClipboard(m, this.bondlength);

        if (scil.Clipboard != null && m != null && !m.isEmpty()) {
            scil.Clipboard.copy(m.getXml(null, null, null, null, this.bondlength));
            return true;
        }

        return false;
    },

    /**
    * Cut
    * @function cut
    * @returns null
    */
    cut: function () {
        if (!this.copy())
            return false;
        this.pushundo();
        return this.delSelected() > 0;
    },

    /**
    * Paste
    * @function past
    * @param {Point} pos - place the pasted structure to this location
    * @returns the Mol
    */
    paste: function (pos) {
        var m = JSDraw2.Editor.getClipboard();
        return this.pasteMol(m);
    },

    /**
    * Paste a mol
    * @function past
    * @param {Mol} m - molecule to be pasted
    * @param {Point} pos - place the pasted structure to this location
    * @returns the Mol
    */
    pasteMol: function (m, pos, clear) {
        if (m == null)
            return false;

        if (typeof (m) == "string") {
            var mol = new JSDraw2.Mol(this.options.showimplicithydrogens);
            mol.setMolfile(m);
            m = mol;
        }

        var empty = this.m.isEmpty();
        this.pushundo();

        if (clear == true)
            this.clear(null, true);

        var len = null;
        if (m.bondlength > 0) {
            len = this.bondlength; //I#9549
            m.scale(this.bondlength / m.bondlength);
            //this.resetScale();
        }
        else {
            var len2 = m.medBondLength();
            if (!(len2 > 0))
                len2 = 1.56;
            var len = this.m.medBondLength();
            if (!(len > 0))
                len = this.bondlength;
            m.scale(len / len2);
        }

        if (pos == null) {
            m.moveCenter(this.dimension.x, this.dimension.y);
            m.offset(10, 10);
        }
        else {
            var c = m.center();
            m.offset(pos.x - c.x, pos.y - c.y);
        }

        m.showimplicithydrogens = this.options.showimplicithydrogens;
        this.m.setSelected();
        m.setSelected(true);
        m.calcHCount(true);

        // make rxn
        var reaction = null;
        var rxn = this.m.parseRxn(true);
        var rxn2 = m.parseRxn(true);
        if ((clear == "reactant" || clear == "product") && rxn2 != null && rxn2.arrow == null) {
            if (clear == "reactant")
                scil.Utils.mergeArray(rxn.reactants, rxn2.reactants);
            else
                scil.Utils.mergeArray(rxn.products, rxn2.reactants);
            reaction = rxn;
        }
        else if (rxn != null && (rxn.reactants.length > 0 || rxn.products.length > 0)) {
            if (rxn.arrow != null) {
                if (rxn2.arrow == null) {
                    if (rxn.reactants.length == 0)
                        rxn.reactants = rxn2.reactants;
                    else
                        scil.Utils.mergeArray(rxn.products, rxn2.reactants);
                    reaction = rxn;
                }
            }
            else {
                if (rxn2.arrow != null) {
                    if (rxn.arrow == null) {
                        if (rxn2.reactants.length == 0)
                            rxn2.reactants = rxn.reactants;
                        else
                            scil.Utils.mergeArray(rxn2.products, rxn.reactants);
                    }
                    reaction = rxn2;
                }
            }
        }

        if (reaction != null) {
            this.m.setRxn(reaction, len);
            this.fitToWindow();
        }
        else {
            var tlcplates = [];
            for (var i = m.graphics.length - 1; i >= 0; --i) {
                var t = JSDraw2.TLC.cast(m.graphics[i]);
                if (t != null) {
                    m.graphics.splice(i, 1);
                    tlcplates.splice(0, 0, t);
                }
            }

            this.m.mergeMol(m);
            for (var i = 0; i < tlcplates.length; ++i)
                this.addTlcPlate(tlcplates[i]);

            if (m.chiral != null)
                this.m.chiral = m.chiral;

            if (empty)
                this.fitToWindow();
        }

        this.setModified(true);
        return true;
    },

    /**
    * Reset scaling
    * @function resetScale
    * @returns null
    */
    resetScale: function (s) {
        this.bondlength = s == null ? JSDraw2.Editor.BONDLENGTH : s.bondlength;
        this.tor = s == null ? JSDraw2.Editor.TOR : s.tor;
        this.linewidth = s == null ? JSDraw2.Editor.LINEWIDTH : s.linewidth;
        this.fontsize = s == null ? JSDraw2.Editor.FONTSIZE : s.fontsize;
        this.angleStop = s == null ? JSDraw2.Editor.ANGLESTOP : s.angleStop;
    },

    clone: function () {
        return { mol: this.m.clone(), bondlength: this.bondlength, tor: this.tor, linewidth: this.linewidth, fontsize: this.fontsize, angleStop: this.angleStop };
    },

    showTextEditor: function (obj, p, str) {
        var text = this.texteditor.text = JSDraw2.Text.cast(obj);
        if (text != null && text.readonly)
            return;

        if (this.texteditor.hidetime != null) {
            var tm = this.texteditor.hidetime;
            this.texteditor.hidetime = null;
            if (new Date().getTime() - tm < 500)
                return;
        }

        var a = this.texteditor.atom = JSDraw2.Atom.cast(obj);
        var t = JSDraw2.Text.cast(obj);
        var shp = this.texteditor.shape = JSDraw2.Shape.cast(obj);
        var br = t != null && t.anchors != null && t.anchors.length == 1 ? JSDraw2.Bracket.cast(t.anchors[0]) : null;
        if (a != null) {
            p.x -= 6 * this.bondlength / 30;
            p.y -= 9 * this.bondlength / 30;
        }
        else if (shp != null) {
            p.x = shp._rect.left + shp._rect.width / 10;
            p.y = shp._rect.center().y - 9 * this.bondlength / 30;
        }

        var me = this;
        if (this.texteditor.ed == null) {
            var input = scil.Utils.createElement(document.body, "input");
            this.texteditor.ed = new scil.DropdownInput(input, { onclickitem: function (s) { return me.clickTextItem(s); } });
            dojo.style(this.texteditor.ed.input, { position: "absolute", display: "none", zIndex: 999 });
            this.connectHandlers.push(dojo.connect(this.texteditor.ed.input, "onkeydown", function (e) { return me.txtKeypress(e); }));
        }

        var options = this.texteditor.ed.options;
        if (a != null) {
            var list = null;
            if (a.bio != null && this.helm != null)
                list = scil.helm.Monomers.getMonomerList(a);
            else
                list = JSDraw2.defaultoptions.atomlist != null ? JSDraw2.defaultoptions.atomlist : JSDraw2.PT.getCommonUsedElements("list");
            this.texteditor.ed.setItems(list);
            options.onSetValue = function (input, s) { input.value = s; };
            options.minautowidth = JSDraw2.defaultoptions.minautowidth1 > 0 ? JSDraw2.defaultoptions.minautowidth1 : 100;
            if (a.bio != null)
                options.onFilter = null;
            else
                options.onFilter = function (q) { return me.filterAtomType(q); };
        }
        else if (shp != null) {
            this.texteditor.ed.setItems(null);
        }
        else if (br != null) {
            if (t.fieldtype == "BRACKET_TYPE") {
                this.texteditor.ed.setItems(JSDraw2.SGroup == null ? null : JSDraw2.SGroup.getDisplayTypes());
                options.onSetValue = function (input, s) {
                    var s2 = "";
                    if (scil.Utils.endswith(s, ")")) {
                        var p = s.lastIndexOf('(');
                        if (p > 0)
                            s2 = s.substr(p + 1, s.length - p - 2);
                    }
                    input.value = s2;
                };
                options.minautowidth = JSDraw2.defaultoptions.minautowidth2 > 0 ? JSDraw2.defaultoptions.minautowidth2 : 150;
                options.onFilter = null;
            }
            else if (t.fieldtype == "MOL_TYPE") {
                this.texteditor.ed.setItems(JSDraw2.MOLECULETYPES);
                options.onSetValue = function (input, s) {
                    if (scil.Utils.isNullOrEmpty(s))
                        this.mol.delGraphics(t);
                    else
                        input.value = s;
                };
                options.minautowidth = JSDraw2.defaultoptions.minautowidth2 > 0 ? JSDraw2.defaultoptions.minautowidth2 : 150;
                options.onFilter = null;
            }
        }
        else {
            this.texteditor.ed.setItems(JSDraw2.defaultoptions.textlist != null ? JSDraw2.defaultoptions.textlist : JSDraw2.TEXTKEYWORDS);
            options.onSetValue = function (input, s) { if (scil.Utils.indexOf(options.items, s) >= 0) input.value += s; else input.value = s; };
            options.minautowidth = JSDraw2.defaultoptions.minautowidth3 > 0 ? JSDraw2.defaultoptions.minautowidth3 : 300;
            options.autosuggest = this.options.reagentsuggest;
            options.onFilter = options.autosuggest != null ? null : function () { };
        }
        var z = scil.Utils.getZindex(this.div);
        this.texteditor.ed.input.style.zIndex = z > 0 ? (z + 1) : 1;

        if (text != null)
            p = new JSDraw2.Point(text._rect.left, text._rect.top);
        else
            p.offset(-2, -2);
        var offset = scil.Utils.getOffset(this.div, false);
        dojo.style(this.texteditor.ed.input, { fontSize: this.fontsize + "px" });
        dojo.style(this.texteditor.ed.input, { left: (p.x + offset.x) + "px", top: (p.y + offset.y) + "px", display: "" });

        var selectall = true;
        if (text != null) {
            this.texteditor.ed.input.value = str == null ? text.text : str;
        }
        else if (a != null) {
            var s = a.getLabel();
            if (a.charge > 0) {
                if (a.charge > 1)
                    s += a.charge;
                else
                    s += "+";
            }
            else if (a.charge < 0) {
                if (a.charge > 1)
                    s += a.charge;
                else
                    s += "-";
            }
            this.texteditor.ed.input.value = s;
        }
        else if (shp != null) {
            this.texteditor.ed.input.value = shp.text;
        }
        else if (str != null) {
            this.texteditor.ed.input.value = str;
            selectall = false;
        }
        // dojo.attr(this.texteditor.ed, "changed", '');

        this.txtAutosize();
        if (selectall)
            this.texteditor.ed.input.select();
        this.texteditor.ed.input.style.display = "";
        this.texteditor.ed.input.focus();
        this.texteditor.showtime = new Date().getTime();
    },

    filterAtomType: function (q) {
        if (this.texteditor.atom == null)
            return;
        return JSDraw2.SuperAtoms.filter(q, JSDraw2.defaultoptions.suggestcount > 0 ? JSDraw2.defaultoptions.suggestcount : 10);
    },

    createImageTo: function (parent) {
        if (!scil.Utils.serviceAvailable() || parent == null)
            return;

        if (typeof (parent) == "string")
            parent = scil.byId(parent);

        var jsdraw = this.getXml();
        scil.Utils.ajax(JSDrawServices.url + "?cmd=jsdraw2img", function (ret) {
            scil.Utils.createElement(parent, "img", null, null, { src: ret.src, jsdraw: JSDraw2.Base64.encode(jsdraw) });
        }, { jsdraw: jsdraw });
    },

    clickTextItem: function (s) {
        if (this.texteditor.atom != null) {
            if (s == "...") {
                this.hideTextEditor(true);

                this.m.setSelected(false);
                this.texteditor.atom.selected = true;
                this.refresh(false);

                var me = this;
                this.showPT(function (elem) { me.menuSetAtomType2(elem); });
            }
            else {
                this.hideTextEditor();
            }
        }
        else {
            this.txtAutosize();
        }
    },

    insertSymbol: function (symbol) {
        if (this.texteditor.ed == null || this.texteditor.ed.input.style.display == "none")
            return false;
        this.texteditor.ed.input.focus();

        var caretposition = JSDraw2.Symbol.getCaretPosition(this.texteditor.ed.input);
        var s = this.texteditor.ed.input.value;
        if (caretposition > 0 && caretposition < s.length) {
            this.texteditor.ed.input.value = s.substr(0, caretposition) + symbol + s.substr(caretposition);
            ++caretposition;
            JSDraw2.Symbol.setCaretPosition(this.texteditor.ed.input, caretposition);
        }
        else {
            this.texteditor.ed.input.value += symbol;
        }
        this.txtAutosize();
        return false;
    },

    hideTextEditor: function (cancel) {
        if (this.texteditor.ed == null || this.texteditor.ed.input.style.display == "none")
            return;

        if (this.texteditor.showtime != null) {
            var tm = this.texteditor.showtime;
            this.texteditor.showtime = null;
            if (new Date().getTime() - tm < 500)
                return;
        }

        this.texteditor.ed.hide();
        this.texteditor.ed.input.style.display = "none";
        this.texteditor.ed.input.style.display = "none";
        this.texteditor.hidetime = new Date().getTime();

        var s = scil.Utils.trim(this.texteditor.ed.input.value);
        this.texteditor.ed.input.value = "";
        if (cancel == true)
            return;

        if (this.options.onvalidatetext != null) {
            if (this.options.onvalidatetext(s, this.texteditor, this) == false)
                return;
        }

        if (JSDraw2.Symbol != null)
            JSDraw2.Symbol.hide();

        if (this.texteditor.atom != null) {
            if (s == "")
                s = "C";
            var cloned = this.clone();

            if (this.texteditor.atom.bio != null) {
                if (this.helm != null && scil.helm.isHelmNode(this.texteditor.atom)) {
                    f = this.helm.setNodeTypeFromGui(this.texteditor.atom, s);
                }
            }
            else {
                s = JSDraw2.FormulaParser.stripHs(s);
                var f = this.m.setAtomAlias(this.texteditor.atom, s) || this.m.setAtomType(this.texteditor.atom, s, true);
            }

            if (f) {
                this.pushundo(cloned);
                this.refresh(true);
            }
        }
        else if (this.texteditor.shape != null) {
            if (this.texteditor.shape.text != s) {
                this.pushundo();
                this.texteditor.shape.text = s;
                this.refresh(true);
            }
        }
        else {
            if (this.texteditor.text == null) {
                if (s.length == 0)
                    return;

                var offset = scil.Utils.getOffset(this.div, false);
                var rect = scil.Utils.styleRect(this.texteditor.ed.input);
                rect.offset(-offset.x, -offset.y);
                var txt = new JSDraw2.Text(rect, s);
                this.pushundo();
                this.m.addGraphics(txt);
                this.refresh(true);
            }
            else {
                if (s == this.texteditor.text.text)
                    return;

                this.pushundo();
                if (s.length == 0)
                    this.texteditor.text._parent.delObject(this.texteditor.text);
                else
                    this.texteditor.text.text = s;
                if (this.texteditor.text.fieldtype == "BRACKET_TYPE" && this.texteditor.text.anchors.length == 1 && JSDraw2.Bracket.cast(this.texteditor.text.anchors[0]) != null) {
                    if (scil.Utils.isNumber(s))
                        this.texteditor.text.anchors[0].type = "mul";
                    else
                        this.texteditor.text.anchors[0].type = s;
                }
                this.texteditor.text = null;
                this.refresh(true);
            }
        }
    },

    showTemplatesDlg: function () {
        JSDraw2.CustomTemplates.show(false, this);
    },

    showSymbolDlg: function () {
        var input = this.texteditor == null || this.texteditor.ed == null ? null : this.texteditor.ed.input;
        var pt = input == null || input.style.display == "none" ? null : { x: input.offsetLeft, y: input.offsetTop + input.offsetHeight + 5 };
        var me = this;
        JSDraw2.Symbol.show(false, function (s) { return me.insertSymbol(s); }, pt);
    },

    txtKeypress: function (e) {
        if ((e.keyCode == 40 || e.keyCode == 38) && (e.ctrlKey || e.metaKey) && JSDraw2.Symbol != null) {
            if (e.keyCode == 40)
                this.showSymbolDlg();
            else
                JSDraw2.Symbol.hide();
            e.preventDefault();
            return false;
        }

        if (e.keyCode == 27 || e.keyCode == 13) {
            this.hideTextEditor(e.keyCode == 27);
            e.time2 = 903;
            e.preventDefault();
            return false;
        }
        this.txtAutosize();
    },

    txtAutosize: function () {
        var w = scil.Utils.textWidth(this.texteditor.ed.input.value) * this.fontsize * 0.6 + this.fontsize * 3;
        this.texteditor.ed.input.style.width = (w < 100 ? 100 : w) + "px";
        this.texteditor.ed.updateDropdownSize();
    },

    _setmol: function (m) {
        this.m = m;
        this.m.showimplicithydrogens = this.options.showimplicithydrogens;
        this.start = null;
        this.end = null;
        this.status = null;
        this.curObject = null;
    },

    /**
    * Scale the molecule
    * @function scale
    * @param {number} s - the scaling factor
    * @param {Point} origin - the scaling origin
    * @returns null
    */
    scale: function (s, origin) {
        if (s <= 0 || s == 1.0)
            return;

        if (this.bondlength * s < JSDraw2.speedup.minbondlength)
            s = JSDraw2.speedup.minbondlength / this.bondlength;

        this.m.scale(s, origin);
        this.bondlength *= s;
        this.tor *= s;
        this.linewidth *= s;
        this.fontsize *= s;

        if (origin == null)
            this.moveCenter();
    },

    /**
    * Set modified flag
    * @function setModified
    * @param {bool} f - true or false
    * @returns null
    */
    setModified: function (f) {
        this.modified = f;
        if (f == false)
            return;

        if (this.options.ondatachange != null && this.loaded) {
            if (typeof this.options.ondatachange == "function") {
                this.options.ondatachange(this);
            }
            else {
                try {
                    eval(this.options.ondatachange)(this);
                }
                catch (e) {
                }
            }
        }
    },

    /**
    * Refresh the display
    * @function refresh
    * @param {bool} modified - modified flag
    * @returns null
    */
    refresh: function (modified) {
        this.m.stats = null;
        if (modified == true || modified == false)
            this.setModified(modified);
        this.redraw();
    },

    calcTextRect: function () {
        if (this.surface == null || scil.Utils.isIE8Lower && this.surface.rawNode == null)
            return;

        var g = this.createGroup();
        this.m.draw(g, this.linewidth, this.fontsize, true, null, null, true);
        this.surface.remove(g);
    },

    createGroup: function (parent) {
        var g = (parent == null ? this.surface : parent).createGroup();
        if (dojox.gfx.renderer == "svg")
            g.rawNode.setAttribute("__surface_parentid", this.id);
        return g;
    },

    moveview: function (p) {
        this.viewoffset = p;
        if (this.viewoffset != null)
            this.surface.rootgroup.setTransform([dojox.gfx.matrix.translate(this.viewoffset.x, this.viewoffset.y)]);
        else
            this.surface.rootgroup.setTransform([dojox.gfx.matrix.translate(0, 0)]);
    },

    /**
    * Redraw the molecule
    * @function redraw
    * @returns null
    */
    redraw: function (extraOnly) {
        if (this.surface == null || scil.Utils.isIE8Lower && this.surface.rawNode == null)
            return;

        if (this.surface.rootgroup == null) {
            this.surface.rootgroup = this.createGroup();

            if (JSDraw2.Security.error != null) {
                this.surface.createText({ x: 5, y: 25, text: JSDraw2.Security.error, align: "start" })
                    .setFont({ family: "Arial", size: "20px", weight: "normal" })
                    .setFill("#ffe0e0");
            }
        }
        if (this.viewoffset != null)
            this.surface.rootgroup.setTransform([dojox.gfx.matrix.translate(this.viewoffset.x, this.viewoffset.y)]);
        else
            this.surface.rootgroup.setTransform(null);

        this._clearing = true;
        if (extraOnly) {
            if (this.surface.extra != null) {
                this.surface.extra.clear();
                this.surface.extra.lasso = null;
            }
        }
        else {
            this.surface.rootgroup.clear();
            this.surface.extra = null;
            this._clearing = false;
            var g = this.createGroup(this.surface.rootgroup);
            g.monocolor = this.options.monocolor || JSDraw2.defaultoptions.monocolor;
            this.simpledraw = this.fontsize <= JSDraw2.speedup.fontsize;
            this.updateGroupRect();
            this.m.draw(g, this.linewidth, this.fontsize, null, this.dimension, this.options.highlighterrors, this.options.showcarbon, this.simpledraw);
        }

        var cmd = this.getCmd();
        if (this.surface.extra == null)
            this.surface.extra = this.createGroup(this.surface.rootgroup);
        var extra = this.surface.extra;
        if (this.curObject != null)
            this.curObject.drawCur(extra, this.fontsize / 2 + 1, JSDraw2.Editor.COLORCURRENT, this.m, cmd);

        if (this.start != null && this.end != null) {
            switch (cmd) {
                case "arrow":
                    if (this.arrowtool != null && this.arrowtool.connector == "rejector")
                        JSDraw2.Drawer.drawArrow(extra, this.start, this.end, "gray", this.linewidth, this.linewidth * 2);
                    else
                        JSDraw2.Drawer.drawArrow(extra, this.start, this.end, "gray", this.linewidth);
                    break;
                case "curve":
                    JSDraw2.Drawer.drawCurveArrow(extra, this.start, this.end, null, null, "gray", this.linewidth / 2);
                    break;
                case "rectangle":
                    JSDraw2.Drawer.drawRect(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 2, 5);
                    break;
                case "assaycurve":
                    JSDraw2.Drawer.drawRect(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 4);
                    break;
                case "spectrum":
                    JSDraw2.Drawer.drawRect(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 4);
                    break;
                case "ellipse":
                    JSDraw2.Drawer.drawEllipse(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 2);
                    break;
                case "diamond":
                    JSDraw2.Drawer.drawDiamond(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 2);
                    break;
                case "dreversed":
                    JSDraw2.Drawer.drawDShape(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 2, true);
                    break;
                case "dshape":
                    JSDraw2.Drawer.drawDShape(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth / 2);
                    break;
                case "doublearrow":
                    JSDraw2.Drawer.drawDoubleArrow(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth);
                    break;
                case "tlc":
                case "electrophoresis":
                    if (this.movingClone == null)
                        new JSDraw2.TLC.create(cmd, this.start, this.end, this.fontsize / 2).draw(extra, this.linewidth, null, this.fontsize);
                    break;
                case "select":
                case "lasso":
                case "selfrag":
                case "zoombox":
                    if (this.movingClone == null)
                        JSDraw2.Drawer.drawRect(extra, new JSDraw2.Rect().set(this.start, this.end), "#aaaaff", 1);
                    break;
                case "bracket":
                    JSDraw2.Drawer.drawBracket(extra, new JSDraw2.Rect().set(this.start, this.end), "gray", this.linewidth);
                    break;
                case "chain":
                    if (this.chaintool != null) {
                        var pts = this.chaintool.points;
                        for (var i = 1; i < pts.length; ++i)
                            JSDraw2.Drawer.drawLine(extra, pts[i - 1], pts[i], "gray", this.linewidth);
                    }

                    if (!(scil.Utils.isIE && scil.Utils.isIE < 9 && this.options.appmode))
                        JSDraw2.Drawer.drawText(extra, pts[pts.length - 1], pts.length - 1, "gray", this.fontsize);
                    break;
                default:
                    if (cmd == "sgroup")
                        JSDraw2.Drawer.drawArrow(extra, this.start, this.end, "red", this.linewidth / 2);
                    else if (cmd != "rotate" && cmd != "eraser" && cmd != "plus" && cmd != "rxnmap" && cmd != "text" &&
                        cmd != "undo" && cmd != "redo" && cmd != "zoomin" && cmd != "zoomout")
                        JSDraw2.Drawer.drawLine(extra, this.start, this.end, "gray", this.linewidth);
                    break;
            }
        }

        if (this.status != null && this.status.length > 0) {
            var y = this.dimension.y - 10;
            extra.createText({ x: 5, y: y, text: this.status, align: "bottom" })
              .setFont({ family: "Arial", size: "14px", weight: "normal" })
              .setFill("#000");
        }
    },

    /**
    * Fit the molecule to the view window
    * @function fitToWindow
    * @param {number} maxBondLength - maximum bond length
    * @returns null
    */
    fitToWindow: function (maxBondLength) {
        var rect = this.m.rect();
        if (rect == null)
            return;

        if (maxBondLength == null) {
            maxBondLength = JSDraw2.Editor.BONDLENGTH;
            if (this.options.scale > 0)
                maxBondLength *= this.options.scale;
        }

        rect.inflate(this.bondlength, this.bondlength);
        var hs = rect.width / this.dimension.x;
        var vs = rect.height / this.dimension.y;

        var s;
        if (hs == 0)
            s = vs;
        else if (vs == 0)
            s = hs;
        else
            s = Math.max(vs, hs);

        if (maxBondLength > 0 && this.bondlength / s > maxBondLength)
            s = this.bondlength / maxBondLength;

        if (s == 1.0)
            this.moveCenter();
        else
            this.scale(1.0 / s);
    },

    /**
    * Move the structure to center of the view window
    * @function moveCenter
    * @returns null
    */
    moveCenter: function () {
        this.m.moveCenter(this.dimension.x, this.dimension.y);
    },

    updateGroupRect: function () {
        for (var i = 0; i < this.m.graphics.length; ++i) {
            var g = JSDraw2.Group.cast(this.m.graphics[i]);
            if (g != null)
                g._updateRect(this.m, this.bondlength);
        }
    },

    /**
    * Clean up reaction
    * @function cleanupRxn
    * @returns true if it is a reaction
    */
    cleanupRxn: function () {
        var f = this.m.cleanupRxn(this.bondlength);
        if (f)
            this.fitToWindow(this.bondlength);
        return f;
    },

    setRxn: function (rxn, redraw, bondlength, addlabel) {
        this.pushundo();
        if (bondlength != null)
            this.bondlength = bondlength;

        if (addlabel) {
            for (var i = 0; i < rxn.reactants.length; ++i)
                rxn.reactants[i].removeTextByFieldType("RXNLABEL");
            for (var i = 0; i < rxn.products.length; ++i)
                rxn.products[i].removeTextByFieldType("RXNLABEL");
        }

        this.m.setRxn(rxn, this.bondlength);
        this.calcTextRect();
        this.m._layoutRxn(rxn, this.bondlength);

        if (addlabel) {
            for (var i = 0; i < rxn.reactants.length; ++i)
                this.m._addRxnLabel(rxn.reactants[i], this.bondlength / 2);
            for (var i = 0; i < rxn.products.length; ++i)
                this.m._addRxnLabel(rxn.products[i], this.bondlength / 2);
        }

        this.fitToWindow(this.bondlength);
        if (redraw != false)
            this.redraw();
    },

    /**
    * Clear all contents
    * @function clear
    * @param {bool} redraw - indicate if redrawing the view wndow
    * @returns null
    */
    clear: function (redraw, fireevents) {
        var isempty = this.m.isEmpty();

        this.m.clear();
        this.curObject = null;
        if (redraw)
            this.redraw();
        this.resetScale();
        if (this.options.scale > 0)
            this.scale(this.options.scale);
        if (this.ink != null)
            this.ink.clear();

        if (!isempty) {
            if (fireevents && this.options.onClear != null)
                this.options.onClear();
        }
    },

    toggleAtom: function (p) {
        return this.m.toggleAtom(p, this.simpledraw ? JSDraw2.Editor.TOR : this.tor);
    },

    toggle: function (p) {
        return this.m.toggle(p, this.simpledraw ? JSDraw2.Editor.TOR : this.tor);
    },

    fixWedgeDir: function (b) {
        var atoms1 = this.m.getNeighborAtoms(b.a1, b.a2);
        var atoms2 = this.m.getNeighborAtoms(b.a2, b.a1);
        if ((atoms1.length == 0 || atoms1.length == 1) && atoms1.length < atoms2.length)
            b.reverse();
    },

    /**
    * Get the fragment containing a given atom
    * @function getFragment
    * @param {Atom} a - the given atom
    * @returns the fragement as a Mol object
    */
    getFragment: function (a) {
        var frags = this.m.splitFragments();
        for (var i = 0; i < frags.length; ++i) {
            if (frags[i].containsAtom(a))
                return frags[i];
        }
        return null;
    },

    /**
    * Get the center of a set of atoms
    * @function getCenter
    * @param {array} atoms - an array of atoms
    * @returns a Point object
    */
    getCenter: function (atoms) {
        var x = 0;
        var y = 0;
        if (atoms == null)
            atoms = this.m.atoms;
        if (atoms.length == 0)
            return null;

        for (var i = 0; i < atoms.length; ++i) {
            var a = atoms[i];
            x += a.p.x;
            y += a.p.y;
        }

        return new JSDraw2.Point(x / atoms.length, y / atoms.length);
    },

    /**
    * Rotate atoms around a point
    * @function rotate
    * @param {array} atoms - an array of atom
    * @param {Point} origin - rotating orgin
    * @param {deg} atoms - rotating degree
    * @returns null
    */
    rotate: function (atoms, origin, deg) {
        if (atoms == null)
            atoms = this.m.atoms;

        if (Math.abs(deg) < 0.1 || atoms.length == 0)
            return false;

        for (var i = 0; i < atoms.length; ++i)
            atoms[i].p.rotateAround(origin, deg);

        return true;
    },

    //    mousedown2: function (e) {
    //        // silverlight - simulate double-click
    //        if (this.options.popup) {
    //            var tm = new Date().getTime();
    //            if (this._lastMousedownTm != null && tm - this._lastMousedownTm < 300)
    //                this.dblclick();
    //            this._lastMousedownTm = tm;
    //        }
    //    },

    startResize: function (obj, p, ctrl, cmd) {
        if (obj.resize == null)
            return;

        var corner = obj.cornerTest(p, this.tor, ctrl, cmd);
        if (corner != null) {
            var list = [];
            this.resizing = { corner: corner, obj: obj, start: p, list: list };
            var br = JSDraw2.Bracket.cast(obj);
            if (br != null)
                this.resizing.texts = br.getTexts(this.m);
        }
    },

    getConnectingAtomBonds: function (list) {
        var links = [];
        if (list != null && list.length > 0) {
            var m = list[0]._parent;
            m.clearFlag();
            for (var i = 0; i < list.length; ++i)
                list[i].f = true;
            for (var i = 0; i < m.bonds.length; ++i) {
                var b = m.bonds[i];
                if (b.a1.f != b.a2.f) {
                    links.push({ a: b.a1.f ? b.a1 : b.a2, b: b });
                }
            }
        }
        return links;
    },

    mousewheel: function (e, viewonly) {
        if (!this.activated && !viewonly)
            return;

        var cmd = this.getCmd();
        if (cmd != "moveview")
            return;

        var delta = (e.wheelDelta || -e.detail || (Math.abs(e.deltaY) > Math.abs(e.deltaX) ? e.deltaY : e.deltaX));
        if (scil.Utils.isFirefox)
            delta *= 20.0;

        if (delta > 0 || delta < 0) {
            var p = this.eventPoint(e);
            this.scale(1.0 + delta / 500.0, p);
            if (!viewonly) {
                this.pushundo(null, "moveview");
                this.refresh(true);
            }
            else {
                this.redraw();
            }
        }

        if (scil.Utils.isFirefox) {
            e.stopImmediatePropagation();
            e.stopPropagation();
        }
        e.preventDefault();
    },

    mousedown: function (e, viewonly) {
        if (!this.activated) {
            this.mousedownPoint = new JSDraw2.Point(e.clientX, e.clientY);
            if (viewonly && e.button == 0)
                this.start = this.eventPoint(e);
            return;
        }
        if (this.contextmenu != null && this.contextmenu.hide())
            return;

        JSDraw2.Menu.close();
        this.holding.start(e, this);

        //this.div.focus();
        if (!scil.Utils.isTouch && e.button != (scil.Utils.isIE8Lower ? 1 : 0))
            return;

        this.start = null;
        this.end = null;
        this.movingClone = null;
        this.resizing = null;
        this.lassolast = null;

        var cmd = this.getCmd();

        var tm = new Date().getTime();
        var tm0 = this._lastMousedownTm;
        this._lastMousedownTm = tm;
        if (tm - tm0 < JSDraw2.Editor.dblclickdelay && (cmd == "select" || cmd == "lasso" || cmd == "selfrag")) {
            if (this.surface.extra != null)
                this.surface.extra.lasso = null;
            this.mousedblclick(e);
            e.preventDefault();
            return;
        }

        var p = this.eventPoint(e);
        if (cmd == "moveview") {
            this.start = p;
            this.viewoffset = null;
            return;
        }

        if (scil.Utils.startswith(cmd, "spot-")) {
            this.start = p;
            return;
        }

        if (cmd == "inkred" || cmd == "inkblue" || cmd == "inkgreen") {
            if (this.ink == null) {
                this.surface.ink = this.createGroup();
                this.ink = new JSDraw2.Ink(this.surface.ink);
            }
            this.ink.start(cmd.substr(3), p);
            return;
        }

        var obj = this.toggle(p);
        if (cmd == "eraser") {
            this.start = p;
            this.erasercache = { count: 0, cloned: this.clone(), singleton: false };
            if (obj != null) {
                if (JSDraw2.TLC.cast(obj) != null) {
                    obj.cornerTest(p, this.tor, false, "eraser");
                    if (obj.curspot != null)
                        this.erasercache.singleton = true;
                }
                this.delObject(obj);
                ++this.erasercache.count;
                this.redraw();
            }
            this.div.style.cursor = "pointer";
            return;
        }

        this.curObject = obj;
        this.div.style.cursor = "crosshair";
        if (obj != null) {
            if (cmd == "select" || cmd == "lasso" || cmd == "selfrag" || (cmd == "tlc" || cmd == "electrophoresis") && JSDraw2.TLC.cast(obj) != null) {
                if (obj.selected && obj.resize != null && this.m.countSelected() == 1)
                    this.startResize(obj, p, e.ctrlKey || e.metaKey, cmd);

                if (this.resizing == null && !obj.selected) {
                    var a = null;
                    var g = null;
                    if (cmd == "selfrag") {
                        var a = JSDraw2.Atom.cast(obj);
                        var b = JSDraw2.Bond.cast(obj);
                        var g = JSDraw2.Group.cast(obj);
                        var br = JSDraw2.Bracket.cast(obj);
                        if (b != null)
                            a = b.a1;
                    }

                    if (!e.shiftKey)
                        this.m.setSelected(false);
                    if (a != null) {
                        // selfrag to select a fragment
                        if (a != null) {
                            var m = a._parent.getFragment(a, a._parent);
                            for (var i = 0; i < m.atoms.length; ++i)
                                m.atoms[i].selected = true;
                            for (var i = 0; i < m.bonds.length; ++i)
                                m.bonds[i].selected = true;
                        }

                        if (this.options.onselectionchanged != null)
                            this.options.onselectionchanged(this);
                        this.redraw();
                    }
                    else if (g != null) {
                        // selfrag to select group atoms
                        for (var i = 0; i < g._parent.atoms.length; ++i) {
                            if (g._parent.atoms[i].group == g)
                                g._parent.atoms[i].selected = true;
                        }
                    }
                    else if (br != null) {
                        // selfrag to select bracket atoms
                        for (var i = 0; i < br.atoms.length; ++i) {
                            if (br.atoms[i].group == g)
                                br.atoms[i].selected = true;
                        }
                    }
                    else {
                        obj.selected = true;
                        var b = JSDraw2.Bond.cast(obj);
                        if (b != null)
                            b.a1.selected = b.a2.selected = true;
                        else
                            this.startResize(obj, p, e.ctrlKey || e.metaKey, cmd == "tlc" || cmd == "electrophoresis");
                    }
                }

                if (cmd != "tlc" && cmd != "electrophoresis" || this.resizing != null) {
                    this.start = p;
                    this.movingClone = this.clone();
                    this.movingClone.startPt = p.clone();
                    this.div.style.cursor = "moveview";
                }

                if (cmd == "tlc" || cmd == "electrophoresis")
                    this.redraw();
                return;
            }
        }

        var a1 = JSDraw2.Atom.cast(obj);
        if (a1 != null) {
            p.x = a1.p.x;
            p.y = a1.p.y;
            p.atom = a1;
        }
        this.lastmove = this.start = p;
        if (this.start.tm == null)
            this.start.tm = new Date().getTime();

        if (cmd == "lasso" && obj == null) {
            if (!e.shiftKey && this.m.setSelected(false) > 0)
                this.redraw();
            this.lassolast = p;
            return;
        }

        if (cmd == "chain") {
            this.chaintool = { a: a1, start: this.start, p2: null, end: null, points: [] };
            return;
        }

        if (cmd == "rotate" && a1 == null && !this.m.isEmpty()) {
            var atoms = this.m.atoms;

            var list = [];
            for (var i = 0; i < atoms.length; ++i) {
                if (atoms[i].selected)
                    list.push(atoms[i]);
            }

            if (list.length == 0) {
                var center = this.getCenter(null);
                if (center != null)
                    this.rotating = { atoms: null, center: center };
            }
            else if (list.length == 1) {
                var center = list[0].p.clone();
                if (list.length == 1) {
                    var frag = this.getFragment(list[0]);
                    if (frag != null)
                        list = frag.atoms;
                }
                this.rotating = { atoms: list.length == 1 ? null : list, center: center };
            }
            else {
                var links = this.getConnectingAtomBonds(list, false);
                if (links.length == 1)
                    this.rotating = { atoms: list, center: links[0].a.p.clone() };
                else
                    this.rotating = { atoms: list, center: this.getCenter(list) };
            }

            if (this.rotating != null)
                this.rotating.cloned = this.clone();

            if (a1 != null) {
                this.m.setSelected();
                a1.selected = true;
                this.redraw();
            }
            return;
        }

        if (cmd == "arrow") {
            this.arrowtool = { from: obj };
            if (JSDraw2.Shape.cast(obj) != null) {
                var conn = obj.bestConnectPoint(this.start, this.tor);
                this.start = conn.p;
                this.arrowtool.connector = conn.connector;
            }
        }

        if (cmd != "rxnmap" && !(e.ctrlKey || e.metaKey)) {
            if (!e.shiftKey && this.m.setSelected() > 0)
                this.redraw();
        }
    },

    selectCurrent: function (obj, e) {
        if (this.curObject == obj)
            return false;

        this.curObject = obj;
        if (this.options.onselectcurrent != null)
            this.options.onselectcurrent(e, obj, this);

        if (this.options.showhelmpopup)
            this.onHelmSelectCurrent(e, obj);
        return true;
    },

    onHelmSelectCurrent: function (e, obj) {
        var a = JSDraw2.Atom.cast(obj);
        if (a == null || this.start != null || this.contextmenu != null && this.contextmenu.isVisible()) {
            org.helm.webeditor.MolViewer.hide();
            return;
        }
        var type = a == null ? null : a.biotype();
        if (type == null)
            return;
        var set = org.helm.webeditor.Monomers.getMonomerSet(type);
        var s = a == null ? null : a.elem;
        var m = set == null ? null : set[s.toLowerCase()];
        org.helm.webeditor.MolViewer.show(e, type, m, s, this, a);
    },

    mousemove: function (e, viewonly) {
        if (!this.activated) {
            //this.mousedownPoint = null;
            if (viewonly) {
                if (this.start != null && !this.frozen) {
                    var p = this.eventPoint(e);
                    this.moveview(new JSDraw2.Point(p.x - this.start.x, p.y - this.start.y));
                    e.preventDefault();
                }
                else if (this.options.showhelmpopup) {
                    var p = this.eventPoint(e);
                    var obj = this.toggle(p);
                    this.onHelmSelectCurrent(e, obj);
                }
            }
            return;
        }
        this.holding.move(e);

        var cmd = this.getCmd();
        var p = this.eventPoint(e);

        if (cmd == "moveview") {
            if (this.start != null && e.button == 0) {
                this.moveview(new JSDraw2.Point(p.x - this.start.x, p.y - this.start.y));
                e.preventDefault();
            }
            return;
        }

        if (cmd == "inkblue" || cmd == "inkred" || cmd == "inkgreen") {
            if (this.ink != null)
                this.ink.add(p);
            return;
        }

        this.lastmove = p;
        var f = false;

        var obj = null;
        if (this.start == null || cmd != "select" && cmd != "lasso" && cmd != "selfrag") {
            obj = this.toggle(p);
            f = this.selectCurrent(obj, e);
        }

        if (this.start != null) {
            if (cmd == "arrow") {
                if (this.start != null) {
                    this.end = this.guessArrow(this.start, p);
                    f = true;
                }
            }
            else if (cmd == "zoombox" || cmd == "curve") {
                if (this.start != null) {
                    this.end = p;
                    f = true;
                }
            }
            else if (cmd == "rotate") {
                if (this.rotating != null) {
                    if (this.rotating.a1 == null) {
                        this.rotating.a0 = this.rotating.a1 = p.angleTo(this.rotating.center);
                    }
                    else {
                        var a2 = p.angleTo(this.rotating.center);
                        f = this.rotate(this.rotating.atoms, this.rotating.center, a2 - this.rotating.a1);
                        if (f)
                            f = "all";
                        this.rotating.a1 = a2;
                    }
                }
            }
            else if (cmd == "select" || cmd == "lasso" || cmd == "selfrag" || cmd == "tlc" || cmd == "electrophoresis") {
                if (this.start != null) {
                    if (this.lassolast) {
                        this.end = p;
                        this.lassoSelect(this.lassolast);
                        this.lassolast = p;
                    }
                    else if (this.resizing != null) {
                        if (!this.resizing.start.equalsTo(p)) {
                            var delta = p.clone().offset(-this.resizing.start.x, -this.resizing.start.y);
                            this.resizing.obj.resize(this.resizing.corner, delta, this.resizing.texts);
                            if (e.shiftKey && JSDraw2.Shape.cast(this.resizing.obj) != null)
                                this.resizing.obj._rect.height = this.resizing.obj._rect.width;
                            this.resizing.start = p;
                            this.resizing.changed = true;
                            f = "all";
                        }
                    }
                    else if (this.movingClone != null) {
                        if (this.end == null) {
                            this.end = this.start;
                            if (e.ctrlKey || e.metaKey) {
                                var m = this.m.clone(true);
                                m.showimplicithydrogens = this.options.showimplicithydrogens;
                                if (!m.isEmpty()) {
                                    this.m.setSelected();
                                    m.setSelected(true);
                                    m.calcHCount(true);
                                    this.m.mergeMol(m);
                                }
                            }
                        }

                        if (!this.end.equalsTo(p)) {
                            this.m.offset(p.x - this.end.x, p.y - this.end.y, true);
                            this.end = p;
                        }
                        f = "all";
                    }
                    else {
                        this.end = p;
                        f = true;
                    }
                }
            }
            else if (cmd == "rectangle" || cmd == "ellipse" || cmd == "diamond" || cmd == "dshape" || cmd == "dreversed") {
                if (e.shiftKey)
                    p.equalMove(this.start);
                this.end = p;
                f = true;
            }
            else if (cmd == "bracket" || cmd == "sgroup" || cmd == "assaycurve" || cmd == "spectrum" || cmd == "doublearrow" || cmd == "tlc" || cmd == "electrophoresis") {
                this.end = p;
                f = true;
            }
            else if (cmd == "chain") {
                this.end = p;
                f = this._makeChain(this.chaintool, p);
            }
            else if (cmd == "eraser") {
                if (this.erasercache != null && !this.erasercache.singleton) {
                    obj = this.toggle(p);
                    if (obj != null) {
                        this.delObject(obj);
                        ++this.erasercache.count;
                        f = "all";
                    }
                }
            }
            else if (scil.Utils.startswith(cmd, "spot-")) {
            }
            else {
                if (JSDraw2.Atom.cast(this.curObject) != null)
                    this.end = this.curObject.p.clone();
                else
                    this.end = this._guessBond(this.start, p);
                f = true;
            }
        }

        if (f != false && !(this.start != null && p.tm - this.start.tm < JSDraw2.Editor.undoGestureTime))
            this.redraw(f != "all");
    },

    mouseup: function (e, viewonly) {
        this.holding.end();

        if (!scil.Utils.isTouch && e.button == 2) {// right click
            if (!viewonly) {
                if (!this.activated)
                    this.activate(true);
            }

            if (this.touch.start1 == null) // Windows8 issue
                this.showContextMenu(e, viewonly);
            e.preventDefault();
            return;
        }

        if (!this.activated) {
            if (this.mousedownPoint != null && this.mousedownPoint.x == e.clientX && this.mousedownPoint.y == e.clientY)
                this.activate(true);
            if (viewonly && e.button == 0) {
                this.endMove(e, viewonly);
                e.preventDefault();
            }
            return;
        }

        var cmd = this.getCmd();

        if (cmd == "moveview") {
            this.endMove(e, viewonly);
            e.preventDefault();
            return;
        }

        if (cmd == "inkred" || cmd == "inkblue" || cmd == "inkgreen") {
            if (this.ink != null)
                this.ink.end();
            return;
        }

        if (this.start == null)
            return;
        this.div.style.cursor = "default";

        var p1 = this.start;
        var p2 = this.lastmove == null ? p1.clone() : this.lastmove;
        this.lastmove = null;
        this.start = null;

        // detect undo gesture
        var dx = Math.abs(p1.x - p2.x);
        if ((p2.tm - p1.tm < JSDraw2.Editor.undoGestureTime) && Math.abs(dx) > 2 * 10 && dx > 5 * Math.abs(p1.y - p2.y) && this.toggle(p1) == null && this.toggle(p2) == null) {
            if (p1.x > p2.x)
                this.undo();
            else
                this.redo();
            this.refresh(false);
            return;
        }

        var f = null;
        if (cmd == "text") {
            this.showTextEditor(this.curObject, new JSDraw2.Point(p2.x, p2.y));
            return;
        }

        if (cmd == "sgroup") {
            if (p1.equalsTo(p2)) {
                this.showTextEditor(this.curObject, new JSDraw2.Point(p2.x, p2.y));
            }
            else {
                var obj1 = p1.atom != null ? p1.atom : this.toggle(p1);
                var obj2 = this.toggle(p2);
                if (JSDraw2.Text.cast(obj1) != null) {
                    var cloned = this.clone();
                    if (obj1.attach(obj2))
                        this.pushundo(cloned);
                }
                this.refresh(true);
            }
            return;
        }

        if (cmd == "eraser") {
            if (this.erasercache != null) {
                if (this.erasercache.count > 0) {
                    this.pushundo(this.erasercache.cloned);
                    this.curObject = null;
                    if (this.helm != null)
                        this.helm.resetIDs();
                    this.refresh(true);
                }
                this.erasercache = null;
            }
            return;
        }

        if (cmd == "plus") {
            if (this.curObject == null) {
                this.pushundo();
                this.m.addGraphics(new JSDraw2.Plus(p2));
                this.refresh(true);
            }
            return;
        }

        if (cmd == "rxnmap") {
            this.doRxnMap(this.curObject);
            return;
        }

        var d = p1.distTo(p2);
        if (cmd == "arrow" || cmd == "curve") {
            if (this.arrowtool != null && this.arrowtool.from != null) {
                var from = JSDraw2.Shape.cast(this.arrowtool.from);
                var to = JSDraw2.Shape.cast(this.curObject);
                var connector = this.arrowtool.connector;
                this.arrowtool = null;
                if (from != null && from != to) {
                    if (connector == "rejector") {
                        if (from.reject != from) {
                            this.pushundo();
                            if (from.reject == to)
                                from.reject = null;
                            else
                                from.reject = to;
                            this.refresh(true);
                            return;
                        }
                    }
                    else {
                        this.pushundo();
                        if (to == null) {
                            var rect = from.rect();
                            var dx = 0;
                            var dy = 0;
                            var pp2 = p2.clone();
                            if (p2.x < p1.x)
                                pp2.x -= rect.width;
                            if (p2.y < p1.y)
                                pp2.y -= rect.height;
                            to = this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect(pp2.x, pp2.y, rect.width, rect.height), "rectangle"));
                        }

                        if (to != null) {
                            this.pushundo();
                            if (this.isShapeConnected(from, to)) {
                                scil.Utils.delFromArray(to.froms, from);
                            }
                            else {
                                if (this.isShapeConnected(to, from))
                                    scil.Utils.delFromArray(from.froms, to);

                                if (Math.abs(p1.y - p2.y) < this.tor) {
                                    if (this.isIsolatedShape(to)) {
                                        var dy = from._rect.center().y - to._rect.center().y;
                                        to._rect.offset(0, dy);
                                    }
                                    else if (this.isIsolatedShape(from)) {
                                        var dy = to._rect.center().y - from._rect.center().y;
                                        from._rect.offset(0, dy);
                                    }
                                }
                                else if (Math.abs(p1.x - p2.x) < this.tor) {
                                    if (this.isIsolatedShape(to)) {
                                        var dx = from._rect.center().x - to._rect.center().x;
                                        to._rect.offset(dx, 0);
                                    }
                                    else if (this.isIsolatedShape(from)) {
                                        var dx = to._rect.center().x - from._rect.center().x;
                                        from._rect.offset(dx, 0);
                                    }
                                }

                                to.froms.push(from);
                            }

                            this.refresh(true);
                            return;
                        }
                    }
                    this.refresh();
                    return;
                }
            }

            this.pushundo();
            if (d >= this.bondlength)
                p2 = this.guessArrow(p1, p2);
            else
                p2 = p1.clone().offset(3 * this.bondlength, 0);

            if (cmd == "arrow")
                this.m.addGraphics(new JSDraw2.Arrow(p1, p2));
            else
                this.m.addGraphics(new JSDraw2.Curve(p1, p2));
            this.refresh(true);
            return;
        }
        if (cmd == "rectangle" || cmd == "ellipse" || cmd == "doublearrow" || cmd == "diamond" || cmd == "dshape" || cmd == "dreversed") {
            if (d < this.bondlength / 8)
                p2 = new JSDraw2.Point(p1.x + this.bondlength, p1.y + this.bondlength);
            else if (d < this.bondlength / 2)
                return;

            this.pushundo();
            if (cmd == "rectangle")
                this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect().set(p1, p2), "rectangle"));
            else if (cmd == "ellipse")
                this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect().set(p1, p2), "ellipse"));
            else if (cmd == "diamond")
                this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect().set(p1, p2), "diamond"));
            else if (cmd == "dshape")
                this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect().set(p1, p2), "dshape"));
            else if (cmd == "dreversed")
                this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect().set(p1, p2), "dreversed"));
            else if (cmd == "doublearrow")
                this.m.addGraphics(new JSDraw2.Shape(new JSDraw2.Rect().set(p1, p2), "doublearrow"));
            this.refresh(true);
            return;
        }
        if (cmd == "assaycurve") {
            if (d < this.bondlength / 8 && this.m.isEmpty())
                p2 = new JSDraw2.Point(p1.x + this.bondlength * 8, p1.y + this.bondlength * 6);
            else if (Math.abs(p1.x - p2.x) < this.bondlength * 2 || Math.abs(p1.y - p2.y) < this.bondlength * 2)
                return;

            this.pushundo();
            this.m.addGraphics(new JSDraw2.AssayCurve(new JSDraw2.Rect().set(p1, p2)));
            this.refresh(true);
            return;
        }
        if (cmd == "spectrum") {
            if (d < this.bondlength / 8 && this.m.isEmpty())
                p2 = new JSDraw2.Point(p1.x + this.bondlength * 14, p1.y + this.bondlength * 6);
            else if (Math.abs(p1.x - p2.x) < this.bondlength * 2 || Math.abs(p1.y - p2.y) < this.bondlength * 2)
                return;

            this.pushundo();
            this.m.addGraphics(new JSDraw2.Spectrum(new JSDraw2.Rect().set(p1, p2)));
            this.refresh(true);
            return;
        }
        if (cmd == "tlc" || cmd == "electrophoresis") {
            var modified = false;
            if (this.movingClone == null) {
                if (d < this.bondlength / 2)
                    return;

                this.pushundo();
                var tlc = new JSDraw2.TLC.create(cmd, p1, p2, this.fontsize / 2);
                if (tlc.rect().height > 2 * this.bondlength && tlc.spots.length > 0) {
                    this.addTlcPlate(tlc);
                    modified = true;
                }
                this.refresh(modified);
                return;
            }
        }
        if (scil.Utils.startswith(cmd, "spot-")) {
            var tlc = JSDraw2.TLC.cast(this.curObject);
            var clone = this.clone();
            if (tlc != null && tlc.addSpot(cmd.substr(5), p2, this.tor)) {
                this.pushundo(clone);
                this.refresh(true);
            }
            return;
        }

        if (cmd == "rotate" && this.rotating != null) {
            if (this.rotating.a1 != this.rotating.a0) {
                this.pushundo(this.rotating.cloned);
                this.refresh(true);
            }
            this.rotating = null;
            return;
        }

        if (cmd == "select" || cmd == "lasso" || cmd == "selfrag" || cmd == "rotate" || cmd == "tlc" || cmd == "electrophoresis") {
            if (this.lassolast != null) {
                this.lassolast = null;
            }
            else if (this.resizing != null) {
                if (this.resizing.changed) {
                    this._bracketReselectAtoms();
                    this.pushundo(this.movingClone);
                    this.movingClone = null;
                    this.resizing = null;
                    f = true;
                }
            }
            else if (this.movingClone != null) {
                if (!this.movingClone.startPt.equalsTo(p2)) {
                    this._bracketReselectAtoms();
                    this.pushundo(this.movingClone);
                    this.mergeOverlaps();
                    this.movingClone = null;
                    f = true;
                }
            }
            else {
                if (d < this.bondlength) {
                    if (this.curObject != null)
                        this.curObject.selected = true;
                }
                else {
                    this.selectInRect(new JSDraw2.Rect().set(p1, p2));
                }
            }
            this.refresh(f);

            if (this.options.onselectionchanged != null)
                this.options.onselectionchanged(this);
            return;
        }

        if (cmd == "zoombox") {
            var rect = new JSDraw2.Rect().set(p1, p2);
            if (rect.width > 10 && rect.height > 10) {
                var s = Math.min(this.dimension.x / rect.width, this.dimension.y / rect.height);
                var c = rect.center();
                this.pushundo();
                this.scale(s * 0.9, c);
                this.m.offset(this.dimension.x / 2 - c.x, this.dimension.y / 2 - c.y);
            }
            else if (rect.width < 5 && rect.height < 5) {
                this.fitToWindow();
            }
            this.redraw();
            return;
        }

        if (cmd == "chain") {
            if (this.chaintool != null && this.chaintool.points.length > 0) {
                f = false;
                var cloned = this.clone();
                var pts = this.chaintool.points;
                var m = null;
                for (var i = 1; i < pts.length; ++i) {
                    var a1 = this.toggleAtom(pts[i - 1]);
                    var a2 = this.toggleAtom(pts[i]);
                    if (m == null) {
                        if (a1 != null)
                            m = a1._parent;
                        else if (a2 != null)
                            m = a2._parent;
                        else
                            m = this.m;
                    }
                    if (a1 != null && a1._parent != m)
                        a1 = null;
                    if (a2 != null && a2._parent != m)
                        a2 = null;

                    if (a1 == null) {
                        a1 = new JSDraw2.Atom(pts[i - 1]);
                        m.addAtom(a1);
                        this._addNewAtomInExistingGroup(a2, [a1]);
                        f = true;
                    }
                    if (a2 == null) {
                        a2 = new JSDraw2.Atom(pts[i]);
                        m.addAtom(a2);
                        this._addNewAtomInExistingGroup(a1, [a2]);
                        f = true;
                    }

                    if (m.findBond(a1, a2) == null) {
                        m.addBond(new JSDraw2.Bond(a1, a2), null, true);
                        f = true;
                    }
                }
                this.chaintool = null;
                if (f)
                    this.pushundo(cloned);
                this.refresh(f);
                return;
            }
        }

        if (cmd == "bracket") {
            this.m.setSelected(false);
            var r = new JSDraw2.Rect().set(p1, p2);
            var list = this.m.bracketSelect(r);
            if (list.length > 0) {
                this.pushundo();
                var br = new JSDraw2.Bracket(null, r);
                br.atoms = list;
                list[0]._parent.addGraphics(br);
                f = true;
            }
            this.refresh(f);

            if (br != null) {
                var t = br.createSubscript(this.m, "#");
                if (t != null)
                    this.showTextEditor(t, null, "");
            }
            else {
                var t = JSDraw2.Text.cast(this.curObject);
                if (t != null && t.fieldtype == "BRACKET_TYPE" && t.anchors.length == 1 && JSDraw2.Bracket.cast(t.anchors[0]) != null)
                    this.showTextEditor(t, null, t.text);
            }
            return;
        }

        // atom properties
        if (cmd == "&#9679;") {
            var a;
            if ((a = JSDraw2.Atom.cast(this.curObject)) != null)
                this.showAtomDlg(a);
            else if ((a = JSDraw2.Bond.cast(this.curObject)) != null)
                this.showBondDlg(a);
            return;
        }

        if (cmd == "undo" || cmd == "redo" || cmd == "zoomin" || cmd == "zoomout")
            return;

        var cloned = this.clone();
        if (d <= this.tor) {
            // no mouse drag, this is just a click event
            if (scil.Utils.startswith(cmd, "template.")) {
                this.pushundo(cloned);
                this.addTemplate(cmd.substr(9), this.curObject, p2);
                this.refresh(true);
                return;
            }

            var a;
            if ((a = JSDraw2.Atom.cast(this.curObject)) != null) {
                var e = JSDraw2.PT[cmd];
                if (cmd == "antibody" || cmd == "protein" || cmd == "gene")
                    f = this.m.setAtomType(a, cmd);
                else if (e != null)
                    f = this.m.setAtomType(a, cmd);
                else if (cmd == "..." || cmd == "more")
                    f = this.m.setAtomType(a, this.ptElement);
                else if (cmd == "chargep" || cmd == "chargen")
                    f = this.increaseNum(a, cmd == "chargep" ? +1 : -1);
                else if (this.helm != null && this.helm != null && this.helm.isHelmCmd(cmd)) {
                    if (scil.helm.isHelmNode(a))
                        this.helm.changeMonomer(a, cloned);
                }
                else {
                    if (this.helm != null && scil.helm.isHelmNode(a))
                        this.helm.changeMonomer(a, cloned);
                    else
                        f = this._addAutoBond(a, cmd);
                }
            }

            var b;
            if ((b = JSDraw2.Bond.cast(this.curObject)) != null) {
                switch (cmd) {
                    case "double":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.DOUBLE);
                        break;
                    case "triple":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.TRIPLE);
                        break;
                    case "unknown":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.UNKNOWN);
                        break;
                    case "dummy":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.DUMMY);
                        break;
                    case "either":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.EITHER);
                        break;
                    case "wiggly":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.WIGGLY);
                        break;
                    case "bold":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.BOLD);
                        break;
                    case "boldhash":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.BOLDHASH);
                        break;
                    case "delocalized":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.DELOCALIZED);
                        break;
                    case "singledouble":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.SINGLEORDOUBLE);
                        break;
                    case "singlearomatic":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.SINGLEORAROMATIC);
                        break;
                    case "doublearomatic":
                        f = this.m.setBondType(b, JSDraw2.BONDTYPES.DOUBLEORAROMATIC);
                        break;
                    case "up":
                        if (b.type == JSDraw2.BONDTYPES.WEDGE) {
                            b.reverse();
                            f = true;
                        }
                        else {
                            f = this.m.setBondType(b, JSDraw2.BONDTYPES.WEDGE);
                            this.fixWedgeDir(b);
                        }
                        break;
                    case "down":
                        if (b.type == JSDraw2.BONDTYPES.HASH) {
                            b.reverse();
                            f = true;
                        }
                        else {
                            f = this.m.setBondType(b, JSDraw2.BONDTYPES.HASH);
                            this.fixWedgeDir(b);
                        }
                        break;
                    default:
                        f = this.m.setBondType(b, b.type == JSDraw2.BONDTYPES.SINGLE ? JSDraw2.BONDTYPES.DOUBLE : JSDraw2.BONDTYPES.SINGLE);
                        break;
                }
            }

            if (!f && this.curObject == null) {
                if (this.options.toolbarmode == "helm" && !this.helm.isHelmCmd(cmd))
                    return;

                var bondtype = this.Cmd2BondType(cmd);
                if (bondtype != null) {
                    var a1 = this.m.addAtom(new JSDraw2.Atom(p2));
                    var p = p2.clone().offset(this.bondlength, 0).rotateAround(p2, -30);
                    var a2 = JSDraw2.Atom.cast(this.toggle(p));
                    if (a2 == null)
                        a2 = this.m.addAtom(new JSDraw2.Atom(p));
                    this.m.addBond(new JSDraw2.Bond(a1, a2));
                    f = true;
                }
            }

            // draw isolated atom
            if (!f && this.curObject == null) {
                var s = cmd == "more" || cmd == "..." ? this.ptElement : cmd;
                var e = JSDraw2.PT[s];
                if (e != null && e.a > 0 || cmd == "antibody" || cmd == "protein" || cmd == "gene" || this.helm != null && this.helm.isHelmCmd(cmd)) {
                    var a = this.m.addAtom(new JSDraw2.Atom(p2));
                    if (cmd == "antibody") {
                        a.bio = { type: JSDraw2.BIO.ANTIBODY };
                        a.elem = "X";
                    }
                    else if (cmd == "protein") {
                        a.bio = { type: JSDraw2.BIO.PROTEIN };
                        a.elem = "X";
                    }
                    else if (cmd == "gene") {
                        a.bio = { type: JSDraw2.BIO.GENE };
                        a.elem = "X";
                    }
                    else if (this.helm != null && this.helm.createIsolatedMonomer(cmd, a)) {
                        ;
                    }
                    else {
                        this.m.setAtomType(a, s);
                    }
                    f = true;
                }
            }

            if (f) {
                this.pushundo(cloned);
                this.refresh(f);
            }
            return;
        }

        var a1 = JSDraw2.Atom.cast(p1.atom != null ? p1.atom : this.toggle(p1));
        var a2 = JSDraw2.Atom.cast(this.toggle(p2));
        if (a1 != null && a2 != null) {
            if (a1._parent != a2._parent) {
                scil.Utils.alert("Cannot create bond between the two atoms");
                return;
            }
        }

        if (this.options.toolbarmode == "helm" || this.helm.isHelmCmd(cmd)) {
            if (this.helm.connnectGroup(p1, this.curObject)) {
                this.pushundo(cloned);
                this.redraw();
                return;
            }

            if ((a1 == null || a2 == null) && this.helm != null && !this.helm.isHelmCmd(cmd)) {
                if (cmd == "single") {
                    if (this.helm.connnectGroup(p1, this.curObject))
                        this.pushundo(cloned);
                }
                this.redraw();
                return;
            }

            if (this.helm != null && this.helm.isHelmCmd(cmd)) {
                if (a1 != null && a2 == null) {
                    this.helm.extendChain(a1, cmd, p1, p2, cloned);
                    return;
                }
                else if (a1 == null && a2 == null) {
                    this.redraw();
                    return;
                }
            }
        }

        var m = a1 != null ? a1._parent : (a2 != null ? a2._parent : this.m);
        this.pushundo(cloned);
        var c1 = this._countAABonds(a1);
        var ao1 = a1;
        if (a1 == null) {
            if (c1 != null) {
                // add H or OH on peptide terminal Amino Acid
                if (c1.peptideN == 0 && c1.others == 0)
                    a1 = m.addAtom(new JSDraw2.Atom(p1, "H"));
                else if (c1.peptideC == 0 && c1.others == 0)
                    a1 = m.addAtom(new JSDraw2.Atom(p1, "O"));
            }
            else {
                a1 = m.addAtom(new JSDraw2.Atom(p1));
            }
        }

        var c2 = this._countAABonds(a2);
        var ao2 = a2;
        if (a2 == null) {
            p2 = this._guessBond(p1, p2);
            if (c1 != null) {
                // add H or OH on peptide terminal Amino Acid
                if (c1.peptideN == 0 && c1.others == 0)
                    a2 = m.addAtom(new JSDraw2.Atom(p2, "H"));
                else if (c1.peptideC == 0 && c1.others == 0)
                    a2 = m.addAtom(new JSDraw2.Atom(p2, "O"));
            }
            else {
                a2 = m.addAtom(new JSDraw2.Atom(p2));
            }
        }

        if (a1 != null && a2 != null) {
            this._addNewAtomInExistingGroup(ao1, [a2]);
            this._addNewAtomInExistingGroup(ao2, [a1]);

            var b = this.m.findBond(a1, a2);
            if (b == null) {
                if (ao1 != null && ao2 != null && ao1._parent != ao2._parent) {
                    scil.Utils.alert("Cannot create bond between the two atoms");
                }
                else if (this.helm != null && (scil.helm.isHelmNode(a1) || scil.helm.isHelmNode(a2))) {
                    this.helm.connectFragment(a1, a2, !scil.helm.isHelmNode(a1) || !scil.helm.isHelmNode(a2));
                }
                else {
                    var bondtype = this.Cmd2BondType(cmd);
                    if (bondtype == null)
                        bondtype == JSDraw2.BONDTYPES.SINGLE;
                    if (c1 != null && c2 != null) {
                        // connect two amino acids
                        if (c1.peptideN == 0 && c2.peptideC == 0)
                            b = new JSDraw2.Bond(a1, a2, JSDraw2.BONDTYPES.PEPTIDE); // peptide bond
                        else if (c2.peptideN == 0 && c1.peptideC == 0)
                            b = new JSDraw2.Bond(a2, a1, JSDraw2.BONDTYPES.PEPTIDE); // reversed peptide bond
                        else if (ao1.elem == "C" && ao2.elem == "C" && c1.disulfide == 0 && c2.disulfide == 0)
                            b = new JSDraw2.Bond(a1, a2, JSDraw2.BONDTYPES.DISULFIDE);
                        else if (ao1.elem == "K" && c1.amide == 0 && c2.peptideC == 0)
                            b = new JSDraw2.Bond(a1, a2, JSDraw2.BONDTYPES.AMIDE); // amide bond to K
                        else if (ao2.elem == "K" && c2.amide == 0 && c1.peptideC == 0)
                            b = new JSDraw2.Bond(a2, a1, JSDraw2.BONDTYPES.AMIDE); // reversed amide bond to K
                    }
                    else if (c1 != null) {
                        // connect one amino acid to structure
                        if (c1.peptideN + c1.peptideC + c1.others < 2)
                            b = new JSDraw2.Bond(a1, a2, a2.elem == "H" ? JSDraw2.BONDTYPES.PEPTIDE : JSDraw2.BONDTYPES.SINGLE);
                        else if (ao1.elem == "C" && c1.disulfide == 0)
                            b = new JSDraw2.Bond(a1, a2, JSDraw2.BONDTYPES.DISULFIDE); // using sulfide bond to C
                        else if (ao1.elem == "K" && c1.amide == 0)
                            b = new JSDraw2.Bond(a1, a2, JSDraw2.BONDTYPES.AMIDE); // using amide bond to K
                    }
                    else if (c2 != null) {
                        // connect one amino acid to structure
                        if (c2.peptideN + c2.peptideC + c2.others < 2)
                            b = new JSDraw2.Bond(a2, a1, a1.elem == "H" ? JSDraw2.BONDTYPES.PEPTIDE : JSDraw2.BONDTYPES.SINGLE);
                        else if (ao2.elem == "C" && c2.disulfide == 0)
                            b = new JSDraw2.Bond(a2, a1, JSDraw2.BONDTYPES.DISULFIDE); // using sulfide bond to C
                        else if (ao2.elem == "K" && c2.amide == 0)
                            b = new JSDraw2.Bond(a2, a1, JSDraw2.BONDTYPES.AMIDE); // using amide bond to K
                    }
                    else {
                        b = new JSDraw2.Bond(a1, a2, bondtype);
                    }
                }

                if (b != null)
                    m.addBond(b, bondtype != JSDraw2.BONDTYPES.DUMMY, true);
            }
        }

        this.start = null;
        this.refresh(b != null);
    },

    _bracketReselectAtoms: function () {
        var br = JSDraw2.Bracket.cast(this.curObject);
        if (br == null)
            return;

        var list = this.m.bracketSelect(br.rect());
        if (list != null && list.length > 0)
            br.atoms = list;
    },

    _addNewAtomInExistingGroup: function (olda, atoms) {
        if (olda == null)
            return;

        for (var k = 0; k < atoms.length; ++k) {
            var a = atoms[k];
            if (a == null)
                continue;

            // attach to existing groups
            if (olda.group != null && a.group == null)
                a.group = olda.group;

            // attach to existing brackets
            for (var i = 0; i < this.m.graphics.length; ++i) {
                var br = JSDraw2.Bracket.cast(this.m.graphics[i]);
                if (br == null || br.atoms == null)
                    continue;

                if (scil.Utils.indexOf(br.atoms, olda) >= 0 && scil.Utils.indexOf(br.atoms, a) < 0)
                    br.atoms.push(a);
            }
        }
    },

    mousedblclick: function (e) {
        if (this.options.viewonly)
            return;

        var p = this.eventPoint(e);
        var obj = this.toggle(p);
        if (obj == null)
            return;

        var a = JSDraw2.Atom.cast(obj);
        if (a == null) {
            var b = JSDraw2.Bond.cast(obj);
            if (b != null)
                a = b.a1;
        }

        if (a == null)
            return;

        this.m.setSelected(false);
        var m = a._parent.getFragment(a, a._parent);
        for (var i = 0; i < m.atoms.length; ++i)
            m.atoms[i].selected = true;
        for (var i = 0; i < m.bonds.length; ++i)
            m.bonds[i].selected = true;

        this.refresh(false);
    },

    endMove: function (e, viewonly) {
        if (this.start == null)
            return;

        var p = this.eventPoint(e);
        var d = new JSDraw2.Point(p.x - this.start.x, p.y - this.start.y);
        this.start = null;
        this.moveview(null);

        if (d.x != 0 || d.y != 0) {
            if (!viewonly)
                this.pushundo();
            this.m.offset(d.x, d.y);
            if (viewonly)
                this.redraw();
            else
                this.refresh(true);
        }
    },

    isIsolatedShape: function (n) {
        if (n.froms.length > 0)
            return false;

        for (var i = 0; i < this.m.graphics.length; ++i) {
            var s = JSDraw2.Shape.cast(this.m.graphics[i]);
            if (s != null && scil.Utils.indexOf(s.froms, n) >= 0)
                return false;
        }

        return true;
    },

    isShapeConnected: function (from, to) {
        if (from == null || to == null)
            return false;

        for (var i = 0; i < to.froms.length; ++i) {
            if (to.froms[i] == from)
                return true;
        }
        return false;
    },

    _countAABonds: function (a) {
        if (a == null || a.biotype() != JSDraw2.BIO.AA)
            return null;

        var ret = { peptideN: 0, peptideC: 0, disulfide: 0, amide: 0, others: 0 };
        var list1 = this.m.getAllBonds(a);
        for (var i = 0; i < list1.length; ++i) {
            if (list1[i].type == JSDraw2.BONDTYPES.PEPTIDE) {
                if (list1[i].a1 == a)
                    ++ret.peptideN;
                else
                    ++ret.peptideC;
            }
            else if (list1[i].type == JSDraw2.BONDTYPES.DISULFIDE) {
                ++ret.disulfide;
            }
            else if (list1[i].type == JSDraw2.BONDTYPES.AMIDE) {
                ++ret.amide;
            }
            else if (list1[i].type == JSDraw2.BONDTYPES.SINGLE) {
                var oa = list1[i].otherAtom(a);
                if (oa.bio == null)
                    ++ret.others;
            }
        }
        return ret;
    },

    addTlcPlate: function (tlc) {
        if (tlc == null || !(tlc.spots.length > 0))
            return;

        var tlcsetting = null;
        if (JSDraw2.defaultoptions != null && JSDraw2.defaultoptions.tlc != null && tlc.type != "electrophoresis") {
            tlcsetting = JSDraw2.defaultoptions.tlc;
            var scale = tlc.spotsize / (JSDraw2.Editor.FONTSIZE / 2);
            if (tlcsetting.width > 0)
                tlc._rect.width = tlcsetting.width * scale;
            if (tlcsetting.height > 0)
                tlc._rect.height = tlcsetting.height * scale;

            var list = this.getAllTlcPlates(true);
            if (list != null && list.length > 0) {
                var prev = list[list.length - 1];
                var gap = tlcsetting.gap > 0 ? tlcsetting.gap : tlcsetting.width / 5;
                tlc._rect.left = prev._rect.right() + gap;
                tlc._rect.top = prev._rect.top
            }
        }
        this.m.addGraphics(tlc);
        if (tlcsetting != null && tlcsetting.autonumbering)
            this.numberTlcPlates();

        if (this.options.onAddTLC != null)
            this.options.onAddTLC(tlc);

        this.moveCenter();
    },

    hideChirarlities: function (selectonly) {
        var texts = [];
        for (var i = 0; i < this.m.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(this.m.graphics[i]);
            if (t != null && t.anchors != null && t.anchors.length == 1 && t.fieldtype == "CHIRAL") {
                var a = JSDraw2.Atom.cast(t.anchors[0]);
                if (!selectonly || a.selected)
                    texts.push(t);
            }
        }

        if (texts.length > 0) {
            for (var i = 0; i < texts.length; ++i)
                this.m.delGraphics(texts[i]);
            this.pushundo();
            this.refresh(true);
        }
    },

    detectChiralities: function (selectonly) {
        var me = this;
        JSDraw2.JSDrawIO.callWebservice("mol.getchiralatoms", { mol: this.getXml(), format: "xml" }, function (ret) {
            var n = 0;
            var cloned = me.clone();
            for (var k in ret) {
                var id = parseInt(k);
                var a = me.m.getObjectById(id);
                if ((!selectonly || a.selected) && me.m.markChirality(a, ret[k], me.bondlength))
                    ++n;
            }
            if (n > 0) {
                me.pushundo(cloned);
                me.refresh(true);
            }
        });
    },

    increaseNum: function (a, delta) {
        if (delta != 1 && delta != -1)
            return false;
        var f = false;
        if (a.elem == "R") {
            var r = scil.Utils.parseIndex(a.alias);
            if (r == null || r.index == null) {
                f = a._parent.setAtomAlias(a, (r == null || r.prefix == null ? "R" : r.prefix) + "1");
            }
            else {
                if (delta > 0) {
                    f = a._parent.setAtomAlias(a, r.prefix + (r.index + 1));
                }
                else {
                    if (r.index > 1)
                        f = a._parent.setAtomAlias(a, r.prefix + (r.index - 1));
                }
            }
        }
        else {
            f = a._parent.setAtomCharge(a, a.charge + delta);
        }
        return f;
    },

    mergeOverlaps: function () {
        var overlaps = [];
        for (var i = 0; i < this.m.atoms.length; ++i) {
            if (this.m.atoms[i].selected) {
                var a1 = this.m.atoms[i];
                for (var k = 0; k < this.m.atoms.length; ++k) {
                    var a2 = this.m.atoms[k];
                    if (!a2.selected && a2.toggle(a1.p, this.tor)) {
                        overlaps.push({ a1: a1, a2: a2 });
                        break;
                    }
                }
            }
        }

        var bonds = [];
        for (var k = 0; k < overlaps.length; ++k) {
            var a1 = overlaps[k].a1;
            var a2 = overlaps[k].a2;
            var b = this.m.findBond(a1, a2);
            if (b != null) {
                bonds.push(b);
                continue;
            }

            for (var i = 0; i < this.m.bonds.length; ++i) {
                b = this.m.bonds[i];
                if (b.a1 == a1) {
                    if (b.a2 != a2) {
                        var t = this.m.findBond(b.a2, a2);
                        b.a1 = a2;
                        if (t != null)
                            bonds.push(b);
                    }
                }
                else if (b.a2 == a1) {
                    if (b.a1 != a2) {
                        var t = this.m.findBond(b.a1, a2);
                        b.a2 = a2;
                        if (t != null)
                            bonds.push(b);
                    }
                }
            }
        }

        for (var i = 0; i < bonds.length; ++i)
            this.m.delBond(bonds[i], false);
        for (var i = 0; i < overlaps.length; ++i)
            this.m.delAtom(overlaps[i].a1, false);

        return bonds.length + overlaps.length;
    },

    onDel: function () {
        if (this.texteditor.ed != null && this.texteditor.ed.input.style.display != "none")
            return false;

        var cloned = this.clone();
        if (this.delObject(this.curObject) || this.delSelected() > 0) {
            this.pushundo(cloned);
            if (this.helm != null)
                this.helm.resetIDs();
            this.curObject = null;
            this.refresh(true);
            return true;
        }

        return false;
    },

    showContextMenu: function (e, viewonly) {
        if (this.options.showcontextmenu == false)
            return;

        var items = org.helm.webeditor.Interface.onContextMenu(this, e, viewonly);
        if (items == null || items.length == 0)
            return;

        var me = this;
        if (this.contextmenu == null)
            this.contextmenu = new JSDraw2.ContextMenu(items, function (cmd, obj) { me.menuCallback(cmd, obj); });
        var scrolloffset = scil.Utils.scrollOffset();
        this.contextmenu.show(e.clientX + scrolloffset.x, e.clientY + scrolloffset.y, this.curObject, items);
        this.contextmenu.pos = this.eventPoint(e);
    },

    menuSetStereochemistry: function (cmd) {
        if (cmd == "abs")
            cmd = null;

        this.pushundo();
        if (this.m.chiral == cmd)
            this.m.chiral = null;
        else
            this.m.chiral = cmd;
        this.refresh(true);
    },

    menuCallback: function (cmd, obj) {
        var modified = false;
        var cloned = this.clone();
        switch (cmd) {
            //            case "Chiral":                                                                                                                           
            //                this.pushundo();                                                                                                                           
            //                this.m.chiral = !this.m.chiral;                                                                                                                           
            //                this.refresh(true);                                                                                                                           
            //                break;                                                                                                                           
            case "curveline":
                obj.setIC50CurveLine(this);
                break;
            case "icxline":
                obj.setICxCurveLine(this);
                break;
            case "curveonly":
                obj.setAssayCurveOnly(this);
                break;
            case "overlaycurves":
                this.overlayCurves2(obj);
                break;
            case "setrawassaydata":
                obj.setAssayCurveRawData(this);
                break;
            case "spectrum_setdata":
                obj.setSpectrumData(this);
                break;
            case "spectrum_setdatafromfile":
                obj.setSpectrumDataFromFile(this);
                break;
            case "spectrum_attributes":
                obj.viewAttributes(this);
                break;
            case "maskassaysamplepoint":
                modified = obj.maskSamplePoint(obj.curspot);
                break;
            case "pastechemdraw":
                JSDraw2.ChemDraw.paste(this);
                break;
            case "pastechemdrawasproduct":
                JSDraw2.ChemDraw.paste(this, "product");
                break;
            case "pastechemdrawasreactant":
                JSDraw2.ChemDraw.paste(this, "reactant");
                break;
            case "copychemdraw":
                JSDraw2.ChemDraw.copy(this);
                break;
            case "copymolfile":
                this.copyAs("molfile");
                break;
            case "copymolfile2000":
                this.copyAs("molfile2000");
                break;
            case "copymolfile3000":
                this.copyAs("molfile3000");
                break;
            case "copysmiles":
                this.copyAs("smiles");
                break;
            case "pastemolfile":
                this.pasteAs("molfile");
                break;
            case "about":
                JSDraw2.Editor.showAbout();
                break;
            case "abouthelm":
                scil.helm.about();
                break;
            case "removeatomvalues":
                this.removeAtomValues();
                break;
            case "viewlarge":
                this.viewLarge();
                break;
            case "movecenter":
                this.moveCenter();
                this.redraw();
                break;
            case "atom_prop":
                if ((a = JSDraw2.Atom.cast(obj)) != null)
                    this.showAtomDlg(a);
                break;
            case "atom_tag":
                var s = obj.bio == null ? "Atom " + obj.elem : obj.bio.type;
                if (obj.bio != null && obj.bio.subtype != null)
                    s += " " + obj.bio.subtype;
                this.addTag(obj, obj.p, s, true);
                break;
            case "helm_set_sense":
                if (obj.bio.annotation != "5'ss") {
                    obj.bio.annotation = "5'ss";
                    modified = true;
                }
                break;
            case "helm_set_antisense":
                if (obj.bio.annotation != "5'as") {
                    obj.bio.annotation = "5'as";
                    modified = true;
                }
                break;
            case "helm_set_clear":
                if (obj.bio.annotation != "5'") {
                    obj.bio.annotation = "5'";
                    modified = true;
                }
                break;
            case "helm_complementary_strand":
                if (scil.Utils.startswith(obj.bio.annotation, "5'"))
                    modified = this.helm.makeComplementaryStrand(obj) != null;
                break;
            case "helm_create_group":
                modified = this.helm.createGroup(obj, null, true) != null;
                break;
            case "helm_group_collapse":
                modified = this.helm.collapseGroup(obj, true) != null;
                break;
            case "helm_bond_prop":
                this.helm.setBondProp(obj);
                break;
            case "helm_atom_prop":
                this.helm.setAtomProp(obj);
                break;
            case "group_setproperties":
                this.setGroupProperties(obj);
                break;
            case "detectstereochemistry":
                this.detectChiralities(true);
                break;
            case "hidestereochemistry":
                this.hideChirarlities(true);
                break;
            case "detectstereochemistry2":
                this.detectChiralities();
                break;
            case "hidestereochemistry2":
                this.hideChirarlities();
                break;
            case "bond_prop":
                if ((a = JSDraw2.Bond.cast(obj)) != null)
                    this.showBondDlg(a);
                break;
            case "bond_tag":
                this.addTag(obj, obj.center(), "[None]", true);
                break;
            case "bond_locant":
                this.addTag(obj, obj.center(), "U = Unknown Locant");
                break;
            case "bio_showsequence":
                this.showSequences(obj);
                break;
            case "rgroup_define":
                modified = this.rgroupDefine(obj);
                break;
            case "rgroup_remove":
                var a = JSDraw2.Atom.cast(obj);
                if (a != null && a.rgroup != null) {
                    a.rgroup = null;
                    modified = true;
                }
                break;
            case "rgroup_addstructure":
                this.addRgroupStructure(obj);
                modified = true;
                break;
            case "setbracketsubscription":
                this.setBracketSubscription(obj);
                break;
            case "setbracketratio":
                this.setBracketRatio(obj);
                break;
            case "setbracketmw":
                this.setBracketData(obj, "POLYMER_MW", "MW=", 1);
                break;
            case "registrationparent":
                this.setBracketData(obj, "REG_PARENT", "Parent=", 2);
                break;
            case "graphics_bring2front":
                modified = this.m.setZOrder(obj, -1);
                break;
            case "graphics_set2back":
                modified = this.m.setZOrder(obj, 0);
                break;
            case "tlc_addlane":
                modified = JSDraw2.TLC.cast(obj) != null && obj.addLane();
                break;
            case "tlc_duplicatespot":
                modified = JSDraw2.TLC.cast(obj) != null && obj.duplicateSpot(obj.curspot);
                break;
            case "tlc_duplicatelane":
                modified = JSDraw2.TLC.cast(obj) != null && obj.duplicateLane(obj.curspot);
                break;
            case "tlc_showlanelabel":
                modified = JSDraw2.TLC.cast(obj) != null && obj.showLaneLabel(!obj.showlanelabel);
                break;
            case "tlc_removespot":
                modified = JSDraw2.TLC.cast(obj) != null && obj.removeSpot(obj.curspot);
                break;
            case "tlc_setrfvalue":
                modified = JSDraw2.TLC.cast(obj) != null && obj.setRfValue(obj.curspot, this);
                break;
            case "tlc_setlanelabels":
                JSDraw2.TLC.setLaneLabels(this, obj);
                break;
            case "Copy":
                this.copy();
                break;
            case "Select All":
                if (this.selectAll())
                    this.refresh(false);
                break;
            case "copy-viewonly":
                this.copy(cloned == null ? null : cloned.mol);
                break;
            case "Cut":
                if (this.cut())
                    this.refresh(false);
                break;
            case "edit-popup":
                if (this.options.popup)
                    this.dblclick();
                break;
            case "Expand":
                this.expandSuperatom();
                break;
            case "Paste":
                if (this.paste(this.contextmenu.pos))
                    this.refresh(false);
                break;
            case "Delete":
                modified = this.delSelected() > 0;
                break;
            case "multi-center":
                modified = this.createMulticenter() != null;
                break;
            case "Clear":
                this.clear(false, true);
                modified = true;
                break;
            case "Undo":
                if (this.undo())
                    this.refresh(false);
                break;
            case "Redo":
                if (this.redo())
                    this.refresh(false);
                break;
            case "workflow_properties":
                JSDraw2.Shape.showProperties(this, JSDraw2.Shape.cast(obj));
                break;
        }

        if (modified) {
            this.pushundo(cloned);
            this.refresh(modified);
        }
    },

    overlayCurves2: function (curve) {
        curve = JSDraw2.AssayCurve.cast(curve);
        if (curve == null)
            return;

        var list = [];
        for (var i = 0; i < this.m.graphics.length; ++i) {
            var c = JSDraw2.AssayCurve.cast(this.m.graphics[i]);
            if (c != null && c.selected)
                list.push(c);
        }
        this.overlayCurves(list, curve);
    },

    overlayCurves: function (list, curve) {
        if (scil.Utils.indexOf(list, curve) < 0)
            return;

        this.pushundo();
        curve.setDisplayRange();
        for (var i = 0; i < list.length; ++i) {
            list[i].curveline = false;
            list[i].icxline = false;
            if (list[i] == curve) {
                list[i].curveonly = false;
                //list[i].showline = "";
            }
            else {
                list[i]._rect = curve._rect.clone();
                list[i].curveonly = true;
                //list[i].showline = "curve";
                list[i].x1 = curve.x1;
                list[i].x2 = curve.x2;
                list[i].y1 = curve.y1;
                list[i].y2 = curve.y2;
            }
        }

        this.refresh(true);
    },

    setGroupProperties: function (obj) {
        var g = JSDraw2.Group.cast(obj);
        if (g == null)
            return;

        var me = this;
        if (this.groupPropDlg == null) {
            var me = this;
            var fields = { ratio: { label: "Ratio", type: "number", accepts: "(and)|(or)|[*|?]", width: 100 }, tag: { label: "Annotation", width: 300} };
            this.groupPropDlg = scil.Form.createDlgForm("Group Properties", fields, { label: "Save", onclick: function () { me.setGroupProperties2(); } });
        }
        this.groupPropDlg.show();
        this.groupPropDlg.form.setData({ ratio: g.ratio, tag: g.tag });
        this.groupPropDlg.g = g;
    },

    setGroupProperties2: function () {
        var data = this.groupPropDlg.form.getData();
        var g = this.groupPropDlg.g;
        if (data.ratio != "" && this.hasGroupBond(g))
            data.ratio = "";

        if ((g.ratio == null ? "" : g.ratio + "") != data.ratio || g.tag != data.tag) {
            this.pushundo();
            g.ratio = data.ratio;
            g.tag = data.tag;
            this.groupPropDlg.hide();
            this.refresh(true);
        }
    },

    hasGroupBond: function (g) {
        var list = g.a == null ? null : this.m.getAllBonds(g.a);
        return list != null && list.length > 0;
    },

    copyAs: function (fmt) {
        var s = null;
        switch (fmt) {
            case "molfile":
                s = this.getMolfile();
                break;
            case "molfile2000":
                s = this.getMolfile(false);
                break;
            case "molfile3000":
                s = this.getMolfile(true);
                break;
            case "smiles":
                s = this.getSmiles(true);
                break;
        }

        if (scil.Utils.isNullOrEmpty(s)) {
            scil.Utils.alert("Nothing placed on clipboard");
            return;
        }

        scil.Clipboard.copy(s);
    },

    pasteAs: function (fmt) {
    },

    rgroupDefine: function (obj) {
        JSDraw2.needPro();
        return false;
    },

    createMulticenter: function () {
        JSDraw2.needPro();
        return null;
    },

    viewLarge: function () {
        var label = this.options.viewonly ? "Dismiss" : "Save";
        JSDraw2.Editor.showPopup("View Structure", label, null, { value: this.clone(), format: "clone" });
    },

    removeAtomValues: function () {
        var cloned = null;
        for (var i = 0; i < this.m.atoms.length; ++i) {
            var a = this.m.atoms[i];
            if (a.tag != null && a.tag != "") {
                if (cloned == null)
                    cloned = this.clone();
                a.tag = null;
            }
        }

        if (cloned != null) {
            this.pushundo(cloned);
            this.refresh(true);
        }
        return cloned != null;
    },

    /**
    * Select all object
    * @function selectAll
    * @returns true or false
    */
    selectAll: function () {
        var f = this.m.setSelected(true) > 0;
        if (this.options.onselectionchanged != null)
            this.options.onselectionchanged(this);
        return f;
    },

    addRgroupStructure: function (rgroup) {
        JSDraw2.needPro();
    },

    menuTLCSetSpotShape: function (obj, shape, size) {
        JSDraw2.needPro();
    },

    menuTLCSetSpotSize: function (obj, size) {
        JSDraw2.needPro();
    },

    menuTLCLabel: function (obj, cmd) {
        JSDraw2.needPro();
    },

    menuTLCSetLabel: function (obj, cmd) {
        JSDraw2.needPro();
    },

    menuTLCFill: function (obj, cmd) {
        JSDraw2.needPro();
    },

    menuShapeType: function (obj, cmd) {
        JSDraw2.needPro();
    },

    menuAlignShapes: function (obj, cmd) {
        JSDraw2.needPro();
    },

    menuShapeFill: function (obj, cmd) {
        JSDraw2.needPro();
    },

    menuAntiboyType: function (obj, cmd) {
        JSDraw2.needPro();
    },

    showSequences: function (obj) {
        JSDraw2.needPro();
    },

    menuSetFontsize: function (cmd, obj) {
        JSDraw2.needPro();
    },

    menuSetColor: function (cmd, obj) {
        JSDraw2.needPro();
    },

    addTag: function (obj, p, s, edit) {
        JSDraw2.needPro();
    },

    setBracketData: function (br, fieldtype, prefix, ypos) {
        JSDraw2.needPro();
    },

    setBracketSubscription: function (br) {
        if (br == null)
            return;

        var t = this.m.getSgroupText(br, "BRACKET_TYPE");
        if (t == null)
            t = br.createSubscript(this.m, "#");
        this.showTextEditor(t, null, t.text);
    },

    setBracketRatio: function (br) {
        JSDraw2.needPro();
    },

    menuBracket: function (cmd, sub, checked, obj) {
        JSDraw2.needPro();
    },

    menuSetTextField: function (cmd, txt) {
        JSDraw2.needPro();
    },

    menuSetAttachPoint: function (cmd, obj) {
        JSDraw2.needPro();
    },

    lockAtomConnection: function (f) {
        JSDraw2.needPro();
    },

    menuSetAtomQuery: function (cmd, sub, checked, obj) {
        JSDraw2.needPro();
    },

    menuSetAtomQuery2: function (key, val) {
        JSDraw2.needPro();
    },

    menuSetAtomType: function (cmd, obj) {
        if (cmd == "..." || cmd == "more") {
            var me = this;
            this.showPT(function (elem) { me.menuSetAtomType2(elem, obj); });
        }
        else {
            this.menuSetAtomType2(cmd, obj);
        }
    },

    menuSetAtomType2: function (elem, obj) {
        var n = 0;
        var cloned = this.clone();

        var a = JSDraw2.Atom.cast(obj);
        if (a != null && !a.selected) {
            if (a._parent.setAtomType(a, elem))
                ++n;
        }
        else {
            var atoms = this.m.allAtoms();
            for (var i = 0; i < atoms.length; ++i) {
                var a = atoms[i];
                if (a.selected && a._parent.setAtomType(a, elem))
                    ++n;
            }
        }

        if (n > 0) {
            this.pushundo(cloned);
            this.refresh(true);
        }
    },

    menuSetAtomCharges: function (cmd) {
        var charges = parseInt(cmd);
        if (isNaN(charges))
            return;

        var n = 0;
        var cloned = this.clone();

        var atoms = this.m.allAtoms();
        for (var i = 0; i < atoms.length; ++i) {
            var a = atoms[i];
            if (a.selected && a._parent.setAtomCharge(a, charges))
                ++n;
        }

        if (n > 0) {
            this.pushundo(cloned);
            this.refresh(true);
        }
    },

    menuSetAtomIsotope: function (cmd) {
        JSDraw2.needPro();
    },

    menuSetAtomRadical: function (cmd) {
        JSDraw2.needPro();
    },

    menuSetEhnStereochemistry: function (cmd) {
        JSDraw2.needPro();
    },

    menuSetBondTop: function (cmd) {
        JSDraw2.needPro();
    },

    menuSetRxnCenter: function (cmd) {
        JSDraw2.needPro();
    },

    menuSetBondType: function (cmd) {
        JSDraw2.needPro();
    },

    getAllTlcPlates: function (sorting) {
        JSDraw2.needPro();
    },

    numberTlcPlates: function () {
        JSDraw2.needPro();
    },

    expandSuperatom: function () {
        if (!this.helm.expandSuperAtom(this.curObject))
            JSDraw2.needPro();
    },

    _setSelectedBondType: function (bt) {
        var n = 0;
        var bonds = this.m.allBonds();
        for (var i = 0; i < bonds.length; ++i) {
            var b = bonds[i];
            if (b.selected && b._parent.setBondType(bonds[i], bt))
                ++n;
        }
        return n;
    },

    doRxnMap: function (curobj) {
        JSDraw2.needPro();
    },

    Cmd2BondType: function (cmd) {
        switch (cmd) {
            case "single":
                return JSDraw2.BONDTYPES.SINGLE;
            case "double":
                return JSDraw2.BONDTYPES.DOUBLE;
            case "triple":
                return JSDraw2.BONDTYPES.TRIPLE;
            case "unknown":
                return JSDraw2.BONDTYPES.UNKNOWN;
            case "dummy":
                return JSDraw2.BONDTYPES.DUMMY;
            case "either":
                return JSDraw2.BONDTYPES.EITHER;
            case "wiggly":
                return JSDraw2.BONDTYPES.WIGGLY;
            case "bold":
                return JSDraw2.BONDTYPES.BOLD;
            case "boldhash":
                return JSDraw2.BONDTYPES.BOLDHASH;
            case "delocalized":
                return JSDraw2.BONDTYPES.DELOCALIZED;
            case "up":
                return JSDraw2.BONDTYPES.WEDGE;
            case "down":
                return JSDraw2.BONDTYPES.HASH;
        }
        return null;
    },

    delObject: function (obj) {
        if (obj == null)
            return false;

        var br = JSDraw2.Bracket.cast(obj);
        if (br != null) {
            for (var i = 0; i < this.m.graphics.length; ++i) {
                var t = JSDraw2.Text.cast(this.m.graphics[i]);
                if (t != null && scil.Utils.indexOf(t.anchors, br) >= 0)
                    this.m.delObject(t);
            }
            this.m.delObject(br);
            return true;
        }

        var tlc = JSDraw2.TLC.cast(obj);
        if (tlc != null) {
            if (tlc.removeSpot(tlc.curspot))
                return true;
        }

        var rgroup = JSDraw2.RGroup.cast(obj);
        if (rgroup != null)
            return false;

        var a = JSDraw2.Atom.cast(obj);
        if (a != null) {
            if (this.delAA(a))
                return true;

            if (JSDraw2.defaultoptions.delheteroatom != false && a.bio == null) {
                if (a.elem != "C" || a.alias != null && a.alias != "") {
                    a.elem = "C";
                    a.alias = null;
                    a._parent.setHCount(a);
                    return true;
                }
            }
        }

        var f = obj._parent.delObject(obj);
        if (f) {
            if (tlc != null)
                this.numberTlcPlates();
        }

        return f;
    },

    delSelected: function () {
        var hasTcl = false;
        for (var i = 0; i < this.m.graphics.length; ++i) {
            if (JSDraw2.TLC.cast(this.m.graphics[i]) != null) {
                hasTcl = true;
                break;
            }
        }

        var n = this.m.delSelected();
        if (n > 0 && hasTcl)
            this.numberTlcPlates();
        return n;
    },

    hasSelected: function () {
        var n = this.m.hasSelected();
        if (n > 0) {
            for (var i = 0; i < this.m.graphics.length; ++i) {
                if (JSDraw2.TLC.cast(this.m.graphics[i]) != null) {
                    this.numberTlcPlates();
                    break;
                }
            }
        }

        return n;
    },

    lassoSelect: function (last) {
        if (this.start == null || this.end == null)
            return;

        var extra = this.surface.extra;
        if (extra.lasso == null)
            extra.lasso = new JSDraw2.Lasso(extra, this.linewidth, true);

        JSDraw2.Drawer.drawLine(extra, last, this.end, "#aaf", this.linewidth / 2);
        this.m.lassoSelect(extra, this.start, this.end, last, this.linewidth, this.tor / 8);
    },

    selectInRect: function (r) {
        return this.m.selectInRect(r);
    },

    addTemplate: function (key, obj, p) {
        var a = JSDraw2.Atom.cast(obj);
        var b = JSDraw2.Bond.cast(obj);

        var m2 = key == "[custom]" ? JSDraw2.CustomTemplates.get(key) : JSDraw2.SuperAtoms.getTemplate(key);
        if (m2 == null)
            return;
        var m = m2.clone();
        m.setBondLength(b == null ? this.bondlength : b.bondLength());

        if (a != null) {
            this._addNewAtomInExistingGroup(a, m.atoms);
            var a0 = m.atoms[0];
            if (JSDraw2.SuperAtoms._alignMol(a._parent, a, m, m.atoms[0]))
                m.replaceAtom(a0, a);
            else
                return;
        }
        else if (b != null) {
            this._addNewAtomInExistingGroup(b.a1, m.atoms);
            this._addNewAtomInExistingGroup(b.a2, m.atoms);
            var b0 = null;
            for (var i = 0; i < m.bonds.length; ++i) {
                if (m.bonds[i].type != JSDraw2.BONDTYPES.SINGLE) {
                    b0 = m.bonds[i];
                    break;
                }
            }
            if (b0 == null)
                b0 = m.bonds[0];
            m.offset(b.a1.p.x - b0.a1.p.x, b.a1.p.y - b0.a1.p.y);
            var dir = this._caclBondDir(this.m, b);
            var dir0 = this._caclBondDir(m, b0);
            if (dir > 0 && dir0 > 0 || dir < 0 && dir0 < 0)
                m.flipX(b.a1.p.x);

            var deg = b.angle();
            var deg0 = b0.angle();
            m.rotate(b0.a1.p.clone(), deg - deg0);

            m.replaceBond(b0, b);
        }
        else {
            var a0 = m.atoms[0];
            m.offset(p.x - a0.p.x, p.y - a0.p.y);
        }

        for (var i = 0; i < m.atoms.length; ++i) {
            var a0 = m.atoms[i];
            var a2 = JSDraw2.Atom.cast(this.toggle(a0.p));
            if (a2 != null && a != a0)
                m.replaceAtom(a0, a2);
        }

        // attach to existing group
        var group = null;
        if (a != null && a.group != null)
            group = a.group;
        if (b != null && b.a1.group != null && b.a2.group != null && b.a1.group == b.a2.group)
            group = b.a1.group;
        if (group != null) {
            for (var i = 0; i < m.atoms.length; ++i)
                m.atoms[i].group = group;
        }

        var parent = a != null ? a._parent : (b != null ? b._parent : null);
        if (parent != null)
            parent.mergeMol(m);
        else
            this.m.mergeMol(m);
    },

    _caclBondDir: function (m, b) {
        var n = 0;
        var atoms = m.getNeighborAtoms(b.a1, b.a2);
        for (var i = 0; i < atoms.length; ++i) {
            if (b.a1.p.angleAsOrigin(b.a2.p, atoms[i].p) > 180)
                ++n;
            else
                --n;
        }

        var atoms = m.getNeighborAtoms(b.a2, b.a1);
        for (var i = 0; i < atoms.length; ++i) {
            if (b.a2.p.angleAsOrigin(atoms[i].p, b.a1.p) > 180)
                ++n;
            else
                --n;
        }

        return n;
    },

    keydown: function (e) {
        if (!this.activated)
            return;

        if (this.texteditor.ed != null && this.texteditor.ed.input.style.display == "")
            return;
        if (this.helm != null) {
            this.helm.cancelDnD();
            org.helm.webeditor.MolViewer.hide();
        }

        if (scil.Utils.getZindex(this.div) < scil.Utils.getMaxZindex())
            return;

        this._keypresschar = String.fromCharCode(e.keyCode);

        if (e.preventDefault == null)
            e.preventDefault = function () { };

        if (this.contextmenu != null)
            this.contextmenu.hide();

        if (e.keyCode == 27) {
            if (this.start != null) {
                this.start = null;
                this.redraw();
            }
        }

        // ctrl
        if (e.ctrlKey || e.metaKey) {
            switch (e.keyCode) {
                case 89: // Y
                case 121:
                    if (!this.options.appmode) {
                        if (this.redo())
                            this.refresh(true);
                    }
                    break;
                case 90: // Z
                case 122:
                    if (!this.options.appmode) {
                        if (this.undo())
                            this.refresh(true);
                    }
                    break;
                case 67: // C
                case 99:
                    if (!this.options.appmode)
                        this.copy();
                    break;
                case 86: // V
                case 118:
                    if (!this.options.appmode && scil.Utils.isIE) { // except IE, I#10205
                        // IE uses this;  All other browsers use document.onpaste event
                        if (this.paste())
                            this.refresh(true);
                    }
                    break;
                case 88: // X
                case 120:
                    if (!this.options.appmode) {
                        if (this.cut())
                            this.refresh(true);
                    }
                    break;
                case 65: // A
                case 97:
                    if (this.selectAll())
                        this.refresh(false);
                    e.preventDefault();
                    break;
            }
            return;
        }

        var a = JSDraw2.Atom.cast(this.curObject);
        if (e.keyCode == 8 || e.keyCode == 46) { // del
            if (this.onDel())
                e.preventDefault();
            return;
        }

        // move selected objects
        if (this.m.hasSelected()) {
            var dx = 0;
            var dy = 0;
            switch (e.keyCode) {
                case 37: // left
                    dx = -1;
                    break;
                case 38: // up
                    dy = -1;
                    break;
                case 39: // right
                    dx = 1;
                    break;
                case 40: // down
                    dy = 1;
                    break;
            }

            if (dx != 0 || dy != 0) {
                this.pushundo();
                //this.m.offset(e.shiftKey ? dx : dx * this.bondlength / 2, e.shiftKey ? dy : dy * this.bondlength / 2, true);
                this.m.offset(e.shiftKey ? dx : dx * 20, e.shiftKey ? dy : dy * 20, true);
                this.refresh(true);
                e.preventDefault();
                return;
            }
        }

        if (this.curObject == null) {
            if (this.getCmd() == "seq") {
                var c = String.fromCharCode(e.keyCode);
                if (JSDraw2.SuperAtoms.getAA(c) != null) {
                    this.createAA(this.lastmove, c, JSDraw2.BIO.AA);
                }
            }
            else if (this.getCmd() == "helix") {
                var c = String.fromCharCode(e.keyCode);
                if (JSDraw2.SuperAtoms.getDNA(c) != null) {
                    this.createAA(this.lastmove, c, JSDraw2.BIO.BASE_DNA);
                }
            }
            else if (this.getCmd() == "rna") {
                var c = String.fromCharCode(e.keyCode);
                if (JSDraw2.SuperAtoms.getRNA(c) != null) {
                    this.createAA(this.lastmove, c, JSDraw2.BIO.BASE_RNA);
                }
            }
            return;
        }

        if (a != null) {
            if (a.bio) {
                if (e.keyCode == 13) {
                    this.showTextEditor(a, a.p.clone());
                    e.preventDefault();
                    return;
                }

                if (this.helm != null && scil.helm.isHelmNode(a)) {
                    var c = String.fromCharCode(e.keyCode);
                    if (scil.helm.Monomers.getMonomer(a, c) != null) {
                        this.pushundo();
                        a.elem = c;
                        this.refresh(true);
                    }
                }
                else if (a.biotype() == JSDraw2.BIO.AA && JSDraw2.SuperAtoms.getAA(c) != null || a.biotype() == JSDraw2.BIO.BASE_DNA && JSDraw2.SuperAtoms.getDNA(c) != null || a.biotype() == JSDraw2.BIO.BASE_RNA && JSDraw2.SuperAtoms.getRNA(c) != null) {
                    var c = String.fromCharCode(e.keyCode);
                    if (a.selected) {
                        if (a.elem != c) {
                            this.pushundo();
                            a.elem = c;
                            this._setSuperatom(a);
                            this.refresh(true);
                        }
                    }
                    else {
                        this.insertAA(a, c);
                    }
                }
                return;
            }
            else if (a.elem == "R") {
                if (e.keyCode >= 49 && e.keyCode <= 57) {
                    var rlabel = "R" + (e.keyCode - 48);
                    if (a.alias != rlabel) {
                        this.pushundo();
                        this.m.setAtomAlias(a, rlabel);
                        this.refresh(true);
                    }
                    return;
                }
            }

            var c = null;
            switch (e.keyCode) {
                //case 16: // *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                case 56:
                    c = '*';
                    break;
                case 50:
                    c = '@';
                    break;
                case 187:
                case 107:
                    c = '+';
                    break;
                case 189:
                case 109:
                    c = '-';
                    break;
                case 61:
                    if (scil.Utils.isFirefox)
                        c = '+';
                    break;
                case 173:
                    if (scil.Utils.isFirefox)
                        c = '-';
                    break;
                case 65:
                case 97:
                    c = 'A';
                    break;
                case 81:
                case 113:
                    c = 'Q';
                    break;
                case 66:
                case 98:
                    c = 'Br';
                    break;
                case 67:
                case 99:
                    c = 'C';
                    break;
                case 68:
                case 100:
                    c = 'D';
                    break;
                case 70:
                case 102:
                    c = 'F';
                    break;
                case 72:
                case 104:
                    c = 'H';
                    break;
                case 73:
                case 105:
                    c = 'I';
                    break;
                case 76:
                case 108:
                    c = 'Cl';
                    break;
                case 78:
                case 110:
                    c = 'N';
                    break;
                case 79:
                case 111:
                    c = 'O';
                    break;
                case 80:
                case 112:
                    c = 'P';
                    break;
                case 82:
                case 114:
                    c = 'R';
                    break;
                case 83:
                case 115:
                    c = 'S';
                    break;
                case 84:
                case 116:
                    c = 'T';
                    break;
                case 88:
                case 120:
                    c = 'X';
                    break;
                case 77:
                case 109:
                    c = 'M';
                    break;
                case 69:
                    c = "Me";
                    break;
                case 13:
                    this.showTextEditor(a, a.p.clone());
                    e.preventDefault();
                    return;
            }

            if (c == '+' || c == '-') {
                var cloned = this.clone();
                if (this.increaseNum(a, c == '+' ? +1 : -1)) {
                    this.pushundo(cloned);
                    this.refresh(true);
                    return;
                }
            }
            else if (c == "Me") {
                var cloned = this.clone();
                if (this.m.setAtomAlias(a, c)) {
                    this.pushundo(cloned);
                    this.refresh(true);
                    return;
                }
            }
            else if (c != null) {
                var cloned = this.clone();
                if (this.m.setAtomType(a, c)) {
                    this.pushundo(cloned);
                    this.refresh(true);
                    return;
                }
            }
            return;
        }

        var shp = JSDraw2.Shape.cast(this.curObject);
        if (shp != null && e.keyCode == 13) {
            this.showTextEditor(shp, shp._rect.center());
            e.preventDefault();
            return;
        }

        var b = JSDraw2.Bond.cast(this.curObject);
        if (b != null) {
            if (b.isBio()) {
                var f = false;
                var cloned = null;
                if (e.keyCode == 83 && b.type == JSDraw2.BONDTYPES.PEPTIDE) {
                    cloned = this.clone();
                    f = this.m.setBondType(b, JSDraw2.BONDTYPES.DISULFIDE);
                }
                else if (e.keyCode == 49 && b.type == JSDraw2.BONDTYPES.DISULFIDE) {
                    cloned = this.clone();
                    f = this.m.setBondType(b, JSDraw2.BONDTYPES.PEPTIDE);
                }
                if (f) {
                    this.pushundo(cloned);
                    this.refresh(true);
                }
            }
            else {
                var c = -1;
                if (e.keyCode == 189 || e.keyCode == 109)
                    c = 10;
                else if (e.keyCode == 187 || e.keyCode == 107)
                    c = 11;
                else if (e.keyCode == 192)
                    c = 13;
                else
                    c = e.keyCode - 48;

                if (c >= JSDraw2.BONDTYPES.UNKNOWN && c <= JSDraw2.BONDTYPES.DUMMY && this.curObject.type != c) {
                    var cloned = this.clone();
                    if (this.m.setBondType(b, c)) {
                        this.pushundo(cloned);
                        if (b.type == JSDraw2.BONDTYPES.WEDGE || b.type == JSDraw2.BONDTYPES.HASH)
                            this.fixWedgeDir(b);
                        this.refresh(true);
                        return;
                    }
                }
                else if (c == 9 && (b.type == JSDraw2.BONDTYPES.WEDGE || b.type == JSDraw2.BONDTYPES.HASH)) {
                    this.pushundo();
                    b.reverse();
                    this.refresh(true);
                    return;
                }
            }
            return;
        }

        var txt = JSDraw2.Text.cast(this.curObject);
        if (txt != null) {
            this.showTextEditor(txt);
            e.preventDefault();
            return;
        }

        var t = JSDraw2.TLC.cast(this.curObject);
        if (t != null) {
            if (t.curspot != null) {
                switch (e.keyCode) {
                    case 187:
                    case 189:
                        var clone = this.clone();
                        if (t.curspot.move((e.keyCode == 187 ? 0.1 : -0.1) * (e.shiftKey ? 0.1 : 1))) {
                            this.pushundo(clone);
                            this.refresh(true);
                        }
                        e.preventDefault();
                        break;
                    case 190: // >
                        this.pushundo();
                        t.changeSize(t.curspot, "110%");
                        this.refresh(true);
                        break;
                    case 188: // <
                        this.pushundo();
                        t.changeSize(t.curspot, "90%");
                        this.refresh(true);
                        break;
                    case 82: // R
                    case 76: // L
                        {
                            this.pushundo();
                            //if (Math.abs(t.curspot.ry1) <= 1)
                            t.curspot.rx += e.shiftKey ? -0.2 : 0.2;
                            if (t.curspot.rx < 0.1)
                                t.curspot.rx = 0.1;
                            this.refresh(true);
                        }
                        break;
                    case 85: // U
                        {
                            this.pushundo();
                            //if (Math.abs(t.curspot.ry1) <= 1)
                            t.curspot.ry1 += e.shiftKey ? -0.2 : 0.2;
                            this.refresh(true);
                        }
                        break;
                    case 68: // D
                        {
                            this.pushundo();
                            //if (Math.abs(t.curspot.ry1) <= 1)
                            t.curspot.ry2 += e.shiftKey ? -0.2 : 0.2;
                            this.refresh(true);
                        }
                        break;
                }
            }
        }
    },

    toCharArray: function (s, m) {
        if (!(m > 0))
            m = 1;

        var ss = [];
        for (var i = 0; i < s.length; ++i)
            ss.push(s.substr(i, m));
        return ss;
    },

    splitString: function (s, pat) {
        var ss = [];

        var re = new RegExp("^" + pat);
        var ret;
        while ((ret = re.exec(s)) != null) {
            var c = ret + "";
            ss.push(c);
            if (s.length == c.length)
                return ss;
            s = s.substr(c.length);
        }
        return null;
    },

    createAA2: function (s, biotype, expand, asrxn, nterminal, cterminal, selected) {
        if (scil.Utils.isNullOrEmpty(s))
            return;

        if (expand)
            s = s.replace(/[>|\^]/g, "");

        if (new RegExp("^[a-z|^|>]+$").test(s))
            s = scil.Utils.trim(s).toUpperCase();

        var ss = null;
        if (biotype == JSDraw2.BIO.BASE_DNA) {
            if (new RegExp("^[A|G|T|C]+$").test(s)) {
                ss = this.toCharArray(s);
            }
            else {
                scil.Utils.alert2("Invalid DNA sequence.");
                return;
            }
        }
        if (biotype == JSDraw2.BIO.BASE_RNA) {
            if (new RegExp("^[A|G|T|C|U]+$").test(s)) {
                ss = this.toCharArray(s);
            }
            else {
                scil.Utils.alert2("Invalid RNA sequence.");
                return;
            }
        }
        else if (biotype == JSDraw2.BIO.AA) {
            s = s.replace(/[\.]/g, "-");
            if (s.indexOf('-') > 0)
                ss = s.split('-');
            else if (new RegExp("^([A-Z][a-z|0-9]{2}[\\^]?)+[>]?$").test(s))
                ss = this.splitString(s, "[A-Z][a-z|0-9]{2}[\\^|>]?");
            else if (new RegExp("^([A-Z][\\^]?)+[>]?$").test(s)) {
                ss = this.splitString(s, "[A-Z][\\^|>]?");
            }
            if (ss == null) {
                scil.Utils.alert2("Invalid peptide sequence.");
                return;
            }
        }

        if (ss.length >= 3 && scil.Utils.endswith(ss[ss.length - 1], ">") && s.indexOf('^') <= 0)
            ss[0] += "^";

        var m;
        if (expand && biotype == JSDraw2.BIO.AA)
            m = this._createExpandedAA(ss, biotype, nterminal, cterminal);
        else
            m = this._createCollapsedAA(ss, biotype, nterminal, cterminal);
        if (m == null)
            return false;

        if (nterminal == null || nterminal == "")
            nterminal = "H";
        if (cterminal == null || cterminal == "")
            cterminal = "OH";

        var seq = (nterminal != null ? nterminal + "-" : "") + s + (cterminal != null ? "-" + cterminal : "");
        if (this.options.onAddSequence != null) {
            if (this.options.onAddSequence(m, seq, asrxn))
                return true;
        }

        this.m.setSelected(false);
        if (selected != false)
            m.setSelected(true);

        this.pushundo();
        if (asrxn == "reactant" || asrxn == "product") {
            var rxn = this.m.parseRxn();
            if (asrxn == "reactant")
                rxn.reactants.push(m);
            else
                rxn.products.push(m);
            this.setRxn(rxn, false, this.bondlength);
        }
        else {
            this.m.mergeMol(m);
        }

        this.fitToWindow();

        //        var t = null;
        //        if (biotype == JSDraw2.BIO.AA) {
        //            var c = m.rect().centerBottom();
        //            var r = new JSDraw2.Rect(c.x - s.length * this.fontsize / 3, c.y + this.bondlength / 2, 0, 0);
        //            t = new JSDraw2.Text(r, seq);
        //            t.fieldtype = "SEQUENCE";
        //            t.anchors = scil.clone(m.atoms);
        //            this.m.addGraphics(t);
        //        }

        this.refresh(true);
        //        if (t != null) {
        //            var c = m.rect().centerBottom();
        //            t._rect.offset(c.x - t._rect.center().x, 0);
        //        }

        return true;
    },

    _createCollapsedAA: function (ss, biotype, nterminal, cterminal) {
        if (nterminal == null || nterminal == "")
            nterminal = "H";
        if (cterminal == null || cterminal == "")
            cterminal = "OH";

        var head = [];
        var circle = null;
        var tail = null;
        var all = [];

        for (var i = 0; i < ss.length; ++i) {
            var c = ss[i];
            var iscircle = c.length > 1 && (c.substr(c.length - 1) == "^" || c.substr(c.length - 1) == ">");
            if (iscircle)
                c = c.substr(0, c.length - 1);

            var a = new JSDraw2.Atom(null, c, { type: biotype });
            switch (biotype) {
                case JSDraw2.BIO.AA:
                    a.superatom = JSDraw2.SuperAtoms.getAA(c);
                    break;
                case JSDraw2.BIO.BASE_DNA:
                    a.superatom = JSDraw2.SuperAtoms.getDNA(c);
                    break;
                case JSDraw2.BIO.BASE_RNA:
                    a.superatom = JSDraw2.SuperAtoms.getRNA(c);
                    break;
            }
            if (a.superatom == null) {
                scil.Utils.alert("It cannot parse: " + c);
                return;
            }
            all.push(a);

            if (iscircle) {
                if (circle == null) {
                    circle = [a];
                }
                else {
                    if (tail == null) {
                        circle.push(a);
                        tail = [];
                    }
                    else {
                        tail.push(a);
                    }
                }
            }
            else {
                if (tail != null)
                    tail.push(a);
                else if (circle != null)
                    circle.push(a);
                else
                    head.push(a);
            }
        }

        var bondtype = JSDraw2.BONDTYPES.SINGLE;
        if (biotype == JSDraw2.BIO.AA)
            bondtype = JSDraw2.BONDTYPES.PEPTIDE;
        else if (biotype == JSDraw2.BIO.DNA || biotype == JSDraw2.BIO.RNA)
            bondtype = JSDraw2.BONDTYPES.NUCLEOTIDE;

        if (circle != null && circle.length == 1) {
            head.push(circle[0]);
            circle = null;
            if (tail != null) {
                for (var i = 0; i < tail.length; ++i)
                    head.push(tail[i]);
                tail = null;
            }
        }

        var nterm = null;
        var cterm = null;
        var m = new JSDraw2.Mol(this.options.showimplicithydrogens);
        if (head.length > 0) {
            nterm = new JSDraw2.Atom(null, "C");
            m.addAtom(nterm);
            head.splice(0, 0, nterm);

            var b = new JSDraw2.Bond(head[1], nterm, biotype == JSDraw2.BIO.AA ? JSDraw2.BONDTYPES.PEPTIDE : JSDraw2.BONDTYPES.NUCLEOTIDE);
            b.apo1 = 1;
            m.addBond(b);
        }

        m.addAtom(all[0]);
        for (var i = 1; i < all.length; ++i) {
            m.addAtom(all[i]);
            var b = new JSDraw2.Bond(all[i], all[i - 1], bondtype);
            b.apo1 = 1;
            b.apo2 = 2;
            m.addBond(b);
        }

        if (circle == null) {
            var o = new JSDraw2.Atom(null, biotype == JSDraw2.BIO.AA ? 'O' : "3'");
            m.addAtom(o);
            head.push(o);
            cterm = o;

            var b = new JSDraw2.Bond(o, head[head.length - 2], biotype == JSDraw2.BIO.AA ? JSDraw2.BONDTYPES.PEPTIDE : JSDraw2.BONDTYPES.NUCLEOTIDE);
            b.apo2 = 2;
            m.addBond(b);
        }
        else {
            if (head.length == 0 && (tail == null || tail.length == 0)) {
                var b = new JSDraw2.Bond(circle[0], circle[circle.length - 1], JSDraw2.BONDTYPES.PEPTIDE);
                b.apo1 = 1;
                b.apo2 = 2;
                m.addBond(b);
            }
            else if (circle[0].elem == 'C' && circle[circle.length - 1].elem == 'C') {
                var b = new JSDraw2.Bond(circle[0], circle[circle.length - 1], JSDraw2.BONDTYPES.DISULFIDE);
                b.apo1 = 3;
                b.apo2 = 3;
                m.addBond(b);
            }
            else if (circle[0].elem == 'K' && (tail == null || tail.length == 0)) {
                var b = new JSDraw2.Bond(circle[0], circle[circle.length - 1], JSDraw2.BONDTYPES.AMIDE);
                b.apo1 = 3;
                b.apo2 = 2;
                m.addBond(b);
            }

            if (tail != null && tail.length > 0) {
                cterm = new JSDraw2.Atom(null, "C");
                m.addAtom(cterm);
                tail.push(cterm);

                var b = new JSDraw2.Bond(tail[tail.length - 2], cterm, JSDraw2.BONDTYPES.SINGLE);
                b.apo1 = 1;
                m.addBond(b);
            }
        }

        if (circle == null || circle.length == 1) {
            var last = null;
            this.layoutAtoms(head, "line", this.bondlength, last);
            if (head.length > 0)
                last = head[head.length - 1];
            if (circle != null) {
                this.layoutAtoms(circle, "line", this.bondlength, last);
                if (circle.length > 0)
                    last = circle[circle.length - 1];
                if (tail != null)
                    this.layoutAtoms(tail, "line", this.bondlength, last);
            }
        }
        else {
            var center = new JSDraw2.Point(0, 0);
            this.layoutAtoms(circle, "circle", this.bondlength, center.clone().offset(1, 0), center);
            if (head.length > 0) {
                head.push(null);
                head.reverse();
                this.layoutAtoms(head, "line", this.bondlength, circle[0].p, center);
            }
            if (tail != null && tail.length > 0) {
                tail.splice(0, 0, null);
                this.layoutAtoms(tail, "line", this.bondlength, circle[circle.length - 1].p, center);
            }
        }

        if (nterm != null) {
            if (biotype == JSDraw2.BIO.AA) {
                if (nterminal == "H")
                    nterm.elem = "H";
                else
                    m.setAtomAlias(nterm, nterminal)
            }
            else {
                nterm.elem = "5'";
            }
        }

        if (cterm != null) {
            if (biotype == JSDraw2.BIO.AA) {
                if (cterminal == "OH")
                    cterm.elem = "O";
                else if (cterminal == "NH2")
                    cterm.elem = "N";
                else
                    m.setAtomAlias(cterm, cterminal)
            }
            else {
                cterm.elem = "3'";
            }
        }

        return m;
    },

    _createExpandedAA: function (ss, biotype, nterminal, cterminal) {
        if (nterminal == null || nterminal == "")
            nterminal = "H";
        if (cterminal == null || cterminal == "")
            cterminal = "OH";

        var mol = null;
        var last = null;
        for (var i = 0; i < ss.length; ++i) {
            var c = ss[i];
            var m = JSDraw2.SuperAtoms.getAA(c);
            if (m == null) {
                scil.Utils.alert("Unknow Amino Acid: " + c);
                return null;
            }
            m = m.clone();
            m.setBondLength(this.bondlength);
            var attachs = JSDraw2.SuperAtoms._getAttachAtoms(m);
            for (var k = 2; k < attachs.length; ++k)
                attachs[k].a.attachpoints = [];

            if (i == 0) {
                mol = m;

                attachs[0].a.attachpoints = [];

                if (nterminal != "H") {
                    var p = this._guessAutoBond(attachs[0].a);
                    var a = new JSDraw2.Atom(p, "C");
                    var b = new JSDraw2.Bond(attachs[0].a, a, JSDraw2.BONDTYPES.SINGLE);
                    mol.addAtom(a);
                    mol.addBond(b);

                    mol.setAtomAlias(a, nterminal)
                }

                last = attachs[1].a;
                continue;
            }

            if (i % 2 == 1) {
                for (var k = 0; k < m.atoms.length; ++k)
                    m.atoms[k].p.y *= -1;

                for (var k = 0; k < m.bonds.length; ++k) {
                    if (m.bonds[k].type == JSDraw2.BONDTYPES.WEDGE)
                        m.bonds[k].type = JSDraw2.BONDTYPES.HASH;
                    else if (m.bonds[k].type == JSDraw2.BONDTYPES.HASH)
                        m.bonds[k].type = JSDraw2.BONDTYPES.WEDGE;
                }
            }

            var p0 = attachs[0].a.p;
            var p = this._guessAutoBond(last);
            m.offset(p.x - p0.x, p.y - p0.y);
            mol.mergeMol(m);

            last.attachpoints = [];
            attachs[0].a.attachpoints = [];
            var b = new JSDraw2.Bond(last, attachs[0].a, JSDraw2.BONDTYPES.SINGLE);
            mol.addBond(b);

            last = attachs[1].a;
        }

        if (last != null) {
            last.attachpoints = [];

            if (cterminal != "H") {
                var p = this._guessAutoBond(last);
                var a = new JSDraw2.Atom(p, "C");
                var b = new JSDraw2.Bond(last, a, JSDraw2.BONDTYPES.SINGLE);
                mol.addAtom(a);
                mol.addBond(b);

                if (cterminal == "OH")
                    a.elem = "O";
                else
                    mol.setAtomAlias(a, cterminal)
            }
        }
        return mol;
    },

    layoutAtoms: function (atoms, shape, d, p1, p2) {
        if (atoms == null || atoms.length == 0)
            return;

        if (p2 == null)
            p2 = new JSDraw2.Point(0, 0);
        if (p1 == null)
            p1 = p2.clone().offset(d, 0);

        switch (shape) {
            case "line":
                if (atoms[0] != null)
                    atoms[0].p = p1.clone();
                var s = d / p1.distTo(p2);
                var dx = (p1.x - p2.x) * s;
                var dy = (p1.y - p2.y) * s;
                for (var i = 1; i < atoms.length; ++i)
                    atoms[i].p = p1.clone().offset(dx * i, dy * i);
                break;
            case "circle":
                var deg = 360 / atoms.length;
                var r = d / 2 / Math.sin(deg / 2 * Math.PI / 180);
                var s = r / p1.distTo(p2);
                p1 = new JSDraw2.Point(p2.x + (p1.x - p2.x) * s, p2.y + (p1.y - p2.y) * s);
                if (atoms[0] != null)
                    atoms[0].p = p1.clone();
                for (var i = 1; i < atoms.length; ++i)
                    atoms[i].p = p1.clone().rotateAround(p2, deg * i);
                break;
        }
    },

    createAA: function (p, c, biotype) {
        if (p == null)
            return;

        this.pushundo();
        var h = new JSDraw2.Atom(p.clone().offset(-this.bondlength, 0), biotype == JSDraw2.BIO.AA ? 'H' : "5'");
        var a = new JSDraw2.Atom(p.clone(), c, { type: biotype });
        a.superatom = null;
        if (biotype == JSDraw2.BIO.AA)
            a.superatom = JSDraw2.SuperAtoms.getAA(c);
        else if (biotype == JSDraw2.BIO.BASE_DNA)
            a.superatom = JSDraw2.SuperAtoms.getDNA(c);
        else if (biotype == JSDraw2.BIO.BASE_RNA)
            a.superatom = JSDraw2.SuperAtoms.getRNA(c);
        var o = new JSDraw2.Atom(p.clone().offset(this.bondlength, 0), biotype == JSDraw2.BIO.AA ? 'O' : "3'");
        this.m.addAtom(h);
        this.m.addAtom(a);
        this.m.addAtom(o);

        var b = new JSDraw2.Bond(h, a, JSDraw2.BONDTYPES.SINGLE);
        a.apo2 = 2;
        this.m.addBond(b);

        b = new JSDraw2.Bond(a, o, JSDraw2.BONDTYPES.SINGLE);
        a.apo1 = 1;
        this.m.addBond(b);

        this.curObject = a;
        this.refresh(true);
    },

    delAA: function (a) {
        if (a == null || a.biotype() != JSDraw2.BIO.AA && a.biotype() != JSDraw2.BIO.BASE_DNA && a.biotype() != JSDraw2.BIO.BASE_RNA)
            return false;

        var next = this.findNextAA(a, false);
        if (next == null)
            return false;

        this.m.delBond(next.b, false);
        var mm = this.m.getFragment(next.a);
        mm.offset(a.p.x - next.a.p.x, a.p.y - next.a.p.y);

        var bonds = this.m.getNeighborBonds(a);
        for (var i = 0; i < bonds.length; ++i) {
            var b = bonds[i];
            if (b.a1 == a)
                b.a1 = next.a;
            else if (b.a2 == a)
                b.a2 = next.a;
        }
        a._parent.delAtom(a);

        return true;
    },

    _setSuperatom: function (a) {
        a.superatom = null;
        var c = a.elem;
        switch (a.biotype()) {
            case JSDraw2.BIO.BASE_DNA:
                a.superatom = JSDraw2.SuperAtoms.getDNA(c);
                break;
            case JSDraw2.BIO.BASE_RNA:
                a.superatom = JSDraw2.SuperAtoms.getRNA(c);
                break;
            case JSDraw2.BIO.AA:
                a.superatom = JSDraw2.SuperAtoms.getAA(c);
                break;
        }
    },

    insertAA: function (a, c) {
        if (a == null || !a.bio)
            return;

        if (a.biotype() == JSDraw2.BIO.AA && JSDraw2.SuperAtoms.getAA(c) == null || a.biotype() == JSDraw2.BIO.BASE_DNA && JSDraw2.SuperAtoms.getDNA(c) != null || a.biotype() == JSDraw2.BIO.BASE_RNA && JSDraw2.SuperAtoms.getRNA(c) != null)
            return;

        var dx = this.bondlength;
        var right = true;
        var list = null;

        var next = this.findNextAA(a, true);
        this.pushundo();
        var na = new JSDraw2.Atom(a.p.clone().offset(dx, 0), c, dojo.clone(a.bio));
        var nb = new JSDraw2.Bond(na, a, a.biotype() == JSDraw2.BIO.AA ? JSDraw2.BONDTYPES.PEPTIDE : JSDraw2.BONDTYPES.SINGLE);
        this.m.addAtom(na);
        this.m.addBond(nb);

        this._setSuperatom(na);
        nb.apo1 = 1;
        nb.apo2 = 2;

        if (next != null) {
            this.m.delBond(next.b, false);
            var mm = this.m.getFragment(next.a);
            mm.offset(dx, 0);
            var b = new JSDraw2.Bond(next.a, na, a.biotype() == JSDraw2.BIO.AA ? JSDraw2.BONDTYPES.PEPTIDE : JSDraw2.BONDTYPES.SINGLE, true);
            b.apo1 = 1;
            b.apo2 = 2;
            this.m.addBond(b);
        }

        this.curObject = na;
        this.refresh(true);
    },

    findNextAA: function (a, forinsert) {
        var bonds = this.m.getNeighborBonds(a);
        if (bonds.length == 0)
            return null;
        else if (bonds.length == 1)
            return { a: bonds[0].otherAtom(a), b: bonds[0] };

        var backup = null;
        for (var i = bonds.length - 1; i >= 0; --i) {
            var oa = bonds[i].otherAtom(a);
            if (Math.abs(a.p.y - oa.p.y) < this.tor / 2) {
                if (oa.p.x < a.p.x) {
                    backup = bonds[i];
                    bonds.splice(i, 1);
                }
                else if (oa.p.x >= a.p.x) {
                    return { a: oa, b: bonds[i] };
                }
            }
        }

        var ret = null;
        for (var i = 0; i < bonds.length; ++i) {
            var b = bonds[i];
            var oa = b.otherAtom(a);
            if (ret == null) {
                ret = { a: oa, b: b };
            }
            else if (!forinsert && b.isBio() && !ret.b.isBio()) {
                ret = { a: oa, b: b };
            }
            else {
                if (oa.p.x < a.p.x && ret.a.p.x < a.p.x || oa.p.x > a.p.x && ret.a.p.x > a.p.x) {
                    if (oa.p.y > ret.a.p.y)
                        ret = { a: oa, b: b };
                }
                else if (oa.p.x > a.p.x) {
                    ret = { a: oa, b: b };
                }
            }
        }

        if (ret == null) {
            return { a: backup.otherAtom(a), b: backup };
        }
        else if (!forinsert && !ret.a.bio) {
            var oa = backup.otherAtom(a);
            if (oa.bio)
                return { a: oa, b: backup };
        }

        return ret;
    },

    findNextAAs: function (a, right) {
        var list = [];
        while (a != null) {
            var r = this._findNextAA(a, right);
            if (r != null) {
                list.push(r);
                a = r.a;
            }
            else {
                break;
            }
        }
        return list;
    },

    _findNextAA: function (a, right) {
        var bonds = this.m.bonds;
        for (var i = 0; i < bonds.length; ++i) {
            var oa = bonds[i].otherAtom(a);
            if (oa != null && Math.abs(oa.p.y - a.p.y) < this.tor / 2 && (right && oa.p.x > a.p.x || !right && oa.p.x < a.p.x))
                return { b: bonds[i], a: oa }
        }
        return null;
    },

    /**
    * Set the view window size
    * @function setSize
    * @param {number} width - new width
    * @param {number height - new height
    * @returns null
    */
    setSize: function (width, height) {
        if (this.maintable != null) {
            if (width > 0)
                this.maintable.style.width = width + "px";
            if (height > 0)
                this.maintable.style.height = height + "px";

            if (this.isSkinW8())
                this.resize(width, height - 24);
            else
                this.resize(width - 28, height - 24);
        }
        else {
            this.resize(width, height);
        }
    },

    onResize: function (width, height) {
        if (this.options.onresize != null) {
            if (this.options.onresize())
                return;
        }
        this.resize(width > 0 ? width : this.div.offsetWidth, height > 0 ? height : this.div.offsetHeight);
    },

    resize: function (width, height) {
        if (scil.Utils.isIpad) {
            // this one cause ELN problem on iPad
            if (scil.eln != null /* ELN 2.0 */ || scil.App != null && scil.App.AccountTypes != null /* ELN 1.x */)
                return;
        }
        if (this._setSurfaceSize(new JSDraw2.Point(width, height))) {
            if (this.isSkinW8() && this.toolbar != null)
                this.toolbar.recreateTopToolbar();
        }
    },

    _setSurfaceSize: function (sz) {
        if (Math.abs(sz.x - this.dimension.x) < 6 && Math.abs(sz.y - this.dimension.y) < 6)
            return false;

        if (sz.x > 0)
            this.dimension.x = sz.x;
        if (sz.y > 0)
            this.dimension.y = sz.y;

        this.div.style.width = this.dimension.x + "px";
        this.div.style.height = this.dimension.y + "px";
        this.surface.setDimensions(this.dimension.x, this.dimension.y);
        this.fitToWindow();
        this.redraw();
        return true;
    },

    dblclick: function () {
        if (this.popuplocked) {
            scil.Utils.alert("Editing is currently locked");
            return false;
        }

        var me = this;
        var fn = function (jsd) {
            me.restoreClone(jsd.clone());
            me.fitToWindow();
            me.refresh(true);
            if (me.options.onpopupsaved != null)
                me.options.onpopupsaved(me);
        };
        JSDraw2.Editor.showPopup("JSDraw2 Popup Editor", "Save", fn, { value: this.clone(), format: "clone" });
    },

    _makeChain: function (chain, end) {
        if (chain == null || chain.end != null && chain.end.distTo(end) < this.tor)
            return false;
        if (end.distTo(chain.start) < this.bondlength * 2)
            chain.p2 = end;
        chain.end = end;
        chain.points = [];

        var d = chain.start.distTo(end);
        var p1 = chain.start;
        var p2;
        if (chain.a == null) {
            if (Math.abs(end.y - p1.y) / Math.abs(end.x - p1.x) < 0.1) // horizontally
                p2 = p1.clone().offset(this.bondlength * (end.x > p1.x ? 1 : -1), 0).rotateAround(p1, 30);
            else
                p2 = this._guessBond(p1, chain.p2, true);
        }
        else {
            p2 = this._guessAutoBond(chain.a, end);
        }
        if (p2 == null)
            return false;
        chain.points = [chain.start];
        chain.points.push(p2);

        var angle;
        var d2 = chain.start.distTo(p2);
        while (d2 != 0 && d2 < d) {
            var origin = p2;
            if (chain.points.length == 2) {
                var t1 = p1.clone().rotateAround(origin, 120);
                var t2 = p1.clone().rotateAround(origin, -120);
                if (t1.distTo(end) < t2.distTo(end)) {
                    p2 = t1;
                    angle = 120;
                }
                else {
                    p2 = t2;
                    angle = -120;
                }
            }
            else {
                angle = -angle;
                p2 = p1.clone().rotateAround(origin, angle);
            }
            p1 = origin;
            chain.points.push(p2);
            d2 = chain.start.distTo(p2);
        }
        return true;
    },

    _guessAutoBond: function (a, end) {
        if (a == null)
            return null;
        if (end == null)
            return a._parent.guessBond(a, this.bondlength);

        var p = null;
        var atoms = a._parent.getNeighborAtoms(a);
        if (atoms.length == 0) {
            p = a.p.clone().offset(this.bondlength, 0);
            if (end != null) {
                var deg = Math.round(end.angleTo(a.p) / 30) * 30;
                p.rotateAround(a.p, deg);
            }
        }
        else if (atoms.length == 1) {
            var a1 = atoms[0];
            var p = a1.p.clone().rotateAround(a.p, -120);
            if (end != null) {
                var t = a1.p.clone().rotateAround(a.p, 120);
                if (t.distTo(end) < p.distTo(end))
                    p = t;
            }
        }
        else if (atoms.length == 2) {
            var a1 = atoms[0];
            var a2 = atoms[1];
            var ang1 = a1.p.angleTo(a.p);
            var mid = a.p.middleAngle(a1.p, a2.p);
            p = a1.p.clone().rotateAround(a.p, mid - ang1 + 180);
        }
        return p;
    },

    _addAutoBond: function (a, cmd) {
        var m = a._parent;
        var p = this._guessAutoBond(a);
        if (p == null)
            return false;

        var elem = null;
        var c = this._countAABonds(a);
        var bondtype = this.Cmd2BondType(cmd);
        if (c != null) {
            // add H or OH on peptide terminal Amino Acid
            if (c.peptideN == 0 && c.others == 0) {
                elem = "H";
                bondtype = JSDraw2.BONDTYPES.PEPTIDE;
            }
            else if (c.peptideC == 0 && c.others == 0)
                elem = "O";
            else
                return false;
        }

        var na = JSDraw2.Atom.cast(this.toggle(p));
        if (na != null) {
            if (na._parent != a._parent)
                na = null;
        }

        if (na == null) {
            na = new JSDraw2.Atom(p, elem);
            this._addNewAtomInExistingGroup(a, [na]);
            m.addAtom(na);
            // attach to existing group
            if (a.group != null)
                na.group = a.group;
        }
        else {
            if (m.findBond(a, na) != null)
                return false;
        }

        var nb = new JSDraw2.Bond(a, na, bondtype);
        m.addBond(nb, null, true);
        return true;
    },

    _guessBond: function (p1, p2, notor) {
        if (!notor && p1.distTo(p2) < this.tor)
            return null;

        var a = p2.angleTo(p1);
        var m = Math.abs(a) % this.angleStop;
        if (a > 0)
            a = a - m + (m > (this.angleStop / 2) ? this.angleStop : 0);
        else
            a = -(-a - m + (m > (this.angleStop / 2) ? this.angleStop : 0));

        return new JSDraw2.Point(this.bondlength, 0).rotate(a).offset(p1.x, p1.y);
    },

    guessArrow: function (p1, p2) {
        if (p1.distTo(p2) < this.bondlength)
            return null;

        var a = p2.angleTo(p1);
        var m = a % 90;
        if (m == 0)
            return p2;

        var s = 0;
        if (m < 5)
            s = -m;
        else if (90 - m < 5)
            s = 90 - m;
        else
            return p2;

        return p2.clone().rotateAround(p1, s);
    },

    frameoffset: { x: 0, y: 0 },
    setFrameoffset: function (x, y) {
        this.frameoffset.x = x;
        this.frameoffset.y = y;
    },

    eventPoint: function (e) {
        var f = true;
        //if (scil.Utils.isIpad)
        //    f = false;
        var objoffset = scil.Utils.getOffset(this.div, f);
        //objoffset = new JSDraw2.Point(0, 0);
        var pt = new JSDraw2.Point(e.clientX - objoffset.x - this.frameoffset.x, e.clientY - objoffset.y - this.frameoffset.y);
        pt.tm = new Date().getTime();
        pt.clientX = e.clientX;
        pt.clientY = e.clientY;
        return pt;
    },

    getCmd: function (td) {
        if (td == null)
            td = this.curButton;
        var s = td == null ? "select" : td.getAttribute('cmd');
        if (s.length > 2 && s.substr(0, 2) == "e-")
            s = s.substr(2);
        return s;
    },

    onSelBtn: function (e) {
        var td = e.target || e.srcElement;
        if (td.getAttribute('cmd') != null) {
            this.onCmd(td);
            return;
        }

        for (var i = 0; i < 5; ++i) {
            td = td.parentNode;
            if (td == null || td.tagName != "TD")
                return;

            if (td.getAttribute('cmd') != null) {
                this.onCmd(td);
                return;
            }
        }
    },

    /**
    * Do a toolbar command
    * @function doCmd
    * @param {string} cmd - the command name
    * @returns null
    */
    doCmd: function (cmd) {
        if (this.toolbar == null)
            return;

        var list = this.toolbar.getButtons();
        for (var i = 0; i < list.length; ++i) {
            var p = list[i];
            if (this.options.skin == "si")
                p = p.parentNode;
            if (p.getAttribute("cmd") == cmd) {
                this.onCmd(p);
                break;
            }
        }
    },

    onCmd: function (td) {
        var useonce = true;
        this.start = null;
        var cmd = this.getCmd(td);
        JSDraw2.Menu.close();
        switch (cmd) {
            case "about":
            case "jsdraw":
                JSDraw2.Editor.showAbout();
                break;
            case "inkclearall":
                if (this.ink != null)
                    this.ink.clear();
                break;
            case "inkclear":
                if (this.ink != null)
                    this.ink.clearLastOne();
                break;
            case "center":
                this.pushundo();
                this.fitToWindow();
                this.redraw();
                break;
            case "zoomin":
                this.pushundo();
                this.scale(1.25, new JSDraw2.Point(this.dimension.x / 2, this.dimension.y / 2));
                this.redraw();
                useonce = false;
                break;
            case "zoomout":
                this.pushundo();
                this.scale(0.75, new JSDraw2.Point(this.dimension.x / 2, this.dimension.y / 2));
                this.redraw();
                useonce = false;
                break;
            case "new":
                if (!this.m.isEmpty()) {
                    var me = this;
                    //scil.Utils.confirmYes("Clear all contents?", function () {
                        me.pushundo();
                        me.clear(null, true);
                        me.refresh(true);
                        if (me.options.filenew != null)
                            me.options.filenew(me);
                    //}, this);
                }
                else {
                    if (this.ink != null)
                        this.ink.clear();
                }
                break;
            case "save":
                if (this.options.filesave != null)
                    this.options.filesave(this);
                else if (scil.Utils.serviceAvailable())
                    JSDraw2.JSDrawIO.jsdFileSave(this);
                else
                    this.onShowSaveFileDlg();
                break;
            case "open":
                if (this.options.fileopen != null)
                    this.options.fileopen(this);
                else if (scil.Utils.serviceAvailable())
                    JSDraw2.JSDrawIO.jsdFileOpen(this);
                else
                    this.onShowOpenFileDlg();
                break;
            case "undo":
                if (this.undo())
                    this.refresh(true);
                useonce = true;
                break;
            case "redo":
                if (this.redo())
                    this.refresh(true);
                useonce = true;
                break;
            case "rxn":
                var cloned = this.clone();
                if (this.cleanupRxn(this.bondlength)) {
                    this.pushundo(cloned);
                    this.refresh(true);
                }
                break;
            case "copyprod":
                var rxn = this.m.parseRxn(true);
                if (rxn != null && rxn.reactants.length > 0 && rxn.products.length == 0) {
                    this.pushundo();
                    for (var i = 0; i < rxn.reactants.length; ++i) {
                        rxn.products.push(rxn.reactants[i].clone());
                    }
                    this.setRxn(rxn, false);
                    this.refresh(true);
                }
                else {
                    scil.Utils.alert("It's already a reaction");
                }
                break;
            case "rxnmap2":
                var cloned = this.clone();
                if (this.m.clearAtomMap() > 0) {
                    this.pushundo(cloned);
                    this.refresh(true);
                }
                else {
                    scil.Utils.alert("No reaction map found");
                }
                break;
            case "seq":
                JSDraw2.SequenceBuilder.show(this, JSDraw2.BIO.AA, "Peptide");
                break;
            case "helix":
                JSDraw2.SequenceBuilder.show(this, JSDraw2.BIO.BASE_DNA, "DNA");
                break;
            case "rna":
                JSDraw2.SequenceBuilder.show(this, JSDraw2.BIO.BASE_RNA, "RNA");
                break;
            case "n2s":
                JSDraw2.JSDrawIO.name2structure(this);
                break;
            case "cleanup":
                JSDraw2.JSDrawIO.cleanup(this);
                break;
            case "selectall":
                if (this.selectAll())
                    this.redraw();
                break;
            case "copy":
                this.copy();
                break;
            case "cut":
                if (this.cut())
                    this.redraw();
                break;
            case "paste":
                if (this.paste())
                    this.redraw();
                break;
            case "fliph":
                this.flip("hori");
                break;
            case "flipv":
                this.flip("vert");
                break;
            case "reaxys":
            case "scifinder":
            case "pubchem":
            case "chemspider":
                this.sendQuery(cmd);
                useonce = true;
                break;
            case "chemdraw":
                JSDraw2.ChemdrawPopup.show(this);
                useonce = true;
                break;
            case "eraser":
                if (!this.onDel())
                    useonce = false;
                break;
            case "...":
            case "more":
                this.showPT();
                useonce = false;
                break;
            case "pastechemdraw":
                JSDraw2.ChemDraw.paste(this);
                break;
            case "copychemdraw":
                JSDraw2.ChemDraw.copy(this);
                break;
            case "symbol":
                this.showSymbolDlg();
                break;
            case "template.[custom]":
                this.showTemplatesDlg();
                useonce = false;
                break;
            case "tlctemplate":
                JSDraw2.TLCTemplates.show(true, this);
                break;
            case "tlcnumber":
                this.numberTlcPlates();
                break;
            case "fullscreen":
            case "fullscreen2":
                if (JSDraw2.Fullscreen != null)
                    JSDraw2.Fullscreen.show(this);
                useonce = true;
                break;
            case "helm_import":
                if (this.helm != null)
                    this.helm.showImportDlg();
                useonce = true;
                break;
            case "helm_find":
                if (this.helm != null)
                    this.helm.showFindReplaceDlg();
                useonce = true;
                break;
            case "helm_mex":
                if (this.helm != null)
                    scil.helm.MonomerExplorer.showDlg(this);
                useonce = true;
                break;
            case "helm_layout":
                if (this.helm != null)
                    this.helm.clean(null, true);
                useonce = true;
                break;
            default:
                useonce = false;
                break;
        }

        if (!useonce)
            this.onCmd2(td);
    },

    onCmd2: function (td) {
        var cmd = this.getCmd(td);
        if (cmd == "rxnmap") {
            var rxn = this.m.parseRxn();
            if (rxn == null || rxn.reactants.length == 0 || rxn.products.length == 0) {
                scil.Utils.alert("Please draw a completed reaction first.");
                return;
            }
        }
        var pid = dojo.attr(td, "parent");
        var parent = pid == null ? null : dojo.byId(pid);
        if (parent != null) {
            this.toolbar.exchangeButton(parent, td);
            td = parent;
        }
        if (this.curButton != td) {
            if (this.options.skin == "w8") {
                var me = this;
                if (this.curButton != null) {
                    dojo.style(this.curButton, { backgroundImage: scil.Utils.imgSrc("w8/" + me.options.buttonshape + ".png", true) });
                    this.curButton.removeAttribute("pushed");
                }
                td.setAttribute("pushed", 1);
                dojo.style(td, { backgroundImage: scil.Utils.imgSrc("w8/" + me.options.buttonshape + "0.png", true) });
            }
            else if (this.options.skin == "si") {
                if (this.curButton != null) {
                    dojo.style(this.curButton, { background: "" });
                    this.curButton.removeAttribute("pushed");
                }
                td.setAttribute("pushed", 1);
                dojo.style(td, { background: JSDraw2.Skin.jsdraw.btnselcolor });
            }
            else {
                if (this.curButton != null) {
                    dojo.style(this.curButton, { border: "none", padding: "2px" });
                    //this.curButton.removeAttribute("pushed");
                }
                //td.setAttribute("pushed", 1);
                dojo.style(td, { border: "solid 1px", borderColor: "#c0c0c0 #f5f5f5 #f5f5f5 #c0c0c0", padding: "1px" });
            }
            this.curButton = td;
        }
    },

    flip: function (dir) {
        if (this.m.isEmpty())
            return;

        var list = [];
        var atoms = this.m.atoms;
        for (var i = 0; i < atoms.length; ++i) {
            if (atoms[i].selected)
                list.push(atoms[i]);
        }

        if (list.length == 0) {
            var graphics = this.m.graphics;
            for (var i = 0; i < graphics.length; ++i) {
                if (graphics[i].selected && JSDraw2.Curve.cast(graphics[i]) != null)
                    list.push(graphics[i]);
            }

            if (list.length != 0) {
                this.pushundo();
                for (var i = 0; i < list.length; ++i)
                    list[i].flip();
                this.refresh(true);
                return;
            }
        }

        var flipBond = null;
        var flipaxis = null;
        var center = null;
        if (list.length == 0) {
            center = this.getCenter();
            list = atoms;
        }
        else if (list.length == 1) {
            center = list[0].p.clone();

            var frag = this.getFragment(list[0]);
            if (frag != null)
                list = frag.atoms;
        }
        else {
            if (list.length == 2 && (flipBond = this.m.findBond(list[0], list[1])) != null) {
                center = flipBond.center();

                var frag = this.getFragment(list[0]);
                if (frag != null)
                    list = frag.atoms;
            }
            else {
                var links = this.getConnectingAtomBonds(list);
                if (links.length == 1) {
                    flipBond = links[0].b;
                    center = (flipBond.a1.f ? flipBond.a1 : flipBond.a2).p.clone();
                }
                else if (links.length == 2) {
                    flipaxis = { a1: links[0].a, a2: links[1].a };
                }
                else {
                    center = this.getCenter(list);
                }
            }
        }

        if (flipBond != null)
            flipaxis = { a1: flipBond.a1, a2: flipBond.a2 };

        this.pushundo();
        if (flipaxis != null) {
            var deg = flipaxis.a2.p.angleTo(flipaxis.a1.p);
            center = flipaxis.a1.p.clone();
            this.rotate(list, center, -deg);
            for (var i = 0; i < list.length; ++i) {
                var p = list[i].p;
                p.y = center.y - (p.y - center.y);
            }
            this.rotate(list, center, deg);
        }
        else {
            if (dir == "vert") {
                for (var i = 0; i < list.length; ++i) {
                    var p = list[i].p;
                    p.y = center.y - (p.y - center.y);
                }
            }
            else {
                for (var i = 0; i < list.length; ++i) {
                    var p = list[i].p;
                    p.x = center.x - (p.x - center.x);
                }
            }
        }
        this._invertStereoBonds(list);

        this.refresh(true);
    },

    _invertStereoBonds: function (list) {
        var all = list.length == this.m.atoms.length;
        for (var i = 0; i < this.m.bonds.length; ++i) {
            var b = this.m.bonds[i];
            if (b.type == JSDraw2.BONDTYPES.WEDGE || b.type == JSDraw2.BONDTYPES.HASH) {
                if (scil.Utils.indexOf(list, b.a1) >= 0 || scil.Utils.indexOf(list, b.a2) >= 0) {
                    b.type = b.type == JSDraw2.BONDTYPES.WEDGE ? JSDraw2.BONDTYPES.HASH : JSDraw2.BONDTYPES.WEDGE;
                }
            }
        }
    },

    sendQuery: function (cmd) {
        var smiles = this.getSmiles();
        if (smiles == null || smiles == "") {
            scil.Utils.alert("No query structure drawn");
            return;
        }
        var url;
        switch (cmd.toLowerCase()) {
            case "pubchem":
                url = "http://pubchem.ncbi.nlm.nih.gov/search/search.cgi?cmd=search&q_type=dt&simp_schtp=fs&q_data=";
                break;
            case "chemspider":
                url = "http://www.chemspider.com/Search.aspx?q=";
                break;
            case "reaxys":
                url = "https://www.reaxys.com/reaxys/secured/hopinto.do?context=S&query=";
                break;
            case "scifinder":
                url = "https://www.reaxys.com/reaxys/secured/hopinto.do?context=S&query=";
                break;
            default:
                return;
        }
        url += escape(smiles);
        window.open(url, "_blank");
    },

    onShowOpenFileDlg: function () {
        var me = JSDraw2.Editor;
        if (me.openfiledlg == null) {
            var fileformats = null;
            if (JSDraw2.Security.kEdition == "Lite") {
                if (this.options.toolbarmode == "helm")
                    fileformats = { helm: "HELM", xhelm: "xHELM" };
                else
                    fileformats = { mol: "Mol File" };
            }
            else if (jsd.options.toolbarmode == "tlc")
                fileformats = JSDraw2.JSDrawIO.jsdFiles2;
            else
                fileformats = JSDraw2.JSDrawIO.jsdFiles;

            var fields = { filetype: { label: "File Type", type: "select", items: fileformats }, contents: { label: "Contents", type: "textarea", width: 800, height: 400} };
            me.openfiledlg = scil.Form.createDlgForm("Import File", fields, { label: "Import", onclick: function () { me.onOpenFile(); } });
        }

        var data = {};
        var list = scil.Utils.getDictKeys(me.openfiledlg.form.items.filetype.items);
        if (list.length == 1)
            data = { filetype: list[0] };

        me.openfiledlg.show();
        me.openfiledlg.form.setData(data);
        me.openfiledlg.jsd = this;
    },

    onShowSaveFileDlg: function () {
        var me = JSDraw2.Editor;
        if (me.savefiledlg == null) {
            var fileformats = null;
            if (JSDraw2.Security.kEdition == "Lite") {
                if (this.options.toolbarmode == "helm")
                    fileformats = { helm: "HELM", xhelm: "xHELM" };
                else
                    fileformats = { mol: "Mol File" };
            }
            else if (jsd.options.toolbarmode == "tlc")
                fileformats = JSDraw2.JSDrawIO.jsdFiles2;
            else
                fileformats = JSDraw2.JSDrawIO.jsdFiles;

            var fields = { filetype: { label: "File Type", addblank: false, type: "select", items: fileformats }, contents: { label: "Contents", type: "textarea", width: 800, height: 400 } };
            me.savefiledlg = scil.Form.createDlgForm("Export File", fields, null, {
                onchange: function (field) {
                    if (field == me.savefiledlg.form.fields.filetype) me.onSaveFile();
                }
            });
        }

        var data = {};
        var list = scil.Utils.getDictKeys(me.savefiledlg.form.items.filetype.items);
        if (list.length == 1)
            data = { filetype: list[0] };
        me.savefiledlg.show();
        me.savefiledlg.form.setData(data);
        me.savefiledlg.jsd = this;

        if (list.length == 1)
            me.onSaveFile();
    },

    onPT: function (elem) {
        JSDraw2.Editor.periodictable.hide();
        if (elem != null)
            this.ptElement = elem;
    },

    showPT: function (callback) {
        JSDraw2.needPro();
    },

    showAtomDlg: function (a) {
        JSDraw2.needPro();
    },

    setAtomProps: function (a) {
        JSDraw2.needPro();
    },

    showBondDlg: function (b) {
        JSDraw2.needPro();
    },

    setBondProps: function (b) {
        JSDraw2.needPro();
    },

    /**
    * Set Secptrum JDX data
    * @function setJdx
    * @param {string} data - JDX string
    */
    setJdx: function (data) {
        var m = new JSDraw2.Mol();
        m.setJdx(data, this.bondlength);

        this.setMol(m);
    },

    getData: function (format) {
        if (format == "mol")
            return this.getMolfile();
        else if (format == "mol3000")
            return this.getMolfile(true);
        else if (format == "rxn")
            return this.getRxnfile();
        else if (format == "rxn3000")
            return this.getRxnfile(null, true);
        else if (format == "xml")
            return this.getXml();
        else if (format == "helm")
            return this.getHelm();
        else if (format == "xhelm")
            return this.getXHelm();
        else if (format == "smiles")
            return this.m.getSmiles();
        else if (format == "helm")
            return this.getHelm();
        else if (format == "xhelm")
            return this.getXHelm();
        else
            return null;
    },

    setData: function (data, format) {
        this.setFile(data, format);
    },

    /**
    * Load file data
    * @function setFile
    * @param {string} data - the file contents
    * @param {string} filetype - the file type: mol, rxn, xml.  Other file types can be loaded with JSDraw.WebServices
    * @returns the Mol object loaded
    */
    setFile: function (data, filetype) {
        var m = null;
        if (filetype == "mol")
            m = this.m.setMolfile(data);
        else if (filetype == "rxn")
            m = this.m.setRxnfile(data);
        else if (filetype == "xml")
            m = this.m.setXml(data);
        else if (filetype == "helm") {
            this.setHelm(data);
            return;
        }
        else if (filetype == "xhelm") {
            this.setXHelm(data);
            return;
        }
        else if (filetype == "jdx")
            m = this.m.setJdx(data, this.bondlength);
        else
            return;

        if (m == null) {
            this.clear(true);
            return;
        }

        this.setMol(m);
        return this.m;
    },

    /**
    * Load a Mol object
    * @function setMol
    * @param {Mol} mol - the Mol object to be loaded
    * @returns true or false
    */
    setMol: function (mol) {
        if (mol != null && typeof (mol) == "object" && mol.T == "MOL") {
            this.m = mol;
            this.m.showimplicithydrogens = this.options.showimplicithydrogens;
            if (this.options.removehydrogens)
                this.m.removeHydrogens();
            this.m.calcHCount();
            this.m.toScreen(this.bondlength);
            this.fitToWindow();
            this._setmol(this.m);
            this.refresh(true);
            return true;
        }
        return false;
    },

    /**
    * Load a molfile
    * @function setMolFile
    * @param {string} molfile - the mol file contents
    * @returns null
    */
    setMolfile: function (molfile) {
        this.setFile(molfile, "mol");
    },

    /**
    * Load a rxnfile
    * @function setRxnFile
    * @param {string} rxnfile - the rxn file contents
    * @returns null
    */
    setRxnfile: function (rxnfile) {
        this.setFile(rxnfile, "rxn");
    },

    /**
    * Get molfile data
    * @function getMolfile
    * @param {bool} v3000 - indicate if rendering it in mol v3000 format
    * @returns the molfile string
    */
    getMolfile: function (v3000, excludeDummyBonds) {
        this.m.bondlength = this.bondlength;
        return this.m.getMolfile(false, v3000, excludeDummyBonds);
    },

    /**
    * Get SVG data
    * @function getSvg
    * @returns the svg string
    */
    getSvg: function () {
        var g = dojox.gfx;
        if (g.renderer != "svg")
            return null;

        var r = this.m.rect();
        r.inflate(20, 20);
        var gu = dojox.gfx.utils;
        this.m.offset(-r.left, -r.top);
        this.redraw();
        var xml = gu._cleanSvg(gu._innerXML(this.surface.rawNode));
        this.m.offset(r.left, r.top);
        this.redraw();
        xml = xml.replace(/ width="[0-9]+"/, " width=\"" + Math.round(r.width) + "\"");
        xml = xml.replace(/ height="[0-9]+"/, " height=\"" + Math.round(r.height) + "\"");
        return xml;
    },

    /**
    * Get JSDraw Xml data
    * @function getXml
    * @param {number} width - the view width
    * @param {number} height - the view height
    * @param {bool} viewonly - indicate if it is viewonly mode
    * @returns a string
    */
    getXml: function (width, height, viewonly, withsvg) {
        var svg = null;
        try {
            svg = withsvg ? this.getSvg() : null;
        }
        catch (e) {
        }

        this.m.bondlength = this.bondlength;
        return this.m.getXml(width > 0 ? width : this.dimension.x, height > 0 ? height : this.dimension.y, viewonly, svg, this.bondlength);
    },

    getHtml: function (width, height, viewonly, withsvg) {
        return this.getXml(width, height, viewonly, withsvg);
    },

    getSequence: function (highlightselection) {
        return this.helm == null ? null : this.helm.getSequence(highlightselection);
    },

    getHelm: function (highlightselection) {
        return this.helm == null ? null : this.helm.getHelm(highlightselection);
    },

    setHelm: function (s) {
        return this.helm == null ? null : this.helm.setHelm(s);
    },

    getXHelm: function () {
        return this.helm == null ? null : this.helm.getXHelm();
    },

    setXHelm: function (s) {
        return this.helm == null ? null : this.helm.setXHelm(s);
    },

    /**
    * Set JSDraw Xml data
    * @function setXml
    * @param {string} xml - the JSDraw Xml string
    * @returns the Mol object loaded
    */
    setXml: function (xml, setmodified) {
        var doc = typeof (xml) == "string" ? scil.Utils.parseXml(xml) : xml;
        if (doc == null) {
            if (typeof (xml) == "string" && xml.indexOf("M  END") > 0)
                return this.setMolfile(xml);
            return;
        }

        if (this.helm != null && this.helm.isXHelm(doc)) {
            this.setXHelm(doc);
            return;
        }

        this.clear();
        var root = null;
        if (typeof (xml) == "string")
            root = doc == null ? null : (doc.documentElement || doc.firstElementChild);
        else
            root = xml;
        this.m.setXml(root);

        this.m.calcHCount();
        if (this.m.bondlength > 0) {
            this.m.scale(JSDraw2.Editor.BONDLENGTH / this.m.bondlength);
            this.resetScale();
        }
        else {
            this.m.toScreen(this.bondlength);
        }
        this.fitToWindow();
        this._setmol(this.m);
        this.refresh(setmodified == null ? true : setmodified);
        return this.m;
    },

    setHtml: function (xml) {
        return this.setXml(xml);
    },

    /**
    * Get Rxnfile
    * @function getRxnfile
    * @param {bool} groupbyplus - indicate if grouping reactants/products based on explicit plus signs
    * @param {bool} v3000 - indicate if rendering in v3000 format
    * @returns a string
    */
    getRxnfile: function (groupbyplus, v3000) {
        return this.m.getRxnfile(groupbyplus, v3000);
    },

    /**
    * Get SMILES
    * @function getSmiles
    * @returns a string
    */
    getSmiles: function () {
        return this.m.getSmiles();
    },

    setMolbase64: function (molfile) {
        var s = JSDraw2.Base64.decode(molfile);
        this.setMolfile(s);
    },

    setRxnbase64: function (rxnfile) {
        var s = JSDraw2.Base64.decode(rxnfile);
        this.setRxnfile(s);
    },

    getMolbase64: function () {
        var s = this.m.getMolfile();
        return JSDraw2.Base64.encode(s);
    },

    hasHelmNodes: function () {
        if (this.helm == null)
            return false;

        for (var i = 0; i < this.m.atoms.length; ++i) {
            if (scil.helm.isHelmNode(this.m.atoms[i]))
                return true;
        }

        return false;
    },

    /**
    * Get Formula
    * @function getFormula
    * @param {bool} html - indicate if rendering Formula in HTML format
    * @returns a string
    */
    getFormula: function (html) {
        if (this.hasHelmNodes())
            return this.helm.getMF(html);
        else
            return this.m.getFormula(html);
    },

    /**
    * Get molecular weight
    * @function getMolWeight
    * @returns a number
    */
    getMolWeight: function () {
        if (this.hasHelmNodes())
            return this.helm.getMW();
        else
            return this.m.getMolWeight();
    },

    /**
    * Get Extinction Coefficient
    * @function getExtinctionCoefficient
    * @returns a number
    */
    getExtinctionCoefficient: function () {
        if (this.hasHelmNodes())
            return this.helm.getExtinctionCoefficient();
        else
            return null;
    },

    /**
    * Get exact mass
    * @function getExactMass
    * @returns a number
    */
    getExactMass: function () {
        return this.m.getExactMass();
    },

    setAny: function (s, fmt) {
        if (!scil.Utils.serviceAvailable() || s == null || s.length == 0)
            return;

        var me = this;
        var xhrArgs = {
            url: scil.Utils.scriptUrl() + "Service.aspx?cmd=tomolfile",
            postData: "input=" + escape(s) + "&fmt=" + escape(fmt),
            handleAs: "json",
            load: function (ret) {
                if (ret.success) {
                    me.pushundo(me.clone());
                    me.setMolfile(ret.result);
                }
                else {
                    scil.Utils.alert(ret.error);
                }
            },
            error: function (ret) {
                scil.Utils.alert(ret.message);
            }
        };

        var deferred = dojo.rawXhrPost(xhrArgs);
    },

    /**
    * Highlight a query structure
    * @function highlight
    * @param {string or Mol} query - the query structure
    * @returns true or false
    */
    highlight: function (query) {
        var q = null;
        if (typeof query == "string")
            q = new JSDraw2.Mol(this.options.showimplicithydrogens).setMolfile(query);
        else
            q = query.T == "MOL" ? query : query.m;
        if (q == null)
            return false;

        var target = this;
        var map = q.aamap(target.m, false, true);
        target.redraw();
        return map != null;
    },

    /**
    * Perform a sub-structure search using this molecule as the query
    * @function highlight
    * @param {Editor} target - the target structure
    * @returns true or false
    */
    sss: function (target) {
        return target.highlight(this);
    },

    res: function (s) {
        return JSDraw2.Language.res(s);
    },

    isSkinW8: function () {
        return this.options.skin == "w8" || this.options.skin == "si";
    },

    download: function (url, filetype) {
        var me = this;
        var callback = function (data) {
            if (data.ret != null)
                me.setFile(data.ret.molfile, filetype);
            else
                me.setFile(data, filetype);
        };
        scil.Utils.download(url, callback);
    },

    /**
    * Write the current structure into a cookie, so it can be reloaded next time
    * @function writeCookie
    * @param {string} name - cookie name
    * @param {number} days - cookie valid days
    * @returns null
    */
    writeCookie: function (name, days) {
        if (name == null || name.length == 0)
            name = "__jsdraw_cookie_structure";
        if (!(days > 0))
            days = 30;
        var html = this.getXml();
        scil.Utils.createCookie(name, html, days);
    },

    /**
    * Read the structure from a saved cookie
    * @function readCookie
    * @param {string} name - cookie name
    * @returns null
    */
    readCookie: function (name) {
        if (name == null || name.length == 0)
            name = "__jsdraw_cookie_structure";
        var html = scil.Utils.readCookie(name);
        this.setXml(html);
    },

    /**
    * Destory the editor
    * @returns null
    */
    destroy: function () {
        this.div = null;
        this.curObject = null;
        this.curButton = null;
        this.texteditor = { input: null, text: null, atom: null };
        this.maintable = null;
        if (this.toolbar != null) {
            this.toolbar.destroy();
            this.toolbar = null;
        }
        if (this.surface != null) {
            try {
                this.surface.destroy();
            }
            catch (e) {
            }
            this.surface = null;
        }
        for (var i = 0; i < this.connectHandlers.length; ++i)
            dojo.disconnect(this.connectHandlers[i]);
        this.connectHandlers = null;
    },

    bodyMouseDown: function (e) {
        var src = e.target || e.srcElement;
        if (this.texteditor.ed != null && this.texteditor.ed.isVisible() && !(this.texteditor.ed.isChildOf(src) || JSDraw2.Symbol != null && JSDraw2.Symbol.isFrom(src))) {
            this.hideTextEditor();
            return;
        }

        if (this.texteditor.ed != null && this.texteditor.ed.isChildOf(src) || this.contextmenu != null && this.contextmenu.isFrom(src))
            return;

        var dlg = scil.Dialog.getDialog(src);
        if (dlg != null && dlg.owner == this)
            return;

        if (this._testdeactivation != null) {
            if (this._testdeactivation(e, this))
                return;
        }

        var f = scil.Utils.hasAnsestor(src, this.surface.children[0].rawNode) || this.isFromSvgGroup(src) || scil.Utils.hasAnsestor(src, this.maintable);
        //var f = src.__gfxObject__ != null || scil.Utils.hasAnsestor(src, this.maintable);
        if (this.activated) {
            if (!f)
                this.activate(false);
        }
        else {
            if (f)
                this.activate(true);
        }
    },

    isFromSvgGroup: function (src) {
        if (dojox.gfx.renderer != "svg")
            return false;
        var g = scil.Utils.getParent(src, "g");
        return g != null && g.getAttribute("__surface_parentid") == this.id;
    },

    bodyTouchStart: function (e) {
        if (this.activated && e.touches.length > 0) {
            var te = e.touches[0];
            var src = te.target || te.srcElement;
            if (!scil.Utils.hasAnsestor(src, this.maintable))
                this.activate(false);
        }
        this.bodyMouseDown(e);
    },

    //    bodyClick: function (e) {
    //    },

    touchClick: function (e) {
        if (!this.activated) {
            this.activate(true);
            e.preventDefault();
            return false;
        }
    },

    touch: {
        reset: function (jsd) {
            if (this.cloned != null) {
                jsd.pushundo(this.cloned);
                jsd.setModified(true);
            }
            this.center = null;
            this.start1 = null;
            this.start2 = null;
            this.end1 = null;
            this.end2 = null;
            this.gesture = null;
            this.deg = null;
            this.scale = null;
            this.cloned = null;
        }
    },

    resetGesture: function () {
        this.touch.reset(this);
    },

    holding: {
        delay: 1000,
        tor: 2,
        e: null,
        tm: null,
        timer: null,
        jsd: null,

        start: function (e, jsd) {
            if (!scil.Utils.isTouch && !window.navigator.msPointerEnabled)
                return;
            this.end();
            this.e = { clientX: e.clientX, clientY: e.clientY };
            this.tm = new Date().getTime();
            this.jsd = jsd;
            var me = this;
            this.timer = setTimeout(function () { me.timeout(); }, this.delay);
        },

        end: function () {
            if (this.timer == null)
                return;
            this.e = null;
            this.tm = null;
            clearTimeout(this.timer);
            this.timer = null;
        },

        timeout: function () {
            if (this.e != null) {
                this.jsd.start = null;
                this.jsd.showContextMenu(this.e, this.jsd.options.viewonly);
            }
            this.end();
        },

        move: function (e) {
            if (this.e != null && (Math.abs(e.clientX - this.e.clientX) > this.tor || Math.abs(e.clientY - this.e.clientY) > this.tor))
                this.end();
        }
    },

    touchStart: function (e) {
        if (!this.activated)
            return;

        if (JSDraw2.Menu.isOpen()) {
            JSDraw2.Menu.close();
            e.preventDefault();
            return false;
        }

        if (e.touches.length == 1) {
            this.mousedown(e.touches[0]);
            e.preventDefault();
            return false;
        }
        else if (e.touches.length == 2) {
            this.lastmove = null;
            this.resetGesture();

            this.touch.start1 = this.eventPoint(e.touches[0]);
            this.touch.start2 = this.eventPoint(e.touches[1]);
            this.touch.center = new JSDraw2.Point((this.touch.start1.x + this.touch.start2.x) / 2, (this.touch.start1.y + this.touch.start2.y) / 2);

            e.preventDefault();
            return false;
        }
    },

    touchMove: function (e) {
        if (!this.activated)
            return;

        if (e.touches.length == 1) {
            this.mousemove(e.touches[0]);
            e.preventDefault();
            this.resetGesture();
            return false;
        }

        this.holding.end();
        if (this.ink != null)
            this.ink.cancel();

        this.start = null;
        if (e.touches.length == 2) {
            var p1 = this.eventPoint(e.touches[0]);
            var p2 = this.eventPoint(e.touches[1]);
            if (this.touch.start1 == null) {
                this.touch.start1 = p1;
                this.touch.start2 = p2;
                return;
            }

            if (p1.equalsTo(this.touch.end1) && p2.equalsTo(this.touch.end2))
                return;
            this.touch.end1 = p1;
            this.touch.end2 = p2;

            if (this.touch.gesture == null && this.touch.start1 != null && this.touch.start2 != null) {
                var d1 = this.touch.end1.distTo(this.touch.start1);
                var d2 = this.touch.end2.distTo(this.touch.start2);
                if (d1 > 25 || d2 > 25) {
                    var a1 = this.touch.end1.angleTo(this.touch.start1);
                    var a2 = this.touch.end2.angleTo(this.touch.start2);
                    var da = Math.abs(a1 - a2);
                    if (d1 > 8 && d2 > 8 && (da < 30 || Math.abs(da - 360) < 30)) {
                        this.touch.gesture = "moving";
                    }
                    else {
                        var a3 = d1 > 25 ? this.touch.start1.angleAsOrigin(this.touch.end1, this.touch.start2) : this.touch.start2.angleAsOrigin(this.touch.end2, this.touch.start1);
                        if (Math.abs(a3 - 180) < 45 || Math.abs(a3 - 360) < 45)
                            this.touch.gesture = "zooming";
                        else
                            this.touch.gesture = "rotating";
                    }
                    //dojo.byId("Textarea1").value += "d1=" + d1 + ", d2=" + d2 + ", " + a1 + ", " + a2 + ", " + a3 + "\r\n";
                }
            }

            if (this.touch.gesture != null && (!this.touch.end1.equalsTo(this.touch.start1) || !this.touch.end2.equalsTo(this.touch.start2))) {
                if (this.touch.gesture == "zooming") {
                    var dx = this.touch.end1.x - this.touch.start1.x;
                    var dy = this.touch.end2.y - this.touch.start1.y;
                    if (Math.abs(dx) >= this.movingresolution || Math.abs(dy) >= this.movingresolution) {
                        this.touch.scale = this.touch.end1.distTo(this.touch.end2) / this.touch.start1.distTo(this.touch.start2);
                        if (this.touch.cloned == null)
                            this.touch.cloned = this.clone();
                        this.scale(this.touch.scale, this.touch.center);
                        this.touch.start1 = this.touch.end1;
                        this.touch.start2 = this.touch.end2;
                        this.redraw();
                        //this.surface.rootgroup.setTransform([dojox.gfx.matrix.scaleAt(this.touch.scale, this.touch.scale, this.touch.center.x, this.touch.center.y)]);
                    }
                }
                else if (this.touch.gesture == "moving") {
                    var dx = this.touch.end1.x - this.touch.start1.x;
                    var dy = this.touch.end1.y - this.touch.start1.y;
                    if (Math.abs(dx) >= this.movingresolution || Math.abs(dy) >= this.movingresolution) {
                        if (this.touch.cloned == null)
                            this.touch.cloned = this.clone();
                        this.m.offset(dx, dy);
                        this.touch.start1 = this.touch.end1;
                        this.redraw();
                        //this.surface.rootgroup.setTransform([dojox.gfx.matrix.translate(this.touch.end1.x - this.touch.start1.x, this.touch.end1.y - this.touch.start1.y)]);
                    }
                }
                else if (this.touch.gesture == "rotating") {
                    var a1 = this.touch.start2.angleAsOrigin(this.touch.start1, this.touch.end1);
                    var a2 = this.touch.start1.angleAsOrigin(this.touch.start2, this.touch.end2);
                    if (a1 > 180)
                        a1 -= 360;
                    if (a2 > 180)
                        a2 -= 360;
                    if ((Math.abs(a1) >= 1 || Math.abs(a2) >= 1) && Math.abs(a1) < 30 && Math.abs(a2) < 30) {
                        var s = Math.abs(a2) / (Math.abs(a1) + Math.abs(a2));
                        var x = this.touch.start1.x + (this.touch.start2.x - this.touch.start1.x) * s;
                        var y = this.touch.start1.y + (this.touch.start2.y - this.touch.start1.y) * s;
                        this.m.rotate(new JSDraw2.Point(x, y), Math.abs(a1) > Math.abs(a2) ? a1 : a2);
                        this.touch.start1 = this.touch.end1;
                        this.touch.start2 = this.touch.end2;
                        this.redraw();
                    }
                }
            }
            e.preventDefault();
            return false;
        }

        this.resetGesture();
    },

    touchEnd: function (e) {
        if (!this.activated)
            return;

        this.resetGesture();
        this.mouseup(e);
        return false;
    },

    /**
    * Activate the editor and set focus
    * @function activate
    * @param {bool} f - indicate setting focus or name
    * @param {bool} show - indicate if redrawing the structure
    * @returns null
    */
    activate: function (f, show) {
        if (this.activated == f || this.maintable == null)
            return;

        this.activated = f;
        if (f) {
            if (JSDraw2.__currentactived != this && JSDraw2.__currentactived != null)
                JSDraw2.__currentactived.activate(false);
            JSDraw2._currentactived = this;
        }

        if (window.navigator.msPointerEnabled) {
            if (f) {
                if (document.body.style.overflow != "hidden") {
                    this._msContentZooming = document.body.style.msContentZooming;
                    this._overflow = document.body.style.overflow;
                    document.body.style.msContentZooming = "none";
                    document.body.style.overflow = "hidden";
                }
            }
            else {
                if (document.body.style.overflow != this._overflow) {
                    document.body.style.msContentZooming = this._msContentZooming;
                    document.body.style.overflow = this._overflow;
                }
            }
        }

        if (!f && this.contextmenu != null)
            this.contextmenu.hide();

        if (show == false)
            return;

        if (this.options.focusbox != false)
            this.maintable.style.borderColor = f ? (this.options.focuscolor == null ? "#5555ff" : this.options.focuscolor) : "#cccccc";
        if (!f && this.curObject != null) {
            this.curObject = null;
            this.redraw();
        }

        if (this.options.onfocus != null)
            this.options.onfocus(f);
    }
});

scilligence.apply(JSDraw2.Editor, {
    __xcode: 91,
    undoGestureTime: 300,
    dblclickdelay: 300,
    BONDLENGTH: 30.0,
    ANGLESTOP: 30.0,
    LINEWIDTH: 2.0,
    TOR: 10.0,
    FONTSIZE: 14.0,

    /**
    * Get the Editor object by its ID
    * @function {static} get
    * @param {string} id - the Editor ID
    * @returns the Editor object
    */
    get: function (id) {
        if (JSDraw2.Editor._allitems == null)
            JSDraw2.Editor._allitems = {};
        return id == null ? null : JSDraw2.Editor._allitems[id];
    },

    getClipboard: function () {
        var data = scil.Utils.readCookie("__jsdrawclipboard");
        if (data == null || data == "")
            return null;

        data = JSDraw2.Base64.decode(data);
        var m = new JSDraw2.Mol();
        if (m.setXml(data) == null || m.isEmpty())
            return null;

        //scil.Utils.createCookie("__jsdrawclipboard", "");
        return m;
    },

    setClipboard: function (m, bondlength) {
        if (m != null && !m.isEmpty()) {
            scil.Utils.createCookie("__jsdrawclipboard", JSDraw2.Base64.encode(m.getXml(null, null, null, null, bondlength)));
            return true;
        }

        scil.Utils.alert("Nothing placed on clipboard.");
        return false;
    },

    /**
    * Show JSDraw About box
    * @function {static} showAbout
    * @returns null
    */
    showAbout: function () {
        if (JSDraw2.Editor.about == null) {
            var div = scil.Utils.createElement(null, "div", null, { width: "430px", color: "black" });
            scil.Utils.createElement(div, "img", null, null, { src: scil.Utils.imgSrc("img/jsdraw2.jpg") });

            var lic;
            if (JSDraw2.Security.kEdition == "Lite") {
                lic = "<span style='color:red'>JSDraw Lite for HELM</span>";
            }
            else {
                var exp = JSDraw2.Security.lic == null ? null : JSDraw2.Security.lic.expiration;
                lic = JSDraw2.Security.error != null ? JSDraw2.Security.error : "Licensed to <b>" + JSDraw2.Security.lic.licensor + "</b>, expires on " + exp.getFullYear() + "-" + (exp.getMonth() + 1) + "-" + exp.getDate();
                if (!JSDraw2.Security.valid)
                    lic = "<span style='color:red'>" + lic + "</span>";
            }

            scil.Utils.createElement(div, "div", lic, { textAlign: "right" });
            var tbody = scil.Utils.createTable(div, null, null, { borderTop: "solid 1px gray", width: "100%" });
            var tr = scil.Utils.createElement(tbody, "tr");
            scil.Utils.createElement(tr, "td", JSDraw2.version);
            scil.Utils.createElement(tr, "td", "<a target='_blank' href='http://www.jsdraw.com'>http://www.jsdraw.com</a>", { textAlign: "right" });
            var btn = scil.Utils.createElement(scil.Utils.createElement(div, "div", null, { textAlign: "center" }), "button", "OK", { width: scil.Utils.buttonWidth + "px" });

            JSDraw2.Editor.about = new JSDraw2.Dialog(JSDraw2.Language.res("About JSDraw"), div);
            scil.connect(btn, "onclick", function (e) { JSDraw2.Editor.about.hide(); e.preventDefault(); });
        }
        JSDraw2.Editor.about.show();
    },

    onClickPT: function (elem, id) {
        JSDraw2.Editor.get(id).onPT(elem);
    },

    onSaveFile: function () {
        var fields = JSDraw2.Editor.savefiledlg.form.fields;
        var fmt = fields.filetype.value;
        var txt = fields.contents;
        txt.value = JSDraw2.Editor.savefiledlg.jsd.getData(fmt);
        txt.select();
        txt.focus();
    },

    onOpenFile: function () {
        var fields = JSDraw2.Editor.openfiledlg.form.fields;

        var s = fields.contents.value;
        var fmt = fields.filetype.value;
        JSDraw2.Editor.openfiledlg.jsd.setData(s, fmt);
        JSDraw2.Editor.openfiledlg.hide();
    },

    initNoDelay: function () {
        var list = document.getElementsByTagName("div");
        for (var i = 0; i < list.length; i++) {
            var e = list[i];
            if (dojo.hasClass(e, 'JSDraw')) {
                new JSDraw2.Editor(e);
                dojo.removeClass(e, 'JSDraw');
            }
        }
    },

    /**
    * Initialize all DIV HTML elements and their class marked as JSDraw, and convert all of them into JSDraw Editor<br>
    * This function can be called before document.onload().<br>
    * new JSDraw2.Editor() can only be used in or after document.onload().
    * @function {static} init
    */
    init: function () {
        scil.onload(function () {
            JSDraw2.Editor.initNoDelay();
        });
    },

    /**
    * Create a JSDraw Editor<br>
    * This function can be called before document.onload().<br>
    * new JSDraw2.Editor() can only be used in or after document.onload().
    * @function {static} create
    * @param {string or DOM} id - the ID of DIV placehold, or the DIV DOM object
    * @param {dictonary} options - creating options. Please check Editor contructor for details
    */
    create: function (id, options) {
        dojo.ready(function () { new JSDraw2.Editor(id, options); });
    },

    write: function (id, options) {
        document.writeln("<div id='" + id + "'></div>");
        scil.onload(function () { new JSDraw2.Editor(id, options) });
    },

    showPopupIframe: function (title, btnText, btnFn, value) {
        var newcreated = false;
        var parentWindow = scil.Utils.getTopWindow();
        parentWindow.JSDraw2.Editor.showPopup(title, btnText, btnFn, value);
    },

    getPopupSize: function (win) {
        var args = { width: 800, height: 400 };
        if (JSDraw2.defaultoptions != null) {
            var w = JSDraw2.defaultoptions.popupwidth || JSDraw2.defaultoptions.popupWidth;
            var h = JSDraw2.defaultoptions.popupheight || JSDraw2.defaultoptions.popupHeight;
            var d = scil.Utils.getScreenSize(win); // dojo.window.getBox();
            if (typeof (w) == "string" && w.substr(w.length - 1, 1) == "%")
                args.width = d.w * parseInt(w.substr(0, w.length - 1)) / 100;
            else if (w > 0)
                args.width = s;
            if (typeof (h) == "string" && w.substr(h.length - 1, 1) == "%")
                args.height = d.h * parseInt(h.substr(0, h.length - 1)) / 100;
            else if (h > 0)
                args.height = h;
        }
        return args;
    },

    /**
    * Show JSDraw Poup Editor<br>
    * @function {static} showPopup
    * @param {string} title - the title of the Popup dialog
    * @param {string} btnText - the button text of the Popup dialog
    * @param {function(editor)} btnFn - the callback function when user clicks on the button
    * @param {number} zindex - the zIndex of the dialog DOM
    */
    showPopup: function (title, btnText, btnFn, value, zindex) {
        var args = null;
        if (JSDraw2.Editor.popupdlg == null) {
            args = this.getPopupSize();
            var tbody = scil.Utils.createTable();
            var tr = scil.Utils.createElement(tbody, 'tr');
            var td = scil.Utils.createElement(tr, 'td');
            args.div = scil.Utils.createElement(td, "div", null, { width: args.width + "px", height: args.height + "px" });

            tr = scil.Utils.createElement(tbody, 'tr');
            td = scil.Utils.createElement(tr, 'td', null, { textAlign: "center" });
            var button = scil.Utils.createElement(td, "button", null, { width: scil.Utils.buttonWidth + "px" });
            //var cancel = scil.Utils.createElement(td, "button", scil.Utils.imgTag('cancel.gif', "Cancel", { width: scil.Utils.buttonWidth + "px" });

            JSDraw2.Editor.popupdlg = new JSDraw2.Dialog(title, tbody.parentNode);
            JSDraw2.Editor.popupdlg.button = button;
            //JSDraw2.Editor.popupdlg.cancel = cancel;
        }

        JSDraw2.Editor.popupdlg.show(title, zindex);
        if (args != null) {
            if (JSDraw2.defaultoptions.popupxdraw/* && scil.Utils.isIE */) {
                args.height -= 40;
                args.value = value;
                JSDraw2.Editor.popupdlg.jsd = new scilligence.XDraw(args.div, args);
            }
            else {
                args.div.style.border = "solid 1px #ddd";
                JSDraw2.Editor.popupdlg.jsd = new JSDraw2.Editor(args.div);
                this._loadPopupData(value);
            }

            if (!scil.Utils.isIE || scil.Utils.isIE > 8)
                JSDraw2.Editor.popupdlg.updateWidth();
            //div = null;
            var fn = function (e) {
                var f = true;
                if (JSDraw2.Editor.popupdlg.callback != null) {
                    f = JSDraw2.Editor.popupdlg.callback(JSDraw2.Editor.popupdlg.jsd);
                    JSDraw2.Editor.popupdlg.callback = null;
                }
                if (f != false)
                    JSDraw2.Editor.popupdlg.hide();
                e.preventDefault();
            };
            dojo.connect(JSDraw2.Editor.popupdlg.button, "onclick", fn);
            //var fn2 = function (e) { JSDraw2.Editor.popupdlg.hide(); e.prevendDefault(); };
            //dojo.connect(JSDraw2.Editor.popupdlg.cancel, "onclick", fn2);
        }
        else {
            this._loadPopupData(value);
        }

        JSDraw2.Editor.popupdlg.button.innerHTML = scil.Utils.imgTag("tick.gif", btnText);
        JSDraw2.Editor.popupdlg.callback = btnFn;

        return JSDraw2.Editor.popupdlg.jsd;
    },

    _loadPopupData: function (value) {
        if (value == null) {
            JSDraw2.Editor.popupdlg.jsd.clear(true);
            return;
        }

        if (value.format == "jsdraw" || value.format == "html" || value.format == "xml")
            JSDraw2.Editor.popupdlg.jsd.setXml(value.value);
        else if (value.format == "mol" || value.format == "molfile")
            JSDraw2.Editor.popupdlg.jsd.setMolfile(value.value);
        else if (value.format == "jdx")
            JSDraw2.Editor.popupdlg.jsd.setJdx(value.value);
        else if (value.format == "clone") {
            JSDraw2.Editor.popupdlg.jsd.restoreClone(value.value);
            JSDraw2.Editor.popupdlg.jsd.fitToWindow();
        }
        else
            JSDraw2.Editor.popupdlg.jsd.clear(true);

        JSDraw2.Editor.popupdlg.jsd.refresh();
    }
});

scilligence.mstouch = {
    pointers: {},

    down: function (e) {
        this.pointers[e.pointerId] = { clientX: e.clientX, clientY: e.clientY, target: e.target, button: e.button, pointerId: e.pointerId, _tm: new Date().getTime() };
        e.touches = this.toTouches();
        //dojo.byId("DEBUG").value = "down: " + e.touches.length + "\r\n";
        return e;
    },

    move: function (e) {
        var t = this.pointers[e.pointerId];
        if (t == null)
            return;
        t.clientX = e.clientX;
        t.clientY = e.clientY;
        t._tm = new Date().getTime();
        e.touches = this.toTouches();
        //dojo.byId("DEBUG").value += "move: " + e.touches.length + "\r\n";
        return e;
    },

    up: function (e) {
        delete this.pointers[e.pointerId];
        e.touches = this.toTouches();
        //dojo.byId("DEBUG").value += "up: " + e.touches.length + "\r\n";
        return e;
    },

    toTouches: function () {
        var touches = [];
        var tm = new Date().getTime();
        var list = [];
        for (var k in this.pointers) {
            if (this.pointers[k]._tm > tm - 5000)
                touches.push(this.pointers[k]);
            else
                list.push(k);
        }
        for (var i = 0; i < list.length; ++i)
            delete this.pointers[list[i]];
        touches.sort(function (a, b) { return a.pointerId - b.pointerId; });
        return touches;
    }
};


JSDraw = JSDraw2.Editor;﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

JSDraw2.Table = {
    splitUnit: function (s) {
        if (s == null || s == "&nbsp;")
            return null;
        s = scil.Utils.trim(s);
        if (s.length == 0)
            return null;

        var unit2 = null;
        var unit = null;
        var num = s.replace(/[a-z|\/|%|°]+$/i, "");
        if (num != s) {
            unit2 = s.substr(num.length);
            unit = unit2.toLowerCase();
            num = scil.Utils.trim(num);
        }

        if ((unit == "w/w" || unit == "w/v") && scil.Utils.endswith(num, "%")) {
            num = num.substr(0, num.length - 1);
            unit2 = unit = "% " + unit;
        }

        if (unit == "%w/w")
            unit2 = unit = "% w/w";
        else if (unit == "%w/v")
            unit2 = unit = "% w/v";

        return { value: scil.Utils.trim(num), unit: unit, unit2: unit2 };
    },

    readSdfRecord: function (sdfmol, readattributes) {
        if (sdfmol.substr(0, 1) == "\n")
            sdfmol = sdfmol.substr(1);
        else if (sdfmol.substr(0, 2) == "\r\n")
            sdfmol = sdfmol.substr(2);

        var p = sdfmol.indexOf("\nM  END");
        if (p < 0)
            p = sdfmol.indexOf("\nM END");
        if (p < 0)
            return null;

        var p1 = sdfmol.indexOf("\n", p + 1);
        var molfile = p1 < 0 ? sdfmol : sdfmol.substr(0, p1);
        var s = p1 < 0 ? null : sdfmol.substr(p1 + 1);
        var props = readattributes ? JSDraw2.Table.readProps(s) : null;

        return { molfile: molfile, props: props };
    },

    readProps: function (s) {
        var ret = {};
        if (s == null)
            return ret;

        var ss = s.split('\n');
        for (var i = 0; i < ss.length; ++i) {
            s = ss[i];
            var n = null;
            var v = null;

            if (s.substr(0, 1) == ">") {
                var p = s.indexOf('<', 1);
                if (p > 0) {
                    ++p;
                    var p1 = s.indexOf('>', p);
                    if (p1 > 0)
                        n = s.substr(p, p1 - p);
                }

                for (++i; i < ss.length; ++i) {
                    s = ss[i];
                    if (scil.Utils.trim(s).length == 0)
                        break;
                    if (v == null)
                        v = s;
                    else
                        v += s;
                }
            }

            if (n != null)
                ret[scil.Utils.trim(n)] = scil.Utils.trim(v);
        }

        return ret;
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////



/**
* Bracket class
* @class scilligence.JSDraw2.Bracket
*/
JSDraw2.Bracket = scilligence.extend(scilligence._base, {
    constructor: function (type, rect, shape) {
        this.T = "BRACKET";
        this.atoms = [];
        this.type = type;
        this._rect = rect;
        this.color = null;
        this.shape = shape;
    },

    clone: function () {
        var b = new JSDraw2.Bracket(this.type, this._rect.clone(), this.shape);
        b.color = this.color;
        b.sgrouptexts = this.sgrouptexts;
        return b;
    },

    getXbonds: function (m) {
        var list = [];
        var bonds = m.bonds;
        for (var i = 0; i < bonds.length; ++i) {
            var b = bonds[i];
            var f1 = scil.Utils.indexOf(this.atoms, b.a1) >= 0;
            var f2 = scil.Utils.indexOf(this.atoms, b.a2) >= 0;
            if (f1 != f2)
                list.push(b);
        }

        return list;
    },

    allAtomsIn: function (m) {
        if (this.atoms.length == 0)
            return false;
        for (var i = 0; i < this.atoms.length; ++i) {
            if (m.atoms.indexOf(this.atoms[i]) < 0)
                return false;
        }
        return true;
    },

    getTypeNum: function () {
        if (this.type == null)
            return null;
        var type = this.type + "";
        if (type.match(/^[c][0-9]+$/))
            return type.substr(1);
        //        else if (type.match(/^[0-9]+$/))
        //            return type;
        return null;
    },

    getType: function () {
        if (this.type == null)
            return "";
        var type = this.type + "";
        if (type.match(/^[c][0-9]+$/))
            type = "c";
        //        else if (type.match(/^[0-9]+$/))
        //            type = "mul";
        return type;
    },

    getSubscript: function (m) {
        var t = m.getSgroupText(this, "BRACKET_TYPE");
        return t == null ? null : t.text;
    },

    createSubscript: function (m, s) {
        if (scil.Utils.isNullOrEmpty(s))
            return null;

        var t = m.getSgroupText(this, "BRACKET_TYPE");
        if (t != null)
            return t;

        var gap = m.medBondLength(1.56) / 2;
        t = m.setSgroup(this, "BRACKET_TYPE", s, this._rect.right() + gap / 4, this._rect.bottom() - gap);
        return t;
    },

    html: function (scale) {
        //if (this.atoms == null || this.atoms.length == 0)
        //    return;
        var ss = "";

        if (this.atoms != null && this.atoms.length > 0) {
            ss = this.atoms[0].id + "";
            for (var i = 1; i < this.atoms.length; ++i)
                ss += "," + this.atoms[i].id;
        }

        var s = "<i i='" + this.id + "' x='" + this.T + "' t='" + scilligence.Utils.escXmlValue(this.type) + "'";
        if (this.color != null)
            s += " clr='" + this.color + "'";
        if (this.shape != null)
            s += " shape='" + this.shape + "'";
        s += " r='" + this._rect.toString(scale) + "'";
        s += " atoms='" + ss + "'></i>";
        return s;
    },

    flipY: function (y) {
    },

    flipX: function (x) {
    },

    scale: function (s, origin) {
        this._rect.scale(s, origin);
    },

    offset: function (dx, dy) {
        this._rect.offset(dx, dy);
    },

    rect: function () {
        return this._rect;
    },

    toggle: function (p, tor) {
        var r = this._rect;
        if (r == null)
            return;
        var x1 = p.x - r.left;
        var x2 = r.right() - p.x;
        return p.y >= r.top - tor && p.y <= r.bottom() + tor && (x1 >= -tor / 2 && x1 < tor || x2 >= -tor / 2 && x2 < tor);
    },

    drawCur: function (surface, r, color, m) {
        var r2 = this._rect;
        if (r2 == null)
            return;
        var y = r2.center().y;
        surface.createCircle({ cx: r2.left, cy: y, r: r }).setFill(color);
        surface.createCircle({ cx: r2.right(), cy: y, r: r }).setFill(color);

        if (m != null) {
            for (var i = 0; i < this.atoms.length; ++i)
                this.atoms[i].drawCur(surface, r * 0.75, color);
        }
    },

    draw: function (surface, linewidth, m, fontsize) {
        var r = this._rect;

        var color = this.color == null ? "gray" : this.color;
        JSDraw2.Drawer.drawBracket(surface, r, color, linewidth);
    },

    drawSelect: function (lasso) {
        lasso.draw(this, this._rect.fourPoints());
    },

    cornerTest: function (p, tor) {
        return this._rect.cornerTest(p, tor);
    },

    resize: function (corner, d, texts) {
        this._rect.moveCorner(corner, d);
        if (texts == null)
            return;
        switch (corner) {
            case "topleft":
                for (var i = 0; i < texts.topleft.length; ++i)
                    texts.topleft[i]._rect.offset(d.x, d.y);
                for (var i = 0; i < texts.topright.length; ++i)
                    texts.topright[i]._rect.offset(0, d.y);
                for (var i = 0; i < texts.bottomleft.length; ++i)
                    texts.bottomleft[i]._rect.offset(d.x, 0);
                break;
            case "topright":
                for (var i = 0; i < texts.topright.length; ++i)
                    texts.topright[i]._rect.offset(d.x, d.y);
                for (var i = 0; i < texts.topleft.length; ++i)
                    texts.topleft[i]._rect.offset(0, d.y);
                for (var i = 0; i < texts.bottomright.length; ++i)
                    texts.bottomright[i]._rect.offset(d.x, 0);
                break;
            case "bottomleft":
                for (var i = 0; i < texts.bottomleft.length; ++i)
                    texts.bottomleft[i]._rect.offset(d.x, d.y);
                for (var i = 0; i < texts.bottomright.length; ++i)
                    texts.bottomright[i]._rect.offset(0, d.y);
                for (var i = 0; i < texts.topleft.length; ++i)
                    texts.topleft[i]._rect.offset(d.x, 0);
                break;
            case "bottomright":
                for (var i = 0; i < texts.bottomright.length; ++i)
                    texts.bottomright[i]._rect.offset(d.x, d.y);
                for (var i = 0; i < texts.bottomleft.length; ++i)
                    texts.bottomleft[i]._rect.offset(0, d.y);
                for (var i = 0; i < texts.topright.length; ++i)
                    texts.topright[i]._rect.offset(d.x, 0);
                break;
        }
    },

    removeObject: function (obj) {
        var a = JSDraw2.Atom.cast(obj);
        if (a == null)
            return;
        for (var i = 0; i < this.atoms.length; ++i) {
            if (this.atoms[i] == a) {
                this.atoms.splice(i, 1);
                break;
            }
        }
    },

    getTexts: function (m) {
        var ret = { topleft: [], topright: [], bottomleft: [], bottomright: [] };
        var c1 = this._rect.center();
        for (var i = 0; i < m.graphics.length; ++i) {
            var t = JSDraw2.Text.cast(m.graphics[i]);
            if (t == null || t.anchors.length != 1 || t.anchors[0] != this)
                continue;
            var c = t._rect.center();
            if (c.x < c1.x) {
                if (c.y < c1.y)
                    ret.topleft.push(t);
                else
                    ret.bottomleft.push(t);
            }
            else {
                if (c.y < c1.y)
                    ret.topright.push(t);
                else
                    ret.bottomright.push(t);
            }
        }

        return ret;
    }
});

JSDraw2.Bracket.cast = function (a) {
    return a != null && a.T == 'BRACKET' ? a : null;
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////



/**
* Group class - defines Object groups
* @class scilligence.JSDraw2.Group
*/
JSDraw2.Group = scil.extend(scil._base, {
    /**
    * @constructor Group
    * @param {string} name - group name
    * @param {string} type - group type
    */
    constructor: function (name, type) {
        this.T = "GROUP";
        this.type = type;
        this.name = name;
        this.id = null;
        this._rect = null;
        this.p = null;
        this.gap = 6.0;
        this.group = null; // a group can belong to another group
        this.color = null;
        this.a = null;
        this.ratio = null;
        this.tag = null;
    },

    clone: function () {
        var g = new JSDraw2.Group(this.name, this.type);
        g.id = this.id;
        g._rect = this._rect == null ? null : this._rect.clone();
        g.p = this.p == null ? null : this.p.clone();
        g.color = this.color;
        g.gap = this.gap;
        g.ratio = this.ratio;
        g.tag = this.tag;
        return g;
    },

    html: function (scale) {
        var s = "<i i='" + this.id + "' x='" + this.T + "' t='" + scilligence.Utils.escXmlValue(this.type) + "' n='" + this.name + "'";
        if (this.color != null)
            s += " clr='" + this.color + "'";
        if (this.gap > 0)
            s += " gap='" + this.gap + "'";
        s += "></i>";
        return s;
    },

    readHtml: function (e) {
        //this.p = JSDraw2.Point.fromString(e.getAttribute("p"));
        var gap = parseFloat(e.getAttribute("gap"));
        if (gap > 0)
            this.gap = gap;
    },

    flipY: function (y) {
    },

    flipX: function (x) {
    },

    scale: function (s, origin) {
    },

    offset: function (dx, dy) {
    },

    rect: function () {
        return this._rect;
    },

    toggle: function (p, tor) {
        var r = this._rect;
        if (r == null)
            return;
        return p.y >= r.top && p.y <= r.bottom() && (Math.abs(p.x - r.left) < tor / 2 || Math.abs(p.x - r.right()) < tor / 2) ||
            p.x >= r.left && p.x <= r.right() && (Math.abs(p.y - r.top) < tor / 2 || Math.abs(p.y - r.bottom()) < tor / 2);
    },

    drawCur: function (surface, r, color, m) {
        var r2 = this._rect;
        if (r2 == null)
            return;
        var c = r2.center();
        surface.createCircle({ cx: r2.left, cy: c.y, r: r }).setFill(color);
        surface.createCircle({ cx: r2.right(), cy: c.y, r: r }).setFill(color);
        surface.createCircle({ cx: c.x, cy: r2.top, r: r }).setFill(color);
        surface.createCircle({ cx: c.x, cy: r2.bottom(), r: r }).setFill(color);

        if (m != null) {
            for (var i = 0; i < m.atoms.length; ++i) {
                if (m.atoms[i].group != this)
                    continue;
                m.atoms[i].drawCur(surface, r * 0.75, color);
            }
            for (var i = 0; i < m.graphics.length; ++i) {
                if (m.graphics[i].group != this)
                    continue;
                m.graphics[i].drawCur(surface, r * 0.75, color);
            }
        }
    },

    _updateRect: function (m, bondlength) {
        var r = m.getGroupRect(this, bondlength);
        this._rect = r;
        return r;
    },

    draw: function (surface, linewidth, m, fontsize) {
        var r = this._rect;
        if (r == null)
            return;

        var color = this.color == null ? "gray" : this.color;
        //r.inflate(this.gap * linewidth, this.gap * linewidth);
        if (this.type == "chiral") {
            JSDraw2.Drawer.drawLabel(surface, new JSDraw2.Point(r.left + r.width / 2, r.top - fontsize), this.name, color, fontsize, false);
        }
        else {
            JSDraw2.Drawer.drawRect(surface, r, color, linewidth / 4, linewidth * 3); //.setFill("#ffffff");
            JSDraw2.Drawer.drawLabel(surface, new JSDraw2.Point(r.left + r.width / 2, r.bottom() + fontsize / 2), this.name, color, fontsize, false);
        }

        if (!scil.Utils.isNullOrEmpty(this.tag))
            JSDraw2.Drawer.drawLabel(surface, new JSDraw2.Point(r.left, r.top - fontsize), this.tag, "black", fontsize, false, "start");
        if (!scil.Utils.isNullOrEmpty(this.ratio))
            JSDraw2.Drawer.drawLabel(surface, new JSDraw2.Point(r.right(), r.bottom() + fontsize / 2), "ratio: " + this.ratio, "black", fontsize, false, "end");
    },

    drawSelect: function (lasso) {
        lasso.draw(this, this._rect.fourPoints());
    }
});

JSDraw2.Group.cast = function (a) {
    return a != null && a.T == 'GROUP' ? a : null;
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////



/**
* Text class
* @class scilligence.JSDraw2.Text
*/
JSDraw2.Text = scilligence.extend(scilligence._base, {
    /**
    @property {Rect} _rect Position
    */
    /**
    @property {string} text Text value
    */
    /**
    @property {string} color Display Color
    */
    /**
    @property {bool} selected Selecting Flag
    */

    /**
    * @constructor Text
    * @param {Rect} r - the position
    * @param {string} text - text value
    */
    constructor: function (r, text) {
        this.T = "TEXT";
        this._rect = r;
        this.text = text;
        this.color = null;
        this.fontsize = 1.0;
        this.selected = false;
        this.fieldtype = null;
        this.readonly = false;
        this.anchors = [];
        this.italic = null;
    },

    clone: function () {
        var a = new JSDraw2.Text(this._rect.clone(), this.text);
        a.id = this.id;
        a.color = this.color;
        a.fieldtype = this.fieldtype;
        a.readonly = this.readonly;
        a.fontsize = this.fontsize;
        a.italic = this.italic;
        return a;
    },

    allAnchorsIn: function (m) {
        if (this.anchors.length == 0)
            return false;
        for (var i = 0; i < this.anchors.length; ++i) {
            var a = this.anchors[i];
            if (JSDraw2.Atom.cast(a) != null && m.atoms.indexOf(a) < 0 ||
                JSDraw2.Bond.cast(a) != null && m.bonds.indexOf(a) < 0 ||
                JSDraw2.Bracket.cast(a) != null && m.graphics.indexOf(a) < 0)
                return false;
        }
        return true;
    },

    attach: function (obj) {
        // anchors can contain one bracket, or any number of atoms and/or bonds
        if (JSDraw2.Bracket.cast(obj) != null) {
            this.anchors = [obj];
            return true;
        }

        if (JSDraw2.Atom.cast(obj) == null && JSDraw2.Bond.cast(obj) == null)
            return false;

        if (this.anchors.length == 1 && JSDraw2.Bracket.cast(this.anchors[0]) != null)
            this.objects = [];

        for (var i = 0; i < this.anchors.length; ++i) {
            if (this.anchors[i] == obj) {
                this.anchors.splice(i, 1);
                return true;
            }
        }
        this.anchors.push(obj);
        return true;
    },

    html: function (scale) {
        var ss = "";
        for (var i = 0; i < this.anchors.length; ++i)
            ss += (ss == "" ? "" : ",") + this.anchors[i].id;
        var s = "<i i='" + this.id + "' x='" + this.T + "' p='" + this._rect.toString(scale) + "'";
        if (this.color != null && this.color != "")
            s += " clr='" + this.color + "'";
        if (this.fontsize > 0)
            s += " fontsize='" + this.fontsize.toFixed(2) + "'";
        if (this.readonly)
            s += " v='1'";
        if (this.italic)
            s += " italic='1'";
        if (this.fieldtype != null && this.fieldtype != "")
            s += " fieldtype='" + scil.Utils.escXmlValue(this.fieldtype) + "'";
        if (ss != "")
            s += " anchors='" + ss + "'";
        s += ">" + scilligence.Utils.escXmlValue(this.text) + "</i>";
        return s;
    },

    readHtml: function (e, map) {
        var r = JSDraw2.Rect.fromString(e.getAttribute("p"));
        var s = e.getAttribute("s");
        if (s == null)
            s = e.text || e.textContent;
        if (r == null || scil.Utils.isNullOrEmpty(s))
            return false;

        // I#6220: p="27.495 -5.105 570.397 0.901"
        if (r.width > r.height * 100)
            r.width = r.height * 5.0;
        if (r.height > r.height * 100)
            r.height = r.width / 5.0;

        this._rect = r;
        this.text = s;
        this.readonly = scil.Utils.isTrue(e.getAttribute("v"));
        this.italic = scil.Utils.isTrue(e.getAttribute("italic"));
        this.dummy = scil.Utils.isTrue(e.getAttribute("dum"));
        this.fieldtype = e.getAttribute("fieldtype");

        var fontsize = parseFloat(e.getAttribute("fontsize"));
        if (fontsize > 0)
            this.fontsize = fontsize;

        var s2 = e.getAttribute("anchors");
        if (s2 != null && s2 != "") {
            var anchors = [];
            var ss = s2.split(',');
            for (var j = 0; j < ss.length; ++j) {
                var a = map[parseInt(ss[j])];
                if (a != null && (JSDraw2.Atom.cast(a) != null || JSDraw2.Bond.cast(a) != null || JSDraw2.Bracket.cast(a) != null))
                    anchors.push(a);
            }
            this.anchors = anchors;
        }
        return true;
    },

    flipY: function (y) {
    },

    flipX: function (x) {
    },

    scale: function (s, origin) {
        if (this._rect != null)
            this._rect.scale(s, origin);
    },

    offset: function (dx, dy) {
        if (this._rect != null)
            this._rect.offset(dx, dy);
    },

    rect: function () {
        return this._rect == null ? null : this._rect.clone();
    },

    toggle: function (p, tor) {
        return this._rect != null && this._rect.contains(p);
    },

    removeObject: function (obj) {
        for (var i = 0; i < this.anchors.length; ++i) {
            if (this.anchors[i] == obj) {
                this.anchors.splice(i, 1);
                break;
            }
        }
    },

    drawCur: function (surface, r, color, m) {
        var p = this._rect.center();
        surface.createCircle({ cx: p.x, cy: p.y, r: r }).setFill(color);

        if (m != null) {
            for (var i = 0; i < this.anchors.length; ++i)
                this.anchors[i].drawCur(surface, r * 0.75, color);
        }
    },

    draw: function (surface, linewidth, m, fontsize) {
        var s = this.text;
        if (s == null)
            return;

        var r = this._rect;
        var fs = fontsize * (this.fontsize > 0 ? this.fontsize : 1.0);
        var color = this.color == null || this.color.length == 0 ? "black" : this.color;
        var t = JSDraw2.Drawer.drawText(surface, new JSDraw2.Point(r.left, r.top), s, color, fs, null, this.italic);
        r.width = t == null ? 0 : t.getTextWidth();
        r.height = fs + 4;

        //var ss = s.match(/[ ]{0,}[a-z|0-9|*|$|@|?|!][ ]{0,}[=]/gi);
        //if (ss != null) {
        //    var c = ss[0].substr(0, ss[0].indexOf('='));
        //    c = scilligence.Utils.trim(c);
        //    for (var i = 0; i < this.anchors.length; ++i) {
        //        var b = JSDraw2.Bond.cast(this.anchors[i]);
        //        if (b != null)
        //            JSDraw2.Drawer.drawLabel(surface, b.center(), c, color, fontsize * 0.85);
        //    }
        //}
    },

    drawSelect: function (lasso) {
        lasso.draw(this, this._rect.fourPoints());
    }
});

JSDraw2.Text.cast = function (a) {
    return a != null && a.T == 'TEXT' ? a : null;
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Lang class - translate web page into other lanagues
* @class scilligence.Lang
* <pre>
* <b>Example:</b>
*    scil.Lang.use('cn');
*    var s = scil.Lang.res("Print");
* </pre>
*/
scil.Lang = {
    token: "translate",
    key: "scil_lang",
    current: null,
    language: null,
    en: {},
    cn: {},

    add: function (dict, lang) {
        if (dict == null)
            return;

        var dest = lang == null ? this.en : scil.Lang[lang];
        if (dest == null)
            scil.Lang[lang] = {};

        scil.apply(dest, dict);
    },

    setLang: function (lang, reload) {
        if (lang == null || lang == "")
            scil.Utils.createCookie(this.key, "", -1, true);
        else
            scil.Utils.createCookie(this.key, lang, 180, true);
        if (reload)
            window.location.reload()
    },

    use: function (lang) {
        if (lang == null)
            return;
        lang = lang.toLowerCase();
        if (lang == "zh")
            lang = "cn";

        this.language = lang;
        this.current = this[lang];
        if (this.current == null) {
            this.current = this.en;
            this.language = null;
        }

        JSDraw2.Language.use(lang);
    },

    res: function (s, lang) {
        if (scil.Utils.isNullOrEmpty(s) || typeof (s) != "string")
            return s;

        if (lang != null) {
            var dict = this[lang];
            return dict == null || dict[s] == null ? s : dict[s];
        }

        if (this.current == null) {
            var lang = scil.Utils.readCookie(this.key, true);
            if (lang != null && lang != "")
                this.use(lang);

            if (this.current == null && this.lang != null)
                this.use(this.lang);

            if (this.current == null) {
                var lang = window.navigator.userLanguage;
                if (lang != null && lang.length > 2)
                    this.use(lang.substr(0, 2));
                if (this.current == null)
                    this.current = this.en;
            }
        }

        var ret = this.current == null ? null : this.current[s];
        if (ret == null || ret == "")
            ret = JSDraw2.Language.res(s);
        return ret;
    },

    translate: function (parent, tags) {
        if (tags == null || tag == "") {
            this.translate(parent, "span");
        }
        else {
            var ss = tags.split(',');
            for (var i = 0; i < ss.length; ++i)
                this.translate(parent, ss[i]);
        }
    },

    translate2: function (parent, tag) {
        if (tag == null || tag == "")
            return;

        var list = (parent == null ? document : parent).getElementsByTagName(tag);
        if (list == null)
            return;

        for (var i = 0; i < list.length; ++i) {
            var e = list[i];
            if (e.getAttribute(this.token) == null)
                continue;

            var s = this.reg(e.innerHTML);
            if (scil.Utils.isNullOrEmpty(s))
                continue;

            e.innerHTML = s;
        }
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Menu class - Menu Control
* @class scilligence.Menu
*/
scil.Menu = {
    timeout: scilligence.Utils.isTouch || window.navigator.msPointerEnabled ? 2000 : 500,
    closetimer: 0,
    menuitem: null,

    isOpen: function () {
        return scil.Menu.menuitem != null && scil.Menu.menuitem.style.display != "none";
    },

    open: function (id) {
        scil.Menu.cancelclosetime();
        if (scil.Menu.menuitem)
            scil.Menu.menuitem.style.display = 'none';
        scil.Menu.menuitem = document.getElementById(id);
        scil.Menu.menuitem.style.display = '';
    },

    close: function () {
        if (scil.Menu.menuitem)
            scil.Menu.menuitem.style.display = 'none';
    },

    openOrClose: function (id) {
        if (scil.Menu.menuitem == null || scil.Menu.menuitem.style.display == "none")
            this.open(id);
        else
            this.close();
    },

    closetime: function () {
        scil.Menu.closetimer = window.setTimeout(scil.Menu.close, scil.Menu.timeout);
    },

    cancelclosetime: function () {
        if (scil.Menu.closetimer) {
            window.clearTimeout(scil.Menu.closetimer);
            scil.Menu.closetimer = null;
        }
    }
};


JSDraw2.Menu = scil.Menu;
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////



/**
* ContextMenu class
* <pre>
* <b>Example:</b>
*    var callback = function (key, obj) {
*        alert( key + " clicked");
*    };
*
*    var items = [{ caption: "Color", key: "x", callback: function (key) { alert("Color: " + key);  }, children: ["Red", "Blue"] },
*            "Small", "Big"
*        ];
*
*    var menu = new scil.ContextMenu(items, callback, null);
*    function test() {
*        menu.show(100, 100);
*    }
* </pre>
* @class scilligence.ContextMenu
*/
scil.ContextMenu = scil.extend(scil._base, {
    /**
    * @constructor ContextMenu
    * @param {array} items - an array of menu item deifinitions
    * @param {function} callback - callback function
    * @param {Menu} parentMenu - parent menu item
    */
    constructor: function (items, callback, parentMenu, doc, lang) {
        this.document = doc == null ? document : doc;
        this.tbody = null;
        this.callback = callback;
        this.submenus = {};
        this.items = items;
        this.cur = null;
        this.parentMenu = parentMenu;
        this.obj = null;
        this.lang = lang != null ? lang : scil.Lang;
    },

    isFrom: function (e) {
        if (this.tbody == null)
            return false;
        if (scil.Utils.isChildOf(e, this.tbody.parentNode))
            return true;

        for (var k in this.submenus) {
            if (this.submenus[k].isFrom(e))
                return true;
        }

        return false;
    },

    /**
    * Show this context menu
    * @function show
    * @param {number} x - x coordinate
    * @param {number} y - y coordinate
    * @param {object} obj - tagged object
    */
    show: function (x, y, obj, items, left) {
        this.hide();
        this._create(items);
        this.obj = obj;

        var maxZindex = scil.Utils.getMaxZindex();
        var parent = this.tbody.parentNode;
        parent.style.display = "";
        parent.style.zIndex = maxZindex > 0 ? maxZindex + 1 : 100;
        scil.Utils.moveToScreen(x, y, parent, left);
    },

    /**
    * Hide context menu
    * @function hide
    */
    hide: function (hideParent) {
        if (this.tbody == null || this.tbody.parentNode.style.display == "none")
            return false;
        this.tbody.parentNode.style.display = "none";
        for (var k in this.submenus)
            this.submenus[k].hide();
        this.setCur(null);
        if (hideParent && this.parentMenu != null)
            this.parentMenu.hide(hideParent);
        return true;
    },

    /**
    * Check if the menu is visible
    * @function isVisible
    * @returns true or false
    */
    isVisible: function () {
        return this.tbody != null && this.tbody.parentNode.style.display != "none";
    },

    _create: function (items) {
        if (items != null)
            this.items = items;
        if (this.tbody == null) {
            var me = this;
            this.tbody = scil.Utils.createTable(this.document.body, 0, 0, { position: "absolute", display: "none", backgroundColor: "#eee", color: "#000", border: "solid 1px #ddd", boxShadow: JSDraw2.Skin.menu.boxshadow });
            this.tbody.setAttribute("jspopupmenu", "1");
            dojo.connect(this.tbody.parentNode, "onmousedown", function (e) { if (e.button != 2) me.click(e); });
            dojo.connect(this.tbody.parentNode, "onmouseover", function (e) { me.hilit(e); });
            dojo.connect(this.document.body, "onmousedown", function (e) { me.clickOut(e); });
            this._createItems();
        }
        else if (items != null) {
            this._createItems();
        }
    },

    _createItems: function () {
        scil.Utils.removeAll(this.tbody);
        for (var i = 0; i < this.items.length; ++i) {
            var item = this.items[i];
            if (item == "-") {
                if (i == 0 || this.items[i - 1] == "-" || i == this.items.length - 1)
                    continue;
                var tr = scil.Utils.createElement(this.tbody, "tr");
                scil.Utils.createElement(tr, "td", null, { textAlign: "center", width: "20px", backgroundColor: "#f5f5f5" });
                scil.Utils.createElement(tr, "td", "<hr style='margin:0;padding:0'>", { padding: "0 2px 0 2px" }).colSpan = 3;
            }
            else {
                if (typeof item == "string")
                    item = { caption: item };
                if (item.key == null)
                    item.key = item.caption;
                var sub = item.children != null && item.children.length > 0;
                var bg = item.bg == null ? "#eee" : item.bg;
                var tr = scil.Utils.createElement(this.tbody, "tr", null, { backgroundColor: bg }, item.disabled ? null : { menukey: item.key });
                scil.Utils.createElement(tr, "td", item.checked ? "&#10004;" : null, { textAlign: "center", width: "20px", backgroundColor: "#f5f5f5" });
                var style = { padding: "1px 3px 1px 3px", color: item.disabled ? "gray" : "" };
                var s = item.nottranslate ? item.caption : this.lang.res(item.caption);
                if (item.icon != null)
                    s = "<img src='" + item.icon + "'>" + s;
                scil.Utils.createElement(tr, "td", s, style);
                style.fontSize = "75%";
                style.paddingLeft = "10px";
                scil.Utils.createElement(tr, "td", item.shortcut == null ? "" : item.shortcut, style);
                scil.Utils.createElement(tr, "td", sub ? "&rsaquo;" : null, { textAlign: "right", width: "30px", paddingRight: "5px" });

                if (sub)
                    this.submenus[item.key] = new scil.ContextMenu(item.children, item.callback == null ? this.callback : item.callback, this, this.document);
                else
                    delete this.submenus[item.key];
            }
        }
    },

    hilit: function (e) {
        var tr = scil.Utils.getParent(e.srcElement || e.target, "TR");
        if (tr != null && tr.getAttribute("menukey") != null)
            this.setCur(tr);
    },

    setCur: function (tr) {
        if (this.cur != null) {
            this.cur.childNodes[0].style.backgroundColor = "#f5f5f5";
            this.cur.childNodes[1].style.backgroundColor = "";
            this.cur.childNodes[2].style.backgroundColor = "";
            this.cur.childNodes[3].style.backgroundColor = "";
            var sub = this.submenus[this.cur.getAttribute("menukey")];
            if (sub != null)
                sub.hide();
        }

        this.cur = tr;
        if (tr != null) {
            tr.childNodes[0].style.backgroundColor = "#aaf";
            tr.childNodes[1].style.backgroundColor = "#aaf";
            tr.childNodes[2].style.backgroundColor = "#aaf";
            tr.childNodes[3].style.backgroundColor = "#aaf";
            var sub = tr == null ? null : this.submenus[tr.getAttribute("menukey")];
            if (sub != null) {
                var p = scil.Utils.getOffset(tr.childNodes[3], false);
                var p2 = scil.Utils.getOffset(tr.childNodes[0], false);
                sub.show(p.x + tr.childNodes[3].offsetWidth + 1, p.y, null, null, p2.x);
            }
        }
    },

    getCallbackObj: function () {
        return this.parentMenu == null ? this.obj : this.parentMenu.getCallbackObj();
    },

    click: function (e) {
        var tr = scil.Utils.getParent(e.srcElement || e.target, "TR");
        var key = tr == null ? null : tr.getAttribute("menukey");
        if (this.submenus[key] != null)
            return;
        if (key != null && this.callback != null)
            this.callback(key, this.getCallbackObj(), tr.childNodes[0].innerHTML != "");
        this.hide(true);
        e.preventDefault();
    },

    clickOut: function (e) {
        var tbody = scil.Utils.getParent(e.srcElement || e.target, "TBODY");
        if (tbody != null && tbody.getAttribute("jspopupmenu") == "1")
            return;
        this.hide();
    }
});

scil.apply(scil.ContextMenu, {
    isFromContextMenu: function (src) {
        var tbody = scil.Utils.getParent(src, "TBODY");
        return tbody != null && tbody.getAttribute("jspopupmenu") == "1";
    }
});


JSDraw2.ContextMenu = scil.ContextMenu;﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////



/**
* Dialog class
* @class scilligence.Dialog
* <pre>
* <b>Example:</b>
*    // Create a popup dialog
*    var div = scil.Utils.createElement(null, "div");
*    var txt = scil.Utils.createElement(div, "textarea", null, { width: "580px", height: "400px" });
*    var btn = scil.Utils.createElement(
*            scil.Utils.createElement(div, "div", null, { textAlign: "center" }), 
*                "button", "OK", { width: "200px" });
* 
*    var dlg = new scilligence.Dialog("My Dialog", div);
*    dojo.connect(btn, "onclick", function (e) { dlg.hide(); });
*    dlg.show();
* </pre>
*/
scil.Dialog = scil.extend(scil._base, {
    /**
    * @constructor Dialog
    * @param {string} title - defaultdialog title
    * @param {DOM} body - dialog body
    * @param {dictionary} options { parentWindow, noclose, notitle }
    */
    constructor: function (title, body, options) {
        this.options = options == null ? {} : options;
        this.lang = this.options.lang == null ? scil.Lang : this.options.lang;
        this.id = this.options.id;
        if (this.id == null || this.id == "") {
            if (scil.Dialog._idincrease == null)
                scil.Dialog._idincrease = 0;
            this.id = "__jsdialog" + (++scil.Dialog._idincrease);
        }
        if (scil.Dialog._allitems == null)
            scil.Dialog._allitems = {};
        scil.Dialog._allitems[this.id] = this;

        this.parentWindow = this.options.parentWindow == null ? window : this.options.parentWindow;
        this.body = body;
        this.title = title;
        this.WRAPPER = 'content';
        this.dialog = null;
        this.dialogmask = null;
        this.movingSt = null;
    },

    /**
    * Check if the dialog is visible
    * @function isVisible
    * @returns true or false
    */
    isVisible: function () {
        return this.dialog != null && this.dialog.style.display != "none";
    },

    isFrom: function (e) {
        if (!this.isVisible())
            return false;
        return scil.Utils.isChildOf(e, this.dialog);
    },

    show2: function (options) {
        if (options == null)
            options = {};
        this.show(options.title, options.zindex, options.modal, options.immediately, options.owner);
    },

    /**
    * Show dialog
    * @function show
    * @param {string} title - dialog title
    * @param {number} zindex - zIndex of dialog DOM
    * @param {bool} modal - Modal dialog
    * @returns true or false
    */
    show: function (title, zindex, modal, immediately, owner) {
        this.owner = owner;
        if (this.isVisible()) {
            if (title != null && this.dialog.titleElement != null)
                this.dialog.titleElement.innerHTML = this.lang.res(title);
            return;
        }

        if (modal == null)
            modal = true;

        this._create();
        this.movingSt = null;
        if (title != null && this.dialog.titleElement != null)
            this.setTitle(title);
        var maxZindex = scil.Utils.getMaxZindex();
        if (JSDraw2.defaultoptions.minDlgZindex > 0 && maxZindex < JSDraw2.defaultoptions.minDlgZindex)
            maxZindex = JSDraw2.defaultoptions.minDlgZindex;
        var z = zindex == null ? maxZindex + 10 : zindex;
        this.dialog.style.display = "";
        this.dialogmask.style.display = "";
        this.dialogmask.style.minHeight = "100%";
        this.dialogmask.style.height = "100%";
        this.dialogmask.style.width = "100%";
        if (z > 0) {
            this.dialogmask.style.zIndex = z + 1;
            this.dialog.style.zIndex = z + 2;
        }
        if (!modal) {
            this.dialog.style.zIndex = z + 1;
            this.dialogmask.style.display = "none";
        }

        this.dialog.style.borderColor = modal ? "#fff" : JSDraw2.Skin.dialog.bkcolor;
        this.dialog.style.display = "";

        this.moveCenter();
        scil.Dialog.stack.push(this);

        if (this._scilform && this.form != null && this.form.fields != null)
            this.form.focus();

        if (!immediately)
            scil.Animation.zoomin(this.dialog, 1000);
    },

    setTitle: function (title) {
        this.dialog.titleElement.innerHTML = this.lang.res(title);
    },

    moveCenter: function () {
        var d = dojo.window.getBox();
        var width = d.w;
        var height = d.h;
        var left = d.l;
        var top = d.t;
        var dialogwidth = this.dialog.offsetWidth;
        var dialogheight = this.dialog.offsetHeight;
        var topposition = Math.round(top + (height - dialogheight) / 2);
        var leftposition = Math.round(left + (width - dialogwidth) / 2);

        dojo.style(this.dialog, { top: Math.max(top, topposition) + "px", left: Math.max(left, leftposition) + "px" });
        this.scroll();
        this.updateWidth();
    },

    _create: function () {
        if (this.dialog != null)
            return;

        var me = this;
        var topBody = this.parentWindow.document.body;
        var zi = 200;
        var tbody = scilligence.Utils.createTable(topBody, 0, 0, { position: "absolute", borderRadius: "1px", width: w, height: h, zIndex: zi, backgroundColor: JSDraw2.Skin.dialog.bkcolor, boxShadow: JSDraw2.Skin.dialog.boxshadow });
        this.dialog = tbody.parentNode;
        this.dialog.setAttribute("__scilligence_dlg", this.id);

        var tr, td;
        var bordertop = "0";
        if (this.options.notitle) {
            bordertop = "5px";
        }
        else {
            tr = scilligence.Utils.createElement(tbody, "tr", null, { height: "30px" });
            td = scilligence.Utils.createElement(tr, "td", this.lang.res(this.title), { paddingLeft: "5px", fontWeight: "bold", color: scil.App == null || scil.App.config == null ? "" : scil.App.config.text });
            this.dialog.titleElement = td;
            td = scilligence.Utils.createElement(tr, "td", null, { textAlign: "right", verticalAlign: "top" });
            if (!this.options.noclose) {
                var img = scilligence.Utils.createElement(td, "img", null, { cursor: "pointer", marginRight: "5px" }, { title: JSDraw2.Language.res("Close"), src: scil.Utils.imgSrc("img/dlgclose.jpg") });
                dojo.connect(scilligence.Utils.isIpad ? td : img, "onclick", function (e) { me.hide(); e.preventDefault(); });
            }

            if (this.options.movable != false) {
                if (scilligence.Utils.isTouch) {
                    dojo.connect(tr, "ontouchstart", function (e) { if (e.touches.length == 1) me.startMove(e.touches[0]); });
                    dojo.connect(topBody, "ontouchmove", function (e) { if (e.touches.length == 1 && me.move(e.touches[0])) { e.preventDefault(); return false; } });
                    dojo.connect(topBody, "ontouchend", function () { me.endMove(); });
                }
                else {
                    tr.style.cursor = "move";
                    dojo.connect(tr, "onmousedown", function (e) { me.startMove(e); });
                    dojo.connect(topBody, "onmousemove", function (e) { me.move(e); });
                    dojo.connect(topBody, "onmouseup", function () { me.endMove(); });
                }
            }
        }

        tr = scil.Utils.createElement(tbody, "tr");
        td = scil.Utils.createElement(tr, "td", null, { padding: bordertop + " 5px 5px 5px" });
        td.colSpan = 2;

        var w = this.options.width;
        var h = this.options.height;
        var style = { background: "#fff", padding: "5px" };
        if (w > 0 || h > 0)
            scil.apply(style, { width: w > 0 ? w : null, height: h > 0 ? h : null, overflow: "scroll" });

        if (this.options.bodystyle != null)
            scil.apply(style, this.options.bodystyle);

        var div = scil.Utils.createElement(td, "div", null, style);
        if (typeof this.body == "string")
            div.innerHTML = "<div>" + this.body + "</div>";
        else
            div.appendChild(this.body);

        var opacity = this.options.opacity > 0 ? this.options.opacity : 35;
        this.dialogmask = scilligence.Utils.createElement(topBody, 'div', null, { position: "absolute", top: "0", left: "0", minHeight: "100%", height: "100%", width: "100%", background: "#999", opacity: opacity / 100.0, filter: "alpha(opacity=" + opacity + ")", zIndex: zi - 1 });
        dojo.connect(window, "onresize", function () { me.resize(); });
        dojo.connect(window, "onscroll", function () { me.scroll(); });

        // bug: I#5763
        if (this.options.fixtransparentissue && dojox.gfx.renderer == "silverlight") {
            this.dialogmask.style.backgroundColor = "white";
            this.dialogmask.style.opacity = "1.0";
            this.dialogmask.style.filter = "alpha(opacity=100)";
        }
    },

    scroll: function () {
        if (!this.isVisible() || this.dialogmask == null || this.dialogmask.style.display == "none")
            return;
        var d = dojo.window.getBox();
        var right = Math.max(d.w + d.l, this.dialog.offsetLeft + this.dialog.offsetWidth);
        var bottom = Math.max(d.h + d.t, this.dialog.offsetTop + this.dialog.offsetHeight);
        if (this.dialogmask.offsetWidth <= right)
            this.dialogmask.style.width = right + "px";
        if (this.dialogmask.offsetHeight <= bottom)
            this.dialogmask.style.height = bottom + "px";
    },

    resize: function () {
        this.scroll();
    },

    /**
    * Move the dialog to a new position
    * @function move
    * @param {number} x
    * @param {number} y
    */
    moveTo: function (x, y) {
        scil.Utils.moveToScreen(x, y, this.dialog);
    },

    startMove: function (e) {
        this.movingSt = null;
        var src = e.srcElement || e.target;
        if (src.tagName == "IMG")
            return;
        this.movingSt = new JSDraw2.Point(e.clientX, e.clientY);
    },

    move: function (e) {
        if (this.movingSt == null || (e.which || e.button) != 1)
            return false;

        var delta = new JSDraw2.Point(e.clientX - this.movingSt.x, e.clientY - this.movingSt.y);
        var top = scilligence.Utils.parsePixel(this.dialog.style.top) + delta.y;
        var left = scilligence.Utils.parsePixel(this.dialog.style.left) + delta.x;
        this.moveTo(left, top);

        this.movingSt = new JSDraw2.Point(e.clientX, e.clientY);
        return true;
    },

    endMove: function () {
        this.movingSt = null;
    },

    updateWidth: function (f) {
        this.dialog.style.width = (this.dialog.firstChild.firstChild.offsetWidth + 2) + "px";
    },

    /**
    * Hide dialog
    * @function hide
    * @param {bool} immediately - set this to true to skip fading animation
    */
    hide: function (immediately) {
        if (this.options.onhide != null)
            this.options.onhide();

        if (immediately) {
            this.close();
        }
        else {
            var me = this;
            scil.Animation.zoomout(this.dialog, 1000, function () { me.close(); });
        }

        scil.Dialog.stack.pop();
        scil.AutoComplete.hideAll();
    },

    close: function () {
        if (this.dialog == null)
            return;

        this.dialog.style.display = "none";
        this.dialogmask.style.display = "none";
        this.dialogmask.style.width = "0px";
        this.dialogmask.style.height = "0px";
    }
});

scil.apply(scil.Dialog, {
    stack: [],

    keydown: function (e) {
        if (e.keyCode == 27 && this.stack.length > 0)
            this.stack[this.stack.length - 1].hide();
    },

    /**
    * Get the Dialog object by its ID
    * @function {static} get
    * @param {string} id - the dialog ID
    */
    get: function (id) {
        if (scil.Dialog._allitems == null)
            scil.Dialog._allitems = {};
        return scil.Dialog._allitems[id];
    },

    getDialog: function (e) {
        while (e != null) {
            var t = scil.Utils.getParent(e, "TABLE");
            if (t == null)
                return null;

            var id = t.getAttribute("__scilligence_dlg");
            if (id != null)
                return this.get(id);
            e = t.parentNode;
        }
        return null;
    }
});

scil.onload(function () {
    dojo.connect(document.body, "onkeydown", function (e) { scil.Dialog.keydown(e); });
});


JsDialog = JSDraw2.Dialog = scil.Dialog;﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Form class
* @class scilligence.Form
* <pre>
* <b>Constructor Parameters:</b>
* - viewonly: {bool}
* - alternativeforms: {dict}
* - usepostform: {bool}
* - hidelabel: {bool}
* - centerbuttons: {bool}
* - onselectrow: function(item)
* - onchange: function(field, this, args)
* - oncreated: function(form)
*
* items of .render(parent, items, options)
*    Format: { key1: { label, width, render, ... }, key2: { ... }}
*      - align: left|right|center
*      - attibutes: {dict}
*      - autosugesturl: {string}
*      - button: {label, icon, type, onclick}
*      - colspan: {int}
*      - disable: {bool},
*      - formula: {string}, 
*      - icon: {string}
*      - height: {int}
*      - hidelabel: {bool}
*      - labelstyle: {dict}
*      - leading: {string}
*      - label: {string}
*      - padding: {int}
*      - render: function(v, values) { return v; }
*      - required: {bool}
*      - str: {string}
*      - style: {dict}
*      - unit: {string}
*      - value: {string}
*      - viewonly: {bool}
*      - was: {string}, the old key
*      - width: {int}
*      - onenter: function(field)
*      - onclick: function(field, item, form)
*
* Supported Item Types:
*    basic types: hidden, number, text, radio, date, color
*    list types: select, dropdowninput, editableselect, dropdowncheck, multiselect
*    table and text: table, tabtext, richtext, html, plaintext
*    chemistry and biology: jsdraw, jdraw.fm, jsdraw.se, jsdraw.table, plate, sketches, plates
*    file: file, filepath, filelink, filedblink, image, rawfile
*    form: subform
*
* <b>Example 1:</b>
*    &lt;script type="text/javascript"&gt;
*        dojo.ready(function () {
*            var parent = scil.Utils.createElement(document.body, "div");
*            var columns = {
*                mass: { label: "Mass", type: "number", width: 200, unit: "g" },
*                name: { label: "Compound Name", type: "input", width: 600, button: { label: "Test", onclick: function () { alert(99); } } },
*                vendor: { label: "Vendor", type: "select", options: ["Company A", "Company B"], width: 700 }
*            };
*            var form = new scil.Form({ viewonly: false });
*            form.render(parent, columns, { immediately: true });
*        });
*    &lt;/script&gt;
*
* <b>Example 2. File Upload Dialog:</b>
*    &lt;script type="text/javascript"&gt;
*        var fields = {
*            projectcode: { label: "Project Code", required: true, width: 300 },
*            file: { label: "Word File", type: "postfile", attributes: { name: "file"} }
*        };
*        var dlg;
*        dlg = scil.Form.createDlgForm("Import Word", fields, { label: "Import", onclick: function () { dlg.form.post('ajax.ashx?cmd=abc.import', null, function(ret) { } } }, { usepostform: true });
*    &lt;/script&gt;
*
* <b>Example 3. Form Forumla:</b>
*    &lt;script type="text/javascript"&gt;
*        var table;
*        scil.ready(function () {
*            var parent = scil.Utils.createElement(document.body, "div");
*            var columns = {
*                a: { label: "A", type: "number" },
*                b: { label: "B", value: 5, viewonly: true },
*                ab: { label: "A+B", formula: "{a}+{b}", viewonly: true },
*                table: { label: "Table", formula: "cny=scil.Math.round({.usd}/{a},2)", type: "jsdraw.table", columns: [{ key: "usd", type: "float" }, { key: "cny", type: "float" }] },
*                sum: { label: "Sum(USD)", formula: "{table}.getColSum('usd')", viewonly: true },
*                sum2: { label: "Sum(CNY)", formula: "{table}.getColSum('cny')", viewonly: true }
*            };
*            table = new scil.Form({ viewonly: false });
*            table.render(parent, columns);
*        });
*    &lt;/script&gt;
* </pre>
*/
scil.Form = scil.extend(scil._base, {
    /**
    * @constructor Form
    * @param {bool} viewonly - build a viewonly Form
    */
    constructor: function (options) {
        if (typeof (options) == "boolean")
            this.options = { viewonly: options };
        else if (options == null)
            this.options = {};
        else
            this.options = options;

        this.lang = this.options.lang == null ? scil.Lang : this.options.lang;
        this.viewonly = this.options.viewonly;
        this.items = null;
        this.tbody = null;
        this.fields = null;
        this.buttons = null;
    },

    destory: function () {
        this.items = null;
        scil.Utils.removeAll(this.tbody);
        this.tbody = null;
        this.fields = null;
        this.buttons = null;
    },

    /**
    * Collect form data in xml format
    * @function getXml
    * @returns xml string
    */
    getXml: function (nowrapper) {
        var ret = nowrapper ? "" : "<data>\n";
        for (var id in this.fields) {
            var field = this.fields[id];
            var v = scil.Form.getFieldData(field, this.items[id]);
            if (v != null && v != "") {
                ret += "<i n='" + scil.Utils.escXmlValue(id) + "'>";
                if (field.stype == "jsdraw" || field.stype == "xdraw" || field.stype == "jsdraw.table" || field.stype == "jsdraw.se" ||
                    field.stype == "jsdraw.fm" || field.stype == "table" || field.stype == "plate" || field.stype == "plates")
                    ret += v;
                else
                    ret += scil.Utils.escXmlValue(v);
                ret += "</i>\n";
            }
        }
        if (!nowrapper)
            ret += "</data>";
        return ret;
    },

    /**
    * Set form data
    * @function setXml
    * @param {xml} data the form data, *id* is the key
    */
    setXml: function (xml) {
        try {
            var data = scil.Form.xml2Json(xml);
            this.setData(data);
        }
        catch (e) {
            alert("Error raised when setting form data: " + e.message);
        }
    },

    /**
    * Collect form data
    * @function getData
    * @returns the form data as a dictionary, with *id* as the key
    */
    getData: function (includeNullValues) {
        var ret = {};
        for (var id in this.fields) {
            var field = this.fields[id];
            if (field != null && this.items[id].type != "rawfile") {
                var v = scil.Form.getFieldData(field, this.items[id]);
                if (includeNullValues || !scil.Utils.isNullOrEmpty(v))
                    ret[id] = v;
            }
        }
        return ret;
    },

    /**
    * Set form data
    * @function setData
    * @param {dictonary} data the form data, *id* is the key
    */
    setData: function (data, overwritemode) {
        this.setDirty(false);
        for (var id in this.fields) {
            var field = this.fields[id];
            if (field == null)
                continue;

            var v = null;
            if (data != null) {
                v = data[id];
                var item = this.items[id];
                if (v == null && item != null) {
                    if (item.alternativekey != null)
                        v = data[item.alternativekey];
                    if (v == null && item.was != null)
                        v = data[item.was];
                }
            }

            if (overwritemode) {
                if (v != null)
                    scil.Form.setFieldData(field, this.items[id], this.viewonly, v, data);
            }
            else {
                scil.Form.setFieldData(field, this.items[id], this.viewonly, v, data);
            }
        }
        this.setDirty(false);
    },

    /**
    * Set a field value
    * @function setFieldValue
    * @param {string} id - the id of the field
    * @param {string} v - value to be set
    */
    setFieldValue: function (id, v, data) {
        var field = this.fields[id];
        scil.Form.setFieldData(this.fields[id], this.items[id], this.viewonly, v, data);
    },

    /**
    * Clear field values
    * @function clear
    */
    clear: function () {
        this.setData({});
    },

    onchange: function (field, args) {
        this.dirty = true;
        if (this.options.onchange != null)
            this.options.onchange(field, this, args);
        this.onformula(field.getAttribute("key"));
    },

    onformula: function (fieldkey) {
        var vars = [fieldkey];
        while (vars.length > 0) {
            var field = vars[0];
            vars.splice(0, 1);

            for (var k in this.items) {
                var formula = this.items[k].formula;
                if (k == fieldkey || scil.Utils.isNullOrEmpty(formula))
                    continue;

                if (formula.indexOf("{" + field + "}") >= 0) {
                    if (this.updateValueByFormula(k))
                        vars.push(k);
                }
            }
        }
    },

    updateValueByFormula: function (fieldkey) {
        if (this.items[fieldkey] == null)
            return false;

        var formula = this.items[fieldkey].formula;
        if (scil.Utils.isNullOrEmpty(formula))
            return false;

        if (this.items[fieldkey].type == "jsdraw.table") {
            return this.fields[fieldkey].jsd.applyFormula(formula, this);
        }
        else {
            var v = scil.Form.evalFormula(formula, this);
            if (v == null)
                return false;

            var v2 = this.getFieldValue(fieldkey);
            if (v2 == v)
                return false;

            this.setFieldValue(fieldkey, v);
            return true;
        }
    },

    setDirty: function (f) {
        this.dirty = f == null || f == true ? true : false;
    },

    preventUnsaved: function (msg) {
        var me = this;
        scil.connect(window, "onbeforeunload", function (e) {
            if (me.dirty) {
                if (msg == null)
                    msg = "WARNING: Form data are not saved yet.";

                var s = scil.Lang.res(msg);
                if (e != null)
                    e.returnValue = s;
                return s;
            }
        });
    },

    switchForm: function (key) {
        if (this.options.alternativeforms == null)
            return false;

        if (this.alternativeforms == null) {
            this.alternativeforms = {};
            this.alternativeforms[""] = { tbody: this.tbody, fields: this.fields, items: this.items };
        }


        if (this.alternativeforms[key] == null) {
            var items = this.options.alternativeforms[key];
            if (items != null) {
                this.render2(items, this.parent, this.renderoptions);
                this.alternativeforms[key] = { tbody: this.tbody, fields: this.fields, items: this.items };
            }
        }

        var cur = this.alternativeforms[key];
        if (cur == null)
            cur = this.alternativeforms[""];

        this.tbody = cur.tbody;
        this.fields = cur.fields;
        this.items = cur.items;
        for (var k in this.alternativeforms)
            this.alternativeforms[k].tbody.parentNode.style.display = k == key ? "" : "none";
        return true;
    },

    selectrow: function (key) {
        this.highlightrow(this.items[key]);
    },

    onselectrow: function (e) {
        var src = e.target || e.srcElement;
        var td = scil.Utils.getParent(src, "TD");

        var item = null;
        for (var k in this.items) {
            if (this.items[k] != null && (this.items[k].td1 == td || this.items[k].td2 == td)) {
                item = this.items[k];
                break;
            }
        }

        this.highlightrow(item);
    },

    highlightrow: function (item) {
        if (this.currentrow == item)
            return;

        if (this.currentrow != null) {
            this.currentrow.td1.style.backgroundColor = this.currentrowbckcolor;
            if (this.currentrow.td2 != null)
                this.currentrow.td2.style.backgroundColor = "";
        }

        if (item != null) {
            this.currentrowbckcolor = item.td1.style.backgroundColor;
            item.td1.style.backgroundColor = JSDraw2.Skin.form.rowselectcolor;
            if (item.td2 != null)
                item.td2.style.backgroundColor = JSDraw2.Skin.form.rowselectcolor;
        }
        this.currentrow = item;

        if (this.options.onselectrow != null)
            this.options.onselectrow(item);
    },

    /**
    * Render the form
    * @function render
    * @param {string or DOM} parent parent element
    * @param {dict} items field definition
    * @param {immediately: true/false, buttons:[] } options
    */
    render: function (parent, items, options) {
        this.parent = parent;
        this.renderoptions = options;
        this.render2(items, this.parent, this.renderoptions);
    },

    render2: function (items, parent, options) {
        var align = options == null ? null : options.align;
        var buttons = options == null ? null : options.buttons;
        var immediately = typeof (options) == "boolean" ? options : (options == null ? true : options.immediately != false);

        this.tbody = null;
        this.fields = {};
        this.items = {};
        this.buttons = [];

        for (var k in items) {
            var item = items[k];
            if (item == null)
                continue;

            this.items[k] = item;
            if (item.label == null && item.caption != null)
                item.label = item.caption;
            if (JSDraw2.Table != null && scil.Utils.indexOf(JSDraw2.Table.kNumberColumns, item.type) >= 0) {
                item.type = "number";
                if (item.unit == null)
                    item.unit = JSDraw2.Table.kDefaultUnits[item.type];
            }
        }

        if (this.options.usepostform) {
            var div = JsUtils.createElement(parent, "div", "<form method='post' enctype='multipart/form-data'></form>");
            this.postform = div.firstChild;
            parent = this.postform;
        }

        var cols = this.options.cols;
        if (!(cols > 0)) {
            if (!(cols > 1))
                cols = 1;
            for (var id in this.items) {
                var item = this.items[id];
                if (item.colspan > cols)
                    cols = item.colspan;
            }
        }

        var tr = null;
        var colspan = cols;
        this.tbody = scil.Utils.createTable(parent);
        var lastitem = null;
        for (var id in this.items) {
            var item = this.items[id];
            if (typeof (item) == "function") {
                continue;
            }
            else if (item.type == "group") {
                tr = scil.Utils.createElement(this.tbody, "tr");
                colspan = cols;
            }
            else if (lastitem != null && lastitem.type == "group" || !(tr != null && cols > 1 && colspan < cols)) {
                tr = scil.Utils.createElement(this.tbody, "tr");
                colspan = item.colspan > 0 ? item.colspan : 1;
            }
            else {
                colspan += item.colspan > 0 ? item.colspan : 1;
            }

            var field = this.newField(item, tr, immediately, (options == null ? null : options.hidelabel), (options == null ? null : options.vertical));
            if (field != null) {
                item.field = this.fields[id] = field;
                field.setAttribute("key", id)
            }

            if (item.type == "group" && cols > 1)
                item.td1.colSpan = cols * 2;
            else if (item.colspan > 1)
                item.td2.colSpan = (item.td2.colSpan > 0 ? item.td2.colSpan : 1) + (item.colspan - 1) * 2;

            if (field != null && this.options.onenter != null && field.tagName == "INPUT")
                this.connectKeyEnter(field, this.options.onenter);
        }

        if (this.options.onselectrow != null) {
            var me = this;
            dojo.connect(this.tbody.parentNode, "onclick", function (e) { me.onselectrow(e); });
        }

        if (align != null)
            this.tbody.parentNode.setAttribute("align", align);

        if (buttons != null) {
            var tr = scil.Utils.createElement(this.tbody, "tr");
            scil.Utils.createElement(tr, "td", "&nbsp;");
            tr = scil.Utils.createElement(this.tbody, "tr");
            this.buttonTR = tr;

            if (options == null || !options.vertical)
                scil.Utils.createElement(tr, "td");

            var td = scil.Utils.createElement(tr, "td", null, { whiteSpace: "nowrap" });
            if (options.centerbuttons)
                td.style.textAlign = "center";
            if (buttons.length > 0) {
                for (var i = 0; i < buttons.length; ++i) {
                    var b = buttons[i];
                    if (b == " ")
                        scil.Utils.createElement(td, "span", "&nbsp;");
                    else
                        this.buttons.push(scil.Utils.createButton(td, b, this.lang));
                }
            }
            else {
                this.buttons.push(scil.Utils.createButton(td, buttons, this.lang));
            }
        }
    },

    /**
    * Post data, particularly for post form with files
    * @function pst
    * @param {string} url: destination
    * @param {dict} params: extra data
    * @param {function} callback: function(ret) {}
    * <b>Example</b>
    * <pre>
    *    &lt;script type="text/javascript"&gt;
    *        var fields = {
    *            file: { label: "Select Files", type: "rawfile", attributes: { multiple: "multiple" } },
    *            attachtype: { label: "Attachment Type", type: "select", items: scil.Config.attachtypes }
    *        };
    *
    *        var dlg = scil.Form.createDlgForm("Upload Files", fields, { label: "Upload", onclick: function (e) {
	*	        e.preventDefault(); dlg.form.post("http://localhost/ajax.ashx?cmd=test", {name:"Scilligence"}, function(ret) { alert(ret); } )
	*        } }, { usepostform: true });
    *    &lt;/script&gt;
    * </pre>
    */
    post: function (url, params, callback) {
        if (this.postform == null)
            return;

        for (var k in this.fields) {
            var f = this.fields[k];
            if (scil.Utils.isNullOrEmpty(f.getAttribute("name")))
                f.setAttribute("name", k);
        }

        scil.Utils.ajaxUploadFile(this.postform, url, params, callback);
    },

    postForm: function (url, params, callback) {
        this.post(url, params, callback);
    },

    /**
    * Check required fields
    * @function checkRequiredFields
    */
    checkRequiredFields: function () {
        var fields = this.fields;
        var n = 0;
        for (var k in this.items) {
            var item = this.items[k];
            var field = fields[k];
            if (item == null || field == null)
                continue;

            item.td1.style.backgroundColor = JSDraw2.Skin.form.labelstyles.backgroundColor;
            if (item.type == "jsdraw.table") {
                n += field.jsd.checkRequiredFields(0);
            }

            if (!item.required)
                continue;

            var s = scil.Form.getFieldData(field);
            if (scil.Utils.isNullOrEmpty(s)) {
                item.td1.style.backgroundColor = "red";
                ++n;
            }
        }
        return n;
    },

    /**
    * Reset required fields
    * @function resetRequiredFields
    */
    resetRequiredFields: function () {
        var fields = this.fields;
        for (var k in this.items) {
            var item = this.items[k];
            var field = fields[k];
            if (item == null || field == null)
                continue;

            item.td1.style.backgroundColor = JSDraw2.Skin.form.labelstyles.backgroundColor;
        }
    },

    connectKeyEnter: function (field, onenter) {
        dojo.connect(field, "onkeydown", function (e) { if (e.keyCode == 13) { onenter(field); e.preventDefault(); } });
    },

    newField: function (item, tr, immediately, hidelabel, veritcal) {
        var me = this;
        if (!this.viewonly) {
            if (item.type == "jsdraw" || item.type == "xdraw") {
                if (JSDraw2.defaultoptions != null && JSDraw2.defaultoptions.usexdraw)
                    item.type = "xdraw";
                //if (item.options == null)
                //    item.options = {};

                // I#9132
                if (item.options != null)
                    item.options.ondatachange = function () { me.onchange(field); };
                else
                    item.ondatachange = function () { me.onchange(field); };
            }
            else if (item.type == "jsdraw.table" || item.type == "jsdraw.se" || item.type == "jsdraw.fm" || item.type == "table" ||
                item.type == "plate" || item.type == "plates" || item.type == "tabtext" || item.type == "richtext" || item.type == "plaintext") {
                //if (item.options == null)
                //    item.options = {};

                // I#9132
                if (item.options != null)
                    item.options.onchange = function (jss, args) { me.onchange(field, args); };
                else
                    item.onchange = function (jss, args) { me.onchange(field, args); };
            }
        }

        var field = this.newField2(item, tr, immediately, hidelabel, veritcal);
        if (field == null)
            return null;

        if (!this.viewonly) {
            if (field.tagName == "INPUT" || field.tagName == "TEXTAREA")
                scil.connect(field, "onchange", function () { me.onchange(field); });
            else if (field.tagName == "SELECT" && !JSDraw2.__touchmolapp) // TouchMol for Word fails here
                scil.connect(field, scil.Utils.isIE && scil.Utils.isIE < 9 ? "onclick" : "onchange", function () { me.onchange(field); });

            if (field.tagName == "INPUT" && item.mobiledata != null && item.type != "number")
                new scil.MobileData(field, { category: item.mobiledata, url: scil.MobileData.getDefaultUrl(false) });
        }
        return field;
    },

    newField2: function (item, tr, immediately, hidelabel, veritcal) {
        var s = item.label == null ? "&nbsp;" : this.lang.res(item.label) + ":";
        if (item.type == "group") {
            if (this.tbody.childNodes.length > 0) {
                scil.Utils.createElement(scil.Utils.createElement(this.tbody, "tr"), "td", "&nbsp;", { fontSize: "50%" }, { colSpan: 2 });
                tr = scil.Utils.createElement(this.tbody, "tr");
            }
            tr.style.backgroundImage = scil.Utils.imgSrc("img/header-bg.gif", true);
            tr.style.backgroundRepeat = "repeat-x";

            var d = dojo.clone(JSDraw2.Skin.form.labelstyles);
            scil.apply(d, { fontWeight: "bold", color: "#555", background: "" });
            if (item.collapsible != false)
                scil.apply(d, { backgroundImage: scil.Utils.imgSrc("img/collapse.gif", true), backgroundPosition: "right", backgroundRepeat: "no-repeat" });
            var td = scil.Utils.createElement(tr, "td", s, d, { colSpan: 2 });
            if (item.collapsible != false)
                dojo.connect(td, "onclick", function (e) { scil.Form.expand(e); });
            item.group = td;
            item.td1 = td;
            return null;
        }
        else if (item.type == "note") {
            var td = scil.Utils.createElement(tr, "td", null, null, { colSpan: 2 });
            var div = scil.Utils.createElement(td, "div", this.lang.res(item.label || item.str), item.style);
            if (item.color != null)
                div.style.color = item.color;
            item.td1 = td;
            return null;
        }
        else {
            if (hidelabel || item.hidelabel) {
                item.td1 = scil.Utils.createElement(tr, "td");
            }
            else {
                if (item.required)
                    s += "<span style='color:red' title='" + this.lang.res("Required") + "'>*</span>";
                if (scil.Utils.isNullOrEmpty(item.icon)) {
                    item.td1 = scil.Utils.createElement(tr, "td", s, JSDraw2.Skin.form.labelstyles);
                }
                else {
                    item.td1 = scil.Utils.createElement(tr, "td");
                    scil.Utils.createElement(item.td1, "img", null, null, { src: item.icon });
                    scil.Utils.createElement(item.td1, "span", s);
                }

                if (item.labelstyle != null)
                    scil.apply(item.td1.style, item.labelstyle);
            }
            if (veritcal)
                tr = scil.Utils.createElement(this.tbody, "tr");
            var td = scil.Utils.createElement(tr, "td", item.leading, null, { valign: "top" });
            item.td2 = td;
            var field = scil.Form.createField(td, item, this.viewonly, item.value, null, immediately, null, this);
            if (item.type == "hidden") {
                tr.style.display = "none";
                tr.setAttribute("hidden", "1");
            }
            if (item.type == "number")
                td.style.whiteSpace = "nowrap";
            return field;
        }
    },

    /**
    * Get the value of a field by its key
    * @function getFieldValue
    */
    getFieldValue: function (key) {
        return scil.Form.getFieldData(this.fields[key]);
    },

    focus: function (key) {
        scil.Form.focus(this.fields, key);
    }
});

scil.apply(scil.Form, {
    focus: function (fields, key) {
        if (fields == null)
            return;

        var field = null;
        if (key == null) {
            for (var k in fields) {
                var f = fields[k];
                if (f != null && (f.tagName == "INPUT" || f.tagName == "TEXTAREA" || f.tagName == "SELECT") && !f.disabled && !f.readOnly) {
                    var tr = scil.Utils.getParent(f, "TR");
                    if (tr != null && tr.style.display != "none" && !f.disabled) {
                        field = f;
                        break;
                    }
                }
            }
        }
        else {
            field = fields[key];
        }

        if (field != null && field.style.dislay != "none" && field.focus != null) {
            try {
                field.focus();
            }
            catch (e) {
            }
        }
    },

    mergeForm: function (src1, src2) {
        if (src1 == null && src2 == null)
            return null;

        var ret = {};
        if (src1 == null) {
            for (var k in src2) {
                if (src2[k] != null)
                    ret[k] = src2[k];
            }
            return ret;
        }

        if (src2 == null) {
            for (var k in src1) {
                if (src1[k] != null)
                    ret[k] = src1[k];
            }
            return ret;
        }

        for (var k in src1) {
            if (src2[k] == null && src1[k] != null)
                ret[k] = src1[k];
        }

        for (var k in src2) {
            if (src2[k] != null)
                ret[k] = src2[k];
            else
                delete ret[k];
        }

        return ret;
    },

    createElement: function (parent, tag, html, styles, attributes, onclick) {
        if (attributes != null && attributes.title != null)
            attributes.title = scil.Lang.res(attributes.title);
        return scil.Utils.createElement(parent, tag, html, styles, attributes, onclick);
    },

    expand: function (e) {
        var td = e.target || e.srcElement;
        if (td.tagName != "TD")
            return;
        var s = td.style.backgroundImage;
        var expand = s.indexOf("expand.gif") > 0;
        if (expand)
            td.style.backgroundImage = scil.Utils.imgSrc("img/collapse.gif", true);
        else
            td.style.backgroundImage = scil.Utils.imgSrc("img/expand.gif", true);

        var tr = td.parentNode.nextSibling;
        while (tr != null && tr.childNodes.length != 1 && tr.getAttribute("buttonrow") != "1") {
            if (tr.getAttribute("hidden") != "1")
                tr.style.display = expand ? "" : "none";
            tr = tr.nextSibling;
        }
    },

    _isAllString: function (s) {
        if (s == null || typeof (s) != "object")
            return false;

        if (s.length > 0)
            return true;

        var n = 0;
        for (var k in s) {
            if (typeof (s[k]) != "string")
                return false;
            ++n;
        }
        return n > 0;
    },

    _getListItems: function (item) {
        if (typeof (item.items) == "function")
            item.items = item.items();
        var list = item.items;
        if (list == null && item.options != null && item.options.items != null) {
            list = item.options.items;
            item.items = list;
            item.options.items = null;
        }
        if (list == null && this._isAllString(item.options)) {
            list = item.options;
            item.items = list;
            item.options = null;
        }
        return list;
    },

    createField: function (parent, item, viewonly, value, values, immediately, fortable, form) {
        var tag = "input";
        var itemtype = item.type;
        if (parent != null && (itemtype == "input" || itemtype == "select" || itemtype == "date" || itemtype == "color" || itemtype == "radio" || itemtype == "checkbox" || itemtype == null))
            parent.style.whiteSpace = "nowrap";

        if (/*fortable && */viewonly && (itemtype == null || itemtype == "input" || itemtype == "select" || itemtype == "editableselect" ||
                itemtype == "htmltext" || itemtype == "multiselect" || itemtype == "dropdowninput" || itemtype == "dropdowncheck" || itemtype == "date") &&
                item.template == null && (fortable || item.unit == null))
            itemtype = "html";

        switch (itemtype) {
            case "":
            case "date":
            case "color":
            case "editableselect":
            case "dropdowninput":
            case "dropdowncheck":
            case "multiselect":
                tag = "input";
                break;
            case "hidden":
                tag = item.render != null ? "div" : "input";
                break;
            case "password":
                tag = "password";
                break;
            case "rawfile":
                tag = "file";
                break;
            case "number":
                tag = viewonly ? "span" : "input";
                break;
            case "htmltext":
                tag = "texarea";
                break;
            case "jsdraw":
            case "xdraw":
            case "jsdraw.fm":
            case "jsdraw.se":
            case "jsdraw.table":
            case "plate":
            case "plates":
            case "table":
            case "tabtext":
            case "richtext":
            case "plaintext":
            case "html":
            case "fileshelf":
            case "file":
            case "filepath":
            case "filelink":
            case "filedblink":
            case "subform":
            case "image":
            case "curve":
            case "sketches":
            case "code":
            case "signature":
                tag = "div";
                break;
            case "button":
                tag = "button";
                break;
            case "postfile":
                tag = "file";
                break;
            case "user":
                tag = "input";
                if (item.autosuggesturl == null)
                    item.autosuggesturl = "Ajax.ashx?cmd=user.suggest";
                break;
            default:
                if (itemtype != null)
                    tag = itemtype;
                break;
        }

        if (item.viewonly)
            viewonly = item.viewonly;

        //if (item.type == "number" && !viewonly && item.align == null)
        //item.align = "right";

        if (viewonly) {
            if (tag == "textarea")
                tag = "div";
        }

        if (typeof (parent) == "string")
            parent = dojo.byId(parent);

        var field;
        if (itemtype == "checkbox") {
            var p = scil.Utils.createElement(parent, "label", null, { whiteSpace: "nowrap" });
            field = scil.Utils.createElement(p, tag, null, item.style, item.attributes);
            if (item.str != null)
                scil.Utils.createElement(p, "span", form.lang.res(item.str));
        }
        else {
            field = scil.Utils.createElement(parent, tag, null, item.style, item.attributes);
            if (viewonly && tag == "div" && (item.type == "htmltext" || item.type == "textarea")
                && item.width != null && (item.style == null || item.style.maxWidth == null)) {
                if (typeof (item.width) == "number")
                    field.style.maxWidth = item.width + "px";
                else
                    field.style.maxWidth = item.width;

                //field.style.wordBreak ="break-all";
                field.style.wordWrap = "break-word";
            }
        }

        if (item.type == "select")
            this._getListItems(item);

        if (tag == "select") {
            var list = this._getListItems(item);
            if (list != null) {
                var addblank = item.addblank;
                if (addblank == null) {
                    if (list.length == null) {
                        addblank = true;
                        for (var k in list) {
                            if (list[k] == null || list[k] == "") {
                                addblank = false;
                                break;
                            }
                        }
                    }
                    else {
                        if (list.length == 0 || list[0] != null && list[0] != "")
                            addblank = true;
                    }
                }
                if (addblank)
                    scil.Utils.listOptions(field, [""]);
                scil.Utils.listOptions(field, list, value, null, item.sort != false ? true : false);
            }
            else if (item.url != null) {
                scil.Form.listOptions(field, item.url, item.addblank);
            }
        }

        if (!viewonly && item.button != null) {
            if (item.button.length > 0) {
                for (var i = 0; i < item.button.length; ++i)
                    this.createFieldButton(parent, item.button[i], form, field);
            }
            else {
                this.createFieldButton(parent, item.button, form, field);
            }
        }

        if (item.button2 != null)
            scil.Utils.createButton(parent, item.button2);

        if ((!fortable || fortable == "card" && !scil.Utils.isNullOrEmpty(value)) && (item.str != null || item.unit != null) && itemtype != "checkbox")
            scil.Utils.createElement(parent, "span", "&nbsp;" + (item.str || item.unit), { whiteSpace: "nowrap" });
        if (fortable != "card") {
            var w = fortable && item.listwidth != null ? item.listwidth : item.width;
            if (w != null && w > 0)
                field.style.width = w + 'px';
        }

        if (item.height > 0 && !(viewonly && tag == "div" && (item.type == "htmltext" || item.type == "textarea")))
            field.style.height = item.height + 'px';

        if (item.align != null)
            field.style.textAlign = item.align;

        if (viewonly) {
            if (tag == "input" || tag == "password") {
                field.readOnly = true;
                field.style.border = "none";
            }
            else if (tag == "checkbox" || tag == "select") {
                field.disabled = true;
            }
        }
        else {
            if (item.readonly || item.viewonly) {
                if (tag == "input")
                    field.readOnly = true;
                else if (tag == "checkbox" || tag == "radio" || tag == "select")
                    field.disabled = true;
            }
        }

        if (tag != "div" || itemtype == "textarea" || itemtype == "html")
            field.style.color = JSDraw2.Skin.form.fieldcolor;
        field.stype = itemtype;

        // I#10377
        // var args = item.options == null ? scil.clone(item) : item.options;
        var args = scil.clone(item);
        if (item.options != null)
            scil.apply(args, item.options);

        if (viewonly)
            args.viewonly = viewonly;

        if (itemtype == "jsdraw" || itemtype == "xdraw") {
            var fn = function () {
                if (itemtype == "xdraw")
                    field.style.height = "";
                field.jsd = itemtype == "jsdraw" || viewonly ? new JSDraw2.Editor(field, args) : new scil.XDraw(field, args);
                if (!scil.Utils.isNullOrEmpty(value))
                    scil.Form.setFieldData(field, item, viewonly, value);
            };
            if (immediately)
                fn();
            else
                scil.ready(fn);
        }
        else if (itemtype == "jsdraw.table") {
            var fn = function () {
                field.jsd = new JSDraw2.Table(null, args, field);
                if (value != null)
                    field.jsd.setXml(value);
                if (item.rows > 0) {
                    for (var i = field.jsd.getRowCount(); i < item.rows; ++i)
                        field.jsd.insert();
                }
            };
            if (immediately)
                fn();
            else
                scil.ready(fn);
        }
        else if (itemtype == "plate" || itemtype == "plates") {
            var fn = function () {
                if (args.hidetable == null)
                    args.hidetable = true;
                if (itemtype == "plate")
                    field.jsd = new JSDraw2.Plate(field, args);
                else
                    field.jsd = new JSDraw2.Plates(field, args);
                if (value != null)
                    field.jsd.setXml(value);
            };
            if (immediately)
                fn();
            else
                scil.ready(fn);
        }
        else if (itemtype == "jsdraw.se") {
            var fn = function () {
                field.jsd = new JSDraw2.SequenceEditor(field, args);
                if (value != null)
                    field.jsd.setXml(value);
            };
            if (immediately)
                fn();
            else
                scil.ready(fn);
        }
        else if (itemtype == "jsdraw.fm") {
            var fn = function () {
                field.jsd = new JSDraw2.Formulation(field, args);
                if (value != null)
                    field.jsd.setXml(value);
            };
            if (immediately)
                fn();
            else
                scil.ready(fn);
        }
        else if (itemtype == "table") {
            field.jsd = new scil.Table(args);
            field.jsd.render(field, item.columns);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "tabtext") {
            field.jsd = new scil.FieldTabText(field, args);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "code") {
            field.style.marginBottom = "4px";
            field.jsd = new scil.FieldCode(field, args);
            if (value != null)
                field.jsd.setValue(value);
        }
        else if (itemtype == "signature") {
            field.jsd = new scil.FieldSignature(field, args);
            if (value != null)
                field.jsd.setValue(value);
        }
        else if (itemtype == "richtext") {
            field.jsd = new scil.FieldRichText(field, args);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "plaintext") {
            field.jsd = new scil.FieldPlainText(field, args);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "subform") {
            field.jsd = new scil.FieldSubform(field, args);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "file" || itemtype == "filelink" || itemtype == "filedblink" || itemtype == "filepath" || itemtype == "image") {
            if (itemtype == "file")
                field.jsd = new scil.FieldFile(field, args);
            else if (itemtype == "image")
                field.jsd = new scil.FieldImage(field, args);
            else if (itemtype == "filelink" || itemtype == "filedblink" || itemtype == "filepath") {
                args.cmd = itemtype;
                field.jsd = new scil.FieldFileLink(field, args);
            }
            if (item.render != null)
                value = item.render(value, values);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "sketches") {
            field.jsd = new scil.FieldSketches(field, args);
            if (item.render != null)
                value = item.render(value, values);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "fileshelf") {
            field.jsd = new scil.FileShelf(field, args);
            if (value != null)
                field.jsd.list(value);
        }
        else if (itemtype == "curve") {
            field.jsd = new scil.FieldCurve(field, args);
            if (value != null)
                field.jsd.setXml(value);
        }
        else if (itemtype == "number") {
            field.jsd = new scil.FieldNumber(field, args);
            this.setFieldData(field, item, viewonly, value, values);
        }
        else if (itemtype == "date") {
            if (!viewonly && !item.viewonly)
                new scil.DatePicker(field, item.options);
            if (value != null) {
                if (value == "{today}")
                    value = scil.Utils.dateStr(new Date(), true, "yyyy-mm-dd");
            }
            this.setFieldData(field, item, viewonly, value, values);
        }
        else if (itemtype == "color") {
            field.jsd = new scil.ColorPicker2(field, { viewonly: viewonly });
            this.setFieldData(field, item, viewonly, value, values);
        }
        else if (itemtype == "button") {
            field.innerHTML = item.text;
        }
        else {
            if (value != null || itemtype == "html" && (item.template != null || item.render != null))
                this.setFieldData(field, item, viewonly, value, values);
        }

        if (itemtype == "img" && item.src != null)
            field.src = item.src;
        if (item.title != null)
            field.setAttribute("title", item.title);
        if (item.onclick != null)
            dojo.connect(field, "onclick", function () { item.onclick(field, item, form); });
        if (field.tagName == "INPUT") {
            if (item.onenter != null)
                dojo.connect(field, "onkeydown", function (e) { if (e.keyCode == 13) { item.onenter(field); e.preventDefault(); } });
            else if (scil.Utils.isIE && scil.Utils.isIE < 9) // fix bug I#6556
                dojo.connect(field, "onkeydown", function (e) { if (e.keyCode == 13) { e.preventDefault(); } });
        }

        if (item.autosuggest != null && item.autosuggest != "" && field.tagName == "INPUT")
            field.jsd = new scil.AutoComplete(field, item.autosuggest, item.options, form);
        else if (item.autosuggesturl != null && item.autosuggesturl != "" && field.tagName == "INPUT")
            field.jsd = new scil.AutoComplete(field, item.autosuggesturl, item.options, form);

        var options = item.options;
        if (options == null)
            options = {};
        if (item.items != null)
            options.items = item.items;

        if (!viewonly && itemtype == "editableselect")
            field.jsd = new scil.EditableSelect(field, options);
        else if (!viewonly && itemtype == "dropdowninput")
            field.jsd = new scil.DropdownInput(field, options);
        else if (!viewonly && itemtype == "dropdowncheck")
            field.jsd = new scil.DropdownCheck(field, options);
        else if (!viewonly && itemtype == "multiselect")
            field.jsd = new scil.DropdownCheck(field, options);
        else if (!viewonly && itemtype == "htmltext") {
            if (args.buttons == null)
                args.buttons = [];
            else if (typeof (args.buttons) == "string")
                args.buttons = [args.buttons];
            if (args.extrabuttons != null)
                args.buttons.push(args.extrabuttons);
            if (value != null && value == "")
                field.value = value;
            scil.Richtext.initTinyMCE(field, args);
        }
        //        else if (itemtype == "number") {
        //            dojo.connect(field, "onchange", function (e) {
        //                var s = field.value;
        //                if (s != "" && s != null && !scil.Utils.isNumber(s, item.allowoperator)) {
        //                    scil.Utils.alert("A number is required!");
        //                    field.value = "";
        //                }
        //            });
        //        }

        // I#9132
        if (field.tagName == "INPUT" || field.tagName == "SELECT" || field.tagName == "TEXTAREA") {
            if (item.onchange != null)
                dojo.connect(field, "onchange", function () { item.onchange(field, form); });
            if (item.onfocus != null)
                dojo.connect(field, "onfocus", function () { item.onfocus(field, form); });
            if (item.onblur != null)
                dojo.connect(field, "onblur", function () { item.onblur(field, form); });
        }

        if (item.padding >= 0 && (field.tagName == "INPUT" || field.tagName == "DIV"))
            field.style.paddingLeft = field.style.paddingRight = item.padding + "px";

        if (field.tagName == "INPUT" && field.disabled != true && item.type != "checkbox" && item.type != "radio")
            dojo.connect(field, "onfocus", function () { field.select(); });

        if (field.jsd != null)
            field.jsd.parentform = form;

        return field;
    },

    createFieldButton: function (parent, button, form, field) {
        var b = scil.Utils.createButton(parent, button);
        if (b != null) {
            if (button.onclick2 != null) {
                dojo.connect(b, "onclick", function () { button.onclick2(field, form); });
            }
            else if (button.ajaxurl != null) {
                dojo.connect(b, "onclick", function () {
                    scil.Utils.ajax(button.ajaxurl, function (ret) {
                        if (button.append != null)
                            field.value += ret + button.append;
                        else
                            field.value = ret;
                    }, { q: field.value });
                });
            }
        }
    },

    getFieldData: function (field, item) {
        if (field == null)
            return null;

        if (field.stype == "jsdraw") {
            if (item != null && item.dataformat != null)
                return field.jsd.getData(item.dataformat);
            else
                return field.jsd.getXml();
        }
        if (field.stype == "xdraw" || field.stype == "jsdraw.se" || field.stype == "jsdraw.fm" ||
            field.stype == "table" || field.stype == "plate" || field.stype == "plates") {
            return field.jsd.getXml();
        }
        else if (field.stype == "jsdraw.table") {
            if (field.jsd.getRowCount() == 0)
                return null;
            return field.jsd.getXml();
        }
        else if (field.type == "checkbox" || field.type == "radio")
            return field.checked;
        else if (field.stype == "htmltext") {
            var ed = scil.Form.getEd(field);
            return ed == null ? field.innerHTML : scil.Richtext.getHtml(ed);
        }
        else if (field.stype == "file" || field.stype == "filelink" || field.stype == "filedblink" || field.stype == "filepath" ||
            field.stype == "image" || field.stype == "curve" || field.stype == "sketches")
            return field.jsd.getXml();
        else if (field.stype == "tabtext" || field.stype == "richtext" || field.stype == "plaintext" || field.stype == "subform")
            return field.jsd.getXml();
        else if (field.stype == "code")
            return field.jsd.getValue();
        else if (field.stype == "signature")
            return field.jsd.getValue();
        else if (field.stype == "number")
            return field.jsd.getValue();
        else if (field.type == "password")
            return field.value == "" ? "" : (item.encrypt != false && JSDraw2.password != null && JSDraw2.password.encrypt && scil.Form.encryptpassword != null ? scil.Form.encryptpassword(field.value) : field.value);
        else if (field.stype == "postfile" || field.stype == "button")
            return null;
        else {
            if (field.value == null && field.getAttribute != null) // I#12753
                return field.getAttribute("originalvalue");
            return field.value == "" ? null : field.value;
        }
    },

    setFieldData: function (field, item, viewonly, value, values) {
        if (item == null)
            return;

        var originalvalue = value;
        if (item.render != null)
            value = item.render(value, values);

        if (viewonly && item.maxlength > 0 && typeof (value) == "string" && value.length > item.maxlength)
            value = value.substr(0, item.maxlength - 3) + "...";

        if (field.stype == "jsdraw" || field.stype == "xdraw" || field.stype == "jsdraw.table" || field.stype == "jsdraw.se" ||
            field.stype == "jsdraw.fm" || field.stype == "plate" || field.stype == "plates") {
            if (field.stype == "jsdraw" || field.stype == "xdraw" || field.stype == "jsdraw.table" && item.options != null && item.options.spreadsheet)
                field.jsd.clear(true);
            else
                field.jsd.clear();

            if (item.type == "jsdraw") {
                if (item.dataformat != null)
                    field.jsd.setData(value, item.dataformat);
                else if (!(value == null || typeof (value) == "string" && value == ""))
                    field.jsd.setXml(value);
            }
            else {
                if (value != null && value.rows != null && field.stype == "jsdraw.table")
                    field.jsd.setJson(value);
                else if (!(value == null || typeof (value) == "string" && value == ""))
                    field.jsd.setXml(value);

                if (field.stype == "jsdraw.table" && item.options != null && item.options.spreadsheet)
                    field.jsd.createTable();

                if (field.stype == "jsdraw.table" && item.rows > 0) {
                    for (var i = field.jsd.getRowCount(); i < item.rows; ++i)
                        field.jsd.insert();
                }
            }
        }
        else if (field.stype == "table") {
            if (value != null && (typeof (value) == "string" || typeof (value) == "object" && value.tagName == "table"))
                field.jsd.setXml(value);
            else if (value != null && value.length > 0)
                field.jsd.setData(value);
            else
                field.jsd.setData([]);
        }
        else if (item.type == "tabtext" || item.type == "richtext" || item.type == "plaintext") {
            field.jsd.setXml(value);
        }
        else if (item.type == "checkbox" || item.type == "radio") {
            field.checked = scil.Utils.isTrue(value);
        }
        else if (item.type == "select") {
            if (viewonly) {
                var list = this._getListItems(item);
                if (list != null && list.length == null)
                    value = list[value];
                this._setInnerHTML(field, value, originalvalue);
            }
            else {
                scil.Utils.selectOption(field, value);
            }
        }
        else if (item.type == "date") {
            if (typeof (value) == "string" && !scil.Utils.isNullOrEmpty(value) && !isNaN(value)) {
                value = parseFloat(value);
                if (isNaN(value))
                    value = null;
            }
            var s = item.timeformat == null ? scil.Utils.dateStr(value, true, item.dateformat) : scil.Utils.timeStr(value, true, item.timeformat);
            if (viewonly) {
                if (field.tagName == "INPUT")
                    field.value = s;
                else
                    this._setInnerHTML(field, s, originalvalue);
            }
            else {
                field.value = s;
            }
        }
        else if (item.type == "color") {
            field.jsd.setValue(value);
        }
        else if (field.stype == "code") {
            field.jsd.setValue(value);
        }
        else if (field.stype == "signature") {
            field.jsd.setValue(value);
        }
        else if (field.stype == "number") {
            return field.jsd.setValue(value);
        }
        else if (field.stype == "html") {
            var s = value == null ? "" : value;
            if (item != null && item.template != null)
                s = this.renderTemplate(item.template, value, values);
            else if (typeof (s) == "string" && s.match(/^((http[s]?)|(ftp)):[\/]{2}.+$/i) != null)
                s = "<a target=_blank href='" + s + "'>" + s + "</a>";
            this._setInnerHTML(field, s, originalvalue);
        }
        else if (field.stype == "file" || field.stype == "filelink" || field.stype == "filedblink" || field.stype == "filepath" || field.stype == "image" || field.stype == "curve" || field.stype == "sketches" || field.stype == "subform") {
            field.jsd.setXml(value);
        }
        else if (field.stype == "fileshelf") {
            field.jsd.list(value);
        }
        else if (item.type == "htmltext") {
            if (viewonly) {
                this._setInnerHTML(field, field.innerHTML = value == null ? "" : value, originalvalue, true);
            }
            else {
                var ed = scil.Form.getEd(field);
                if (ed != null && ed.dom != null)
                    ed.setContent(value == null ? "" : value);
                else
                    field.value = value == null ? "" : value;
            }
        }
        else if (field.stype == "textarea") {
            if (field.tagName == "TEXTAREA")
                field.value = value == null ? "" : value;
            else
                this._setInnerHTML(field, this.wrapTextarea(value), originalvalue, true);
        }
        else if (field.stype != "div" && field.stype != "button") {
            if (field.stype == "hidden" && value != null && typeof (value) == "object" && value.tagName != null) // I#10361
                value = scil.Utils.getOuterXml(value);

            if (field.tagName == "INPUT" || field.tagName == "TEXTAREA")
                field.value = value == null ? "" : value;
            else if (field.tagName == "DIV")
                this._setInnerHTML(field, value == null ? "" : value, originalvalue);
        }

        if (item.onrendered != null)
            item.onrendered(field, value);
    },

    wrapTextarea: function (value) {
        var whitespace = "white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; white-space: pre-wrap; word-wrap: break-word;";
        return value == null ? "" : "<pre style='margin:0;padding:0;" + whitespace + "'>" + scil.Utils.escapeHtml(value) + "</pre>";
    },

    _setInnerHTML: function (field, value, originalvalue, clear) {
        if (value == null)
            value = "";
        else if (clear)
            value += "<div style='clear:both'></div>"; // I#11990

        field.innerHTML = value;

        // very tricky: in chrome:
        //     0 == "" -> true
        //     0 != "" -> false
        // if (originalvalue != null && originalvalue != "")
        if (originalvalue != null && (originalvalue + "") != "")
            field.setAttribute("originalvalue", originalvalue);
    },

    renderTemplate: function (template, value, values) {
        s = template.replace(/\{\?\}/g, value == null ? "" : value);
        if (values == null)
            return s;
        var tokens = s.match(/\{\{[a-z|0-9]+\}\}/ig);
        if (tokens == null)
            return s;
        for (var i = 0; i < tokens.length; ++i) {
            var token = tokens[i];
            var k = token.substr(2, token.length - 4);
            var v = values[k];
            s = s.replace(token, v == null ? "" : v);
        }
        return s;
    },

    listOptions: function (select, url, addblank) {
        scil.Utils.ajax(url, function (ret) {
            if (addblank)
                scil.Utils.listOptions(select, [""]);
            scil.Utils.listOptions(select, ret);
        });
    },

    /**
    * Create a form
    * @function {static} create
    * @param {object} obj the data object to be loaded into the table. obj.load() will be called
    * @param {string or DOM} parent parent element
    * @param {array} buttons an array of button definitions. button: { caption: string, onclick: function }
    * @param {array} items an array of field definitions. item: { id, iskey ... }
    * @param {bool} viewonly indicate if creating a viewonly table
    * @returns a new Table object
    */
    create: function (obj, parent, items, buttons, viewonly) {
        if (typeof parent == "string")
            parent = dojo.byId(parent);

        var div = scil.Utils.createElement(parent, "div");
        var form = new scil.Form(viewonly);
        form.render(div, items);

        if (buttons != null) {
            var tr = scil.Utils.createElement(form.tbody, "tr");
            var td = scil.Utils.createElement(tr, "td");
            td = scil.Utils.createElement(tr, "td");

            if (buttons.length == null) {
                scil.Utils.createButton(td, buttons);
            }
            else {
                for (var i = 0; i < buttons.length; ++i)
                    scil.Utils.createButton(td, buttons[i]);
            }
        }

        if (obj.load != null)
            scil.onload(function () { obj.load(); });
        return form;
    },

    /**
    * Create a HTML form
    * @function {static} createForm2
    * @param {DOM} parent parent element
    * @param {array} items an array of field definitions. item: { id, iskey ... }
    * @param {dict} buttons button definition: { label, onclick }
    * @returns a form object
    * <pre>
    * <b>Example:</b>
    *    dojo.ready(function () {
    *        var parent = scil.Utils.createElement(document.body, "div");
    *        var items = {
    *            notes: { type: "note", label: "This is a test" },
    *            username: { label: "username:", tag: "input", width: 200 },
    *            password: { label: "Your Password:", tag: "password", width: 200 }
    *        };
    *        var form = scil.Form.createForm2(parent, items, { label: "Login", onclick: function () { alert("Blah..." } });
    *    });
    * </pre>
    */
    createForm2: function (parent, items, buttons, options) {
        if (options == null)
            options = {};

        var form = null;
        if (buttons != null)
            options.buttons = buttons;
        if (options.tabs != null) {
            form = new scil.TabbedForm(options).render(parent);
        }
        else {
            form = new scil.Form(options);
            form.render(parent, items, options);

            for (var k in items) {
                if (items[k] == null)
                    continue;
                if (items[k].type == "group" && items[k].group != null && items[k].collapsed)
                    this.expand({ target: items[k].group });
            }
        }

        return form;
    },

    _connetOnClick: function (e, fn) {
        dojo.connect(e, "onclick", function () { fn(); });
    },

    /**
    * Create a HTML Dialog form
    * <pre>
    * <b>Example:</b>
    *    dojo.ready(function () {
    *        var items = {
    *            notes: { type: "note", label: "This is a test" },
    *            username: { label: "username:", tag: "input", width: 200 },
    *            password: { label: "Your Password:", tag: "password", width: 200 }
    *        };
    *        var dlg = scil.Form.createDlgForm("Login", items,
    *                { label: "Login", onclick: function () { alert("Blah..."); dlg.hide(); } }, 350);
    *    });
    * </pre>
    * @function {static} createDlgForm
    * @param {string} caption dialog caption
    * @param {array} items an array of field definitions. item: { id, iskey ... }
    * @param {dict} buttons button definition: { label, onclick }
    * @param {options}: { onenter, viewonly }
    * @returns a dialog object
    */
    createDlgForm: function (caption, items, buttons, options) {
        var args = {};
        if (typeof (options) == "number") {
            args.width = options + "px";
            options = null;
        }
        else if (options != null && options.width > 0) {
            args.width = options.width + "px";
        }
        var div = scil.Utils.createElement(null, "div", null, args);
        var dlg = new JSDraw2.Dialog(caption, div, options);
        dlg.show2({ immediately: true });
        dlg.form = this.createForm2(div, items, buttons, options);
        dlg._scilform = true;
        //dlg.hide(true);
        //dlg.show2({ owner: this, immediately: options == null ? null : options.immediately });
        dlg.moveCenter();
        if (options != null && options.oncreated)
            options.oncreated(dlg.form);
        return dlg;
    },

    createFormDlg: function (caption, items, buttons, options) {
        return this.createDlgForm(caption, items, buttons, options);
    },

    /**
    * Create a HTML Tabbed Dialog form
    * <pre>
    * <b>Example:</b>
    *    &lt;button onclick='test()'&gt;Test&lt;/button&gt;
    *    &lt;script type="text/javascript"&gt;
    *        function test() {
    *            var options = { tabs: {
    *                a: { caption: "Tab A", fields: { field1: { label: "Field1"}} },
    *                b: { caption: "Tab B", fields: { field2: { label: "Field2" }, field3: { label: "Field3"}} }
    *            }, buttons: { label: "Test", onclick: function() { alert(999); } }, border: true
    *            };
    *
    *            var dlg = scil.Form.createTabDlgForm("Test", null, null, options);
    *            dlg.form.setData({ field1: "AAA", field2: "124" });
    *        }
    *    &lt;/script&gt;
    * </pre>
    * @function {static} createTabDlgForm
    * @returns a dialog object
    */
    createTabDlgForm: function (caption, options) {
        return this.createDlgForm(caption, null, null, options);
    },

    createForm: function (items, btn, onclick, border, extra, enter) {
        var style1 = { verticalAlign: "top", whiteSpace: "nowrap" };
        var style2 = { textAlign: "left" };
        if (border) {
            style1.border = "solid 1px #f0f0f0";
            style1.backgroundColor = "#f5f5f5";
        }

        var tbody = scil.Utils.createTable();

        var required = false;
        for (var i = 0; i < items.length; ++i) {
            if (items[i].required) {
                required = true;
                break;
            }
        }
        if (required) {
            var tr = scil.Utils.createElement(tbody, "tr");
            scil.Utils.createElement(tr, "td");
            scil.Utils.createElement(tr, "td", "<span style='color:red;font-weight:bold'>* indicates required field</span>", style2);
        }

        for (var i = 0; i < items.length; ++i) {
            var it = items[i];
            var tr = scil.Utils.createElement(tbody, "tr");
            var td = scil.Utils.createElement(tr, "td", it.label + (it.required ? "<b style='color:red'>*</b>" : ""), style1);
            if (it.colspan) {
                td.colSpan = 2;
            }
            else {
                td = scil.Utils.createElement(tr, "td", null, style2);

                if (it.tag != null) {
                    var input = scil.Utils.createElement(td, it.tag);
                    if (it.tag == "select")
                        scil.Utils.listOptions(input, it.options);
                    if (it.width != null)
                        input.style.width = it.width + "px";
                    if (it.height != null)
                        input.style.height = it.height + "px";
                    if (it.id != null)
                        input.id = it.id;
                    if (it.tag == "hidden")
                        tr.style.display = "none";
                    if (it.align != null)
                        input.style.textAlign = it.align;

                    if (it.id == enter)
                        dojo.connect(input, "onkeydown", function (e) { if (e.keyCode == 13) { onclick(); e.preventDefault(); } });
                }

                if (it.span != null)
                    scil.Utils.createElement(td, "span", it.span);
            }
        }

        var tr = scil.Utils.createElement(tbody, "tr");
        scil.Utils.createElement(tr, "td", "&nbsp;");

        tr = scil.Utils.createElement(tbody, "tr");
        scil.Utils.createElement(tr, "td");
        var td = scil.Utils.createElement(tr, "td");
        if (btn != null) {
            if (typeof (btn) == "string") {
                var b = scil.Utils.createElement(td, "button", btn);
                dojo.connect(b, "onclick", onclick);
            }
            else if (btn != null && typeof (btn) == "object" && btn.length > 0) {
                var buttons = [];
                for (var i = 0; i < btn.length; ++i) {
                    var bn = btn[i];
                    var b = scil.Utils.createElement(td, "button", bn.caption);
                    if (bn.id != null)
                        b.id = bn.id;
                    this._connetOnClick(b, bn.onclick);
                }
            }
        }

        if (extra != null)
            scil.Utils.createElement(td, "span", extra);
        return tbody.parentNode;
    },

    fillForm: function (data, prefix) {
        for (k in data) {
            var field = dojo.byId((prefix == null ? "" : prefix) + k);
            if (field != null) {
                if (field.tagName == "SELECT")
                    JsUtils.selectOption(field, data[k]);
                else
                    field.value = data[k] == null ? "" : data[k];
            }
        }
    },

    collectFormData: function (parent) {
        var ret = {};

        var inputs = parent.getElementsByTagName("input");
        for (var i = 0; i < inputs.length; ++i) {
            var n = inputs[i];
            var type = (n.getAttribute("type") + "").toLowerCase();
            switch (type) {
                case "radio":
                case "checkbox":
                    if (n.checked)
                        this._addValue(ret, n.id, n.value == null || n.value.length == 0 ? "true" : n.value);
                    break;
                case "button":
                    break;
                default:
                    this._addValue(ret, n.id, n.value);
                    break;
            }
        }

        var textareas = parent.getElementsByTagName("textarea");
        for (var i = 0; i < textareas.length; ++i) {
            var n = textareas[i];
            this._addValue(ret, n.id, n.value);
        }

        var selects = parent.getElementsByTagName("select");
        for (var i = 0; i < selects.length; ++i) {
            var n = selects[i];
            this._addValue(ret, n.id, n.value);
        }

        return ret;
    },

    _addValue: function (dict, key, value) {
        if (key == null || key.length == 0)
            return;

        var p = key.lastIndexOf('.');
        if (p > 0)
            key = key.substr(p + 1);
        dict[key] = value;
    },

    toAmount: function (v, liquid) {
        if (v == null || v == 0)
            return "-";
        else if (v >= 1000)
            return (v / 1000) + (liquid ? "L" : "kg");
        else if (v < 0.001 && liquid)
            return (v * 1000000) + "ug";
        else if (v < 1)
            return (v * 1000) + (liquid ? "uL" : "mg");
        else
            return v + (liquid ? "mL" : "g");
    },

    processAmount: function (c) {
        if (!(c.amount > 0))
            c.amount = null;
        if (!(c.amountleft > 0))
            c.amountleft = null;
        var v = c.amount == null ? c.amountleft : c.amount;
        if (v <= 0)
            v = null;
        if (v === null) {
            c.unit = c.isliquid ? "L" : "kg";
        }
        else if (v >= 1000) {
            c.amount /= 1000;
            c.amountleft /= 1000;
            c.unit = c.isliquid ? "L" : "kg";
        }
        else if (v < 0.001 && !c.isliquid) {
            c.amount *= 1000000;
            c.amountleft *= 1000000;
            c.unit = "ug";
        }
        else if (v < 1) {
            c.amount *= 1000;
            c.amountleft *= 1000;
            c.unit = c.isliquid ? "uL" : "mg";
        }
        else {
            c.unit = c.isliquid ? "mL" : "g";
        }
    },

    setButtonValueByKey: function (buttons, key, s) {
        if (buttons == null)
            return;

        for (var i = 0; i < buttons.length; ++i) {
            if (buttons[i].key == key) {
                buttons[i].b.value = s == null ? "" : s;
                break;
            }
        }
    },

    setButtonValueByKey: function (buttons, key, value) {
        if (buttons == null || scil.Utils.isNullOrEmpty(key) || scil.Utils.isNullOrEmpty(value))
            return;

        for (var i = 0; i < buttons.length; ++i) {
            if (buttons[i].key == key) {
                buttons[i].b.value = value;
                break;
            }
        }
    },

    getButtonValueByKey: function (buttons, key) {
        if (buttons == null)
            return null;
        for (var i = 0; i < buttons.length; ++i) {
            if (buttons[i].key == key)
                return buttons[i].b.value;
        }
        return null;
    },

    getButtonValuesByKey: function (buttons, keys, dict) {
        if (dict == null)
            dict = {};

        for (var i = 0; i < keys.length; ++i)
            dict[keys[i]] = this.getButtonValueByKey(buttons, keys[i]);
        return dict;
    },

    createToolbarButtons: function (parent, buttons, padding, tableAlign) {
        if (parent == null || buttons == null)
            return;

        var tr = null;
        if (tableAlign != null)
            tr = scil.Utils.createElement(scil.Utils.createTable2(parent, null, { cellSpacing: 0, cellPadding: 0, align: tableAlign }), "tr");

        for (var i = 0; i < buttons.length; ++i) {
            if ((i == 0 || buttons[i - 1] == "-" || buttons[i - 1] == "|") && (buttons[i] == "-" || buttons[i] == "|"))
                continue;

            if (tableAlign != null)
                parent = scil.Utils.createElement(tr, "td");
            this._createButton(parent, buttons[i], padding);
        }
    },

    _createButton: function (parent, button, padding) {
        if (button == null)
            return;

        if (typeof (padding) != "number" || padding <= 0)
            padding = 3;

        if (typeof(button) == "string") {
            scil.Utils.createElement(parent, "span", (button == "-" ? "|" : button), { margin: "0 " + (2 * padding) + "px 0 " + (2 * padding) + "px" });
            return;
        }

        button.label = scil.Lang.res(button.label);
        button.caption = scil.Lang.res(button.caption);
        button.title = scil.Lang.res(button.title);

        var b = null;
        if (button.type == "select") {
            if (button.label != null) {
                var l = scil.Utils.createElement(parent, "span", button.label + ":", button.labelstyle);
                l.style.marginLeft = padding + "px";
            }
            b = scil.Utils.createElement(parent, "select", null, button.styles, button.attributes);
            scil.Utils.listOptions(b, button.items || button.options, button.value, null, button.sort);
            if (button.onchange != null)
                dojo.connect(b, "onchange", function (b) { button.onchange(b); });
            b.style.marginRight = padding + "px";
        }
        else if (button.type == "input" || button.type == "date" || button.type == "color") {
            if (button.label != null) {
                var l = scil.Utils.createElement(parent, "span", button.label + ":", button.labelstyle);
                l.style.marginLeft = padding + "px";
            }
            b = scil.Utils.createElement(parent, "input", null, button.styles, button.attributes);
            if (button.onenter != null)
                dojo.connect(b, "onkeydown", function (e) { if (e.keyCode == 13) button.onenter(b); });
            if (button.onchange != null)
                dojo.connect(b, "onchange", function (b) { button.onchange(b); });
            if (button.autosuggesturl != null)
                new scil.AutoComplete(b, button.autosuggesturl, { onsuggest: button.onsuggest });
            b.style.marginRight = padding + "px";

            if (button.type == "date")
                new scil.DatePicker(b);
            else if (button.type == "color")
                new scil.ColorPicker2(b);

            if (button.value != null)
                b.value = button.value;

            if (button.autoshrink > 0)
                new scil.AutoShrink(b, button, true);
        }
        else {
            b = scil.Utils.createButton(parent, button);
            b.style.margin = padding + "px";
        }
        button.b = b;
    },

    getEd: function (field) {
        return tinymce.get(field.id);
    },

    dict2formxml: function (dict) {
        return this.json2xml(dict);
    },

    json2xml: function (dict, nowrapper) {
        if (dict == null)
            return null;

        var ret = nowrapper ? "" : "<data>\n";
        for (var k in dict) {
            var v = dict[k];
            if (v != null && v != "") {
                ret += "<i n='" + scil.Utils.escXmlValue(k) + "'>";
                ret += scil.Utils.escXmlValue(v);
                ret += "</i>\n";
            }
        }
        if (!nowrapper)
            ret += "</data>";
        return ret;
    },

    encryptpassword: function (s) {
        if (scil.Utils.isNullOrEmpty(s))
            return null;

        var Key = CryptoJS.enc.Utf8.parse(JSDraw2.password != null && JSDraw2.password.key != null ? JSDraw2.password.key : "PSVJQRk9qTEp!6U1dWUZ%RVFG=1VVT0=");
        var IV = CryptoJS.enc.Utf8.parse(JSDraw2.password != null && JSDraw2.password.iv != null ? JSDraw2.password.iv : "!WlSLVE2ZU+NaW?=");
        var encryptedText = CryptoJS.AES.encrypt(s, Key, { iv: IV, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
        return "(?|" + encryptedText + ")";
    },

    xml2Json: function (xml) {
        var root = null;
        if (typeof xml == "object") {
            root = xml;
        }
        else if (typeof xml == "string") {
            var doc = scil.Utils.parseXml(xml);
            if (doc != null)
                root = doc.documentElement || doc.firstElementChild;
        }

        if (root == null || root.childNodes == null)
            return null;

        var data = {};
        for (var i = 0; i < root.childNodes.length; ++i) {
            var e = root.childNodes[i];
            if (e.tagName != "i")
                continue;

            var id = e.getAttribute("id");
            if (id == null)
                id = e.getAttribute("n");
            var v = scil.Utils.getFirstElement(e);
            if (v != null && scil.Utils.isIE && scil.Utils.isIE < 9)
                v = v.xml;
            data[id] = v != null ? v : (e.text || e.textContent);
        }

        return data;
    },

    evalFormula: function (formula, form, jss, irow) {
        if (scil.Utils.isNullOrEmpty(formula))
            return null;
        var ss = scil.Form.splitVars(formula);

        var expression = "";
        for (var i = 0; i < ss.length; ++i) {
            var s = ss[i];
            if (scil.Utils.startswith(s, "{") && scil.Utils.endswith(s, "}")) {
                var k = s.substr(1, s.length - 2);
                if (k.substr(0, 1) == '.') {
                    s = jss.getCellValue(irow, k.substr(1));
                }
                else {
                    var type = form.items[k].type;
                    if (type == "jsdraw.table" || type == "jsdraw" || type == "jsdraw.se")
                        s = "form.fields['" + k + "'].jsd";
                    else
                        s = form.getFieldValue(k);
                }
            }

            s = s.trim();
            if (scil.Utils.endswith(s, '%')) {
                var s2 = s.substr(0, s.length - 1);
                if (!isNaN(s2))
                    s = parseFloat(s2) / 100;
            }
            expression += s;
        }

        try {
            return eval(expression);
        }
        catch (e) {
            return null;
        }
    },

    splitVars: function (s) {
        var ret = [];
        var p;
        while ((p = s.indexOf("{")) >= 0) {
            if (p > 0) {
                ret.push(s.substr(0, p));
                s = s.substr(p);
            }

            p = s.indexOf("}");
            if (p < 0)
                break;

            ret.push(s.substr(0, p + 1));
            s = s.substr(p + 1);
        }

        if (!scil.Utils.isNullOrEmpty(s))
            ret.push(s);
        return ret;
    },

    ext2Icon: function (filename) {
        if (filename == null)
            return "unknown";
        var p = filename.lastIndexOf('.');
        if (p < 0)
            return "unknown";
        var ext = filename.substr(p + 1).toLowerCase();
        switch (ext) {
            case "avi":
            case "bmp":
            case "c":
            case "cab":
            case "cdx":
            case "cer":
            case "chm":
            case "dll":
            case "doc":
            case "eps":
            case "exe":
            case "fasta":
            case "fdf":
            case "gif":
            case "hlp":
            case "htm":
            case "iso":
            case "jar":
            case "java":
            case "jdx":
            case "jpg":
            case "js":
            case "jsdraw":
            case "mdb":
            case "mht":
            case "molengine":
            case "mov":
            case "mp3":
            case "mrv":
            case "msg":
            case "msi":
            case "pdb":
            case "pdf":
            case "pic":
            case "ppt":
            case "ps":
            case "py":
            case "pyc":
            case "rm":
            case "sdf":
            case "skc":
            case "sql":
            case "swf":
            case "txt":
            case "vbs":
            case "vsd":
            case "xls":
            case "xml":
            case "xps":
            case "zip":
                return ext;
            case "docx":
            case "rtf":
                return "doc";
            case "dx":
                return "jdx";
            case "oxps":
                return "xps";
            case "pptx":
                return "ppt";
            case "xlsx":
            case "csv":
                return "xls";
            case "jpeg":
                return "jpg";
            case "svg":
            case "tif":
            case "tiff":
                return "pic";
            case "mp4":
                return "mp3";
            case "wav":
                return "avi";
            case "png":
            case "wmf":
            case "emf":
                return "bmp";
            case "html":
            case "shtml":
            case "xhtml":
                return "htm";
            case "gz":
                return "zip";
            case "cdxml":
                return "cdx";
            case "tgf":
                return "skc";
            case "mol":
            case "rxn":
            case "jsd":
            case "jssdf":
                return "jsdraw";
            case "cs":
            case "vb":
            case "cpp":
            case "c":
            case "aspx":
            case "asp":
                return "script";
            case "config":
                return "xml";
            default:
                return "unknown";
        }
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////



/**
* AutoComplete class - Convert a INPUT field into a auto-complete field
* @class scilligence.AutoComplete
* <pre>
* <b>Example:</b>
*    var input = scil.Utils.createElement(document.body, "input");
*    var ac = new scil.AutoComplete(element, "http://server/ajax.ashx?cmd=autocomplete");
* </pre>
*/
scil.AutoComplete = scil.extend(scilligence._base, {
    /**
    * @constructor AutoComplete
    * @param {string or DOM} element - the INPUT element to be converted
    * @param {string} url Ajax url to list items.  The ajax service should return { succeeded: true, ret: { items: [] } }
    */
    constructor: function (element, url, options, form) {
        this.input = null;
        this.auto = null;
        this.url = url;
        this.sugid = 0;
        this.disabled = false;
        this.options = options == null ? {} : options;
        this.form = form;

        var me = this;
        this.input = typeof (element) == "string" ? document.getElementById(element) : element;
        if (this.input.tagName == "INPUT") {
            scil.connect(this.input, "onkeyup", function (e) { me.keydown(e); });

            this.auto = scil.Utils.createElement(document.body, "div", null, { display: "none", backgroundColor: "white", border: "solid 1px gray", position: "absolute" });
            scil.connect(document.body, "onmousedown", function (e) { var src = e.srcElement || e.target; if (src != me.q && !scil.Utils.isChildOf(src, me.auto)) me.clickout(); });

            if (this.options.listedonly) {
                scil.connect(this.input, "onblur", function (e) { me.validateList(); });
            }
        }

        scil.AutoComplete._all.push(this);
    },

    validateList: function () {
        var s = this.input.value;
        if (this.items == null || scil.Utils.indexOf(this.items, s) < 0)
            this.input.value = "";
    },

    isVisible: function () {
        return this.auto != null && this.auto.style.display == "";
    },

    hide: function () {
        if (this.auto != null)
            this.auto.style.display = "none";
    },

    keydown: function (e) {
        if (this.disabled || this.input == null || this.url == null || this.url == "")
            return;

        if (this.input.value.length < 1 || e.keyCode == 27 || (e.ctrlKey || e.metaKey)) {
            this.auto.style.display = "none";
            return;
        }

        if (!this.isVisible() && e.keyCode == 13)
            return;

        if (e.keyCode == 38 || e.keyCode == 40 || e.keyCode == 13) {
            this.highlight(e);
            return;
        }

        var sugid = ++this.sugid;
        if (scil.Utils.startswith(this.url, "data:")) {
            // local data
            var ret = this.filterlist(this.url.substr(5).split(','), this.input.value);
            this.list(ret, sugid);
        }
        else if (scil.Utils.startswith(this.url, "javascript:")) {
            var s = this.url.substr(11);
            var fn = scil.Utils.eval(s);
            var items = fun(this);

            var ret = this.filterlist(items, this.input.value);
            this.list(ret, sugid);
        }
        else {
            // url to ajax call
            var me = this;
            var args = { q: this.input.value };
            if (this.options.onsuggest != null)
                this.options.onsuggest(args, this.form, this);
            scil.Utils.jsonp(this.url, function (ret) { me.list(ret.items == null ? ret : ret.items, sugid); }, args);
        }
    },

    filterlist: function (list, q) {
        var ret = [];
        if (q != null && q != "" && list != null) {
            q = q.toLowerCase();
            for (var i = 0; i < list.length; ++i) {
                if (list[i].toLowerCase().indexOf(q) >= 0)
                    ret.push(scil.Utils.trim(list[i]));
            }
        }
        return ret;
    },

    isParentHidden: function (q) {
        var obj = q;
        while (obj != null && obj.style != null) {
            if (obj.style.display == "none" || obj.style.visibility == "hidden")
                return true;
            obj = obj.parentNode;
        }
        return false;
    },

    list: function (items, sugid) {
        if (items == null || items.length == 0 || sugid != this.sugid || this.isParentHidden(this.input)) {
            this.items = null;
            this.auto.style.display = "none";
            return;
        }

        if (this.auto.style.display != "")
            this.position();

        this.items = items;
        scilligence.Utils.removeAll(this.auto);
        var me = this;
        for (var i = 0; i < items.length; ++i) {
            var div = scilligence.Utils.createElement(this.auto, 'div', items[i]);
            dojo.connect(div, "onclick", function (e) { me.click(e); });
            dojo.connect(div, "onmouseover", function (e) { me.mouseover(e); });
            dojo.connect(div, "onmouseout", function (e) { me.mouseout(e); });
        }
    },

    position: function () {
        var p = scilligence.Utils.getOffset(this.input);
        var scroll = p.fixedposition ? new JSDraw2.Point(0, 0) : scilligence.Utils.scrollOffset();
        this.auto.style.position = p.fixedposition ? "fixed" : "absolute";
        var zIndex = scil.Utils.getZindex(this.input) + 1;
        if (scil.Utils.isIE) {
            var s2 = JsUtils.getScrollOffset(this.e);
            scroll.offset(-s2.x, -s2.y);
        }
        var w = this.input.offsetWidth;
        if (this.options.minautowidth > 0 && this.options.minautowidth > w)
            w = this.options.minautowidth;
        if (w < 100)
            w = 100;
        var pos = scil.Utils.isFixedPosition(this.input) ? "fixed" : "absolute";
        dojo.style(this.auto, { zIndex: zIndex, position: pos, display: "", width: (w - 2) + "px", left: (p.x + scroll.x) + "px", top: (p.y + scroll.y + this.input.offsetHeight) + "px" });
    },

    highlight: function (e) {
        if (this.auto == null || this.auto.style.display == "none")
            return;

        e.preventDefault();
        if (e.keyCode == 27) {
            this.hide();
            return;
        }

        var children = this.auto.childNodes;
        var sel = null;
        for (var i = 0; i < children.length; ++i) {
            var item = children[i];
            if (item.getAttribute("sel") == "1") {
                sel = i;
                break;
            }
        }

        if (e.keyCode == 13) {
            if (sel != null)
                this.clickItem(children[sel]);
            return;
        }

        var newsel = null;
        if (e.keyCode == 38 || e.keyCode == 40) {
            if (sel == null) {
                newsel = 0;
            }
            else if (e.keyCode == 38) {
                newsel = sel - 1;
                if (newsel < 0)
                    newsel = children.length - 1;
            }
            else {
                newsel = sel + 1;
                if (newsel >= children.length)
                    newsel = 0;
            }

            e.preventDefault();
        }

        if (newsel != null && newsel != sel) {
            if (sel != null)
                this._hilitItem(children[sel], false);
            this._hilitItem(children[newsel], true);
        }
    },

    mouseover: function (e) {
        this._hilitItem(e.srcElement || e.target, true);
    },

    mouseout: function (e) {
        this._hilitItem(e.srcElement || e.target, false);
    },

    _hilitItem: function (item, f) {
        if (f) {
            item.style.backgroundColor = "#ddf";
            item.setAttribute("sel", "1");
        }
        else {
            item.style.backgroundColor = "white";
            item.removeAttribute("sel");
        }
    },

    getItemValue: function (src) {
        var s = unescape(src.innerHTML);
        if (s == "&nbsp;")
            s = "";
        return s;
    },

    click: function (e) {
        var src = e.srcElement || e.target;
        this.clickItem(src);
    },

    clickItem: function (src) {
        var s = this.getItemValue(src);
        if (this.options.onSetValue != null)
            this.options.onSetValue(this.input, s);
        else if (this.options.overwrite == "unit")
            this.input.value = this.changeUnit(this.input.value, s);
        else if (this.options.overwrite == false)
            this.input.value += s;
        else
            this.input.value = s;
        this.hide();
        if (this.options.overwrite)
            this.input.select();
        this.input.focus();

        if (this.options.onclickitem != null)
            this.options.onclickitem(s);

        scil.Utils.fireEvent(this.input, "change", false, true);
    },

    clickout: function (e) {
        if (this.auto.style.display == "")
            this.auto.style.display = "none";
    }
});

scil.apply(scil.AutoComplete, {
    _all: [],

    hideAll: function () {
        for (var i = 0; i < this._all.length; ++i)
            this._all[i].hide();
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Progress class - To Show Progress
* @class {static} scilligence.Progress
* <pre>
* <b>Example:</b>
*    scilligence.Progress.show("Running", function() { alert("cancelled"); });
*    var count = 0;
*    setInterval(function() { scilligence.Progress.update(++count, "Value " + count); }, 500);
* </pre>
*/
scilligence.Progress = {
    dlg: null,
    bar: null,
    msg: null,
    oncancel: null,

    /**
    * Show progress bar
    * @function {static} show
    * @param {string} caption dialog caption
    * @param {function} or false: oncalcel callback function when users click on Cancel button
    * @param {string} msg Message
    * @param {boolean} showprogressbar
    * @returns null
    */
    show: function (caption, oncancel, msg, showprogressbar) {
        this.create();
        if (oncancel == false) {
            this.cancelbtn.style.display = "none";
            this.oncancel = null;
        }
        else if (typeof(oncancel) == "function") {
            this.cancelbtn.style.display = "";
            this.oncancel = oncancel;
        }
        this.msg.innerHTML = msg == null ? "" : msg;
        this.frame.style.display = showprogressbar == false ? "none" : "";
        this.dlg.show(caption);
    },

    hide: function () {
        if (this.dlg != null)
            this.dlg.hide();
    },

    cancel: function () {
        if (this.oncancel != null)
            this.oncancel();
        this.hide();
    },

    update: function (percent, msg) {
        if (percent > 100)
            percent = 100;
        else if (!(percent > 0))
            percent = 0;

        var n = Math.round(300 * percent / 100);
        if (n < 0)
            n = 0;
        this.bar.style.width = n + "px";
        this.msg.innerHTML = msg == null ? "" : msg;
    },
    
    create: function (u) {
        if (this.dlg != null)
            return false;

        var div = scilligence.Utils.createElement(null, "div", null, { margin: "5px", width: "320px", textAlign: "center" });
        this.animator = scilligence.Utils.createElement(div, "div", scil.Utils.imgTag("animator.gif"), { textAlign: "center" });
        this.msg = scilligence.Utils.createElement(div, "div", "&nbsp;", { textAlign: "center" });
        this.frame = scilligence.Utils.createElement(div, "div", null, { width: "300px", height: "20px", border: "solid 1px #e0e0e0", textAlign: "left" });
        this.bar = scilligence.Utils.createElement(this.frame, "div", "&nbsp;", { width: "1px", height: "20px", backgroundColor: "blue" });
        this.cancelbtn = scilligence.Utils.createElement(div, "button", scil.Utils.imgTag("cancel.gif") + "Cancel", { marginTop: "10px" });
        dojo.connect(this.cancelbtn, "onclick", function () { scilligence.Progress.cancel(); });

        this.dlg = new JSDraw2.Dialog("Progress", div);
        return true;
    }
};
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Table class - Table Control
* @class scilligence.Table
* <pre>
* <b>Constructor Parameters:</b>
* - addrow: {bool}, allow to add rows
* - columns: {key1: {labe, width, type}, key2: { ... } }
*    = label: {string}
*    = width: {int}
*    = type: {string}, any field type defined in scil.Form
*    = render: function(v, values) { return v; }
* - draggable: {bool}, be able to drag rows
* - delrow: {bool},  be able to delete rows
* - grouplinestyle: {string}
* - header: {bool}, indicate if showing headers
* - header0: [{label, colspan}]
* - hidecolumncookiekey: {string}
* - grouping: {bool}, group rows
* - pushleft: {bool}, push columns to the left side
* - rowcheck: {bool}, show row check
* - selectrow: {bool}, be able to select rows
* - viewonly: {bool}
* - ondrop: function(src, dest, this)
* - onAdd: function(this)
* - onselectrow: function(row, old)
* - onchange: function(this, e, item)
* - onBeforeAddRow: function(values)
* - onrowcheck: function(r, checked)
* - onAddRow: function(r, values)
*
* <b>Example 1:</b>
*    dojo.ready(function () {
*        var parent = scil.Utils.createElement(document.body, "div");
*        var columns = {
*            user: { label: "User", type: "input", width: 300 },
*            role: { label: "Role", type: "select", options: ["", "Member", "Manager"], width: 300 }
*        };
*        var table = new scilligence.Table({viewonly: false, header: true});
*        table.render(parent, columns);
*
*        table.setData([{ user: "Tony", role: "Member" }, { user: "Jack", role: "Manager"}]);
*    });
*
* <b>Example 2 (Double Header Table):</b>
*    &lt;script type="text/javascript"&gt;
*        var table;
*        dojo.ready(function () {
*            var parent = scil.Utils.createElement(document.body, "div");
*            var columns = {
*                mass: { label: "Mass", type: "number", align: "center", width: 200, unit: "g" },
*                file: { label: "NMR", type: "file", options: { uploadurl: "service.aspx?cmd=upload"} },
*                name: { label: "Compound Name", type: "input", width: 200 },
*                vendor: { label: "Vendor", type: "editableselect", options: ["Company A", "Company B"], width: 200 }
*            };
*            table = new scil.Table({ viewonly: true, header0: [null, { label: "Scilli", colspan: 2 }, { label: "Kinase"}] });
*            table.render(parent, columns);
*            table.addRow({ mass: 160, name: "Compound 123", vendor: "Sigma" });
*        });
*  &lt;/script&gt;
* </pre>
*/
scil.Table = scil.extend(scil._base, {
    /**
    * @constructor Table
    * @param {bool} viewonly
    * @param {bool} header
    * @param {dictionary} options - { viewonly(bool), header(bool), selectrow (bool), rowcheck(bool), delrow(bool), addrow (bool), selectrow (bool), onAdd, onselectrow, onchange }
    */
    constructor: function (viewonly, header, options) {
        if (viewonly != null && typeof (viewonly) == "object") {
            this.options = viewonly;
            this.viewonly = this.options.viewonly;
            this.header = this.options.header;
        }
        else {
            // old constructor: (viewonly, header, options)
            this.viewonly = viewonly;
            this.header = header;
            if (scil.Table._tableincrease == null)
                scil.Table._tableincrease = 0;
            this._tableid = ++scil.Table._tableincrease;

            if (typeof (options) == "function")
                this.options = { onAdd: options };
            else if (options == null)
                this.options = {};
            else
                this.options = options;
        }

        this.groupIndex = 0;
        this.checkIndex = 1;
        this.dataIndex = 2;
        this._startrow = 2;
        this.tbody = null;
        this.items = null;
        this.key = null;

        this._lastcheck = null;
    },

    /**
    * Get table data as xml
    * @function getData
    */
    getXml: function () {
        var n = this.tbody.childNodes.length - this._startrow;
        if (n == 0)
            return "";
        var xml = "<table>\n";
        for (var i = 0; i < n; ++i) {
            var tr = this.tbody.childNodes[i + this._startrow];

            var hasdata = false;
            var row = {};
            var j = this.dataIndex;
            for (var k in this.items) {
                var v = scil.Form.getFieldData(tr.childNodes[j++].field);
                row[k] = v;
                if (!hasdata && v != null && v != "")
                    hasdata = true;
            }

            if (!hasdata)
                continue;

            xml += "<r";
            if (tr.getAttribute("isnew") == "1")
                xml += " isnew='1'";
            xml += ">\n";
            for (var k in row) {
                var v = row[k];
                if (v != null && v != "")
                    xml += "<i n='" + scil.Utils.escXmlValue(k) + "'>" + scil.Utils.escXmlValue(v) + "</i>\n";
            }
            xml += "</r>\n";
        }
        xml += "</table>";
        return xml;
    },

    /**
    * Set table xml data
    * @function setXml
    * @param {xml} xml
    * @returns null
    */
    setXml: function (xml, lockeditems) {
        this.setData(scil.Table.xml2rows(xml), lockeditems);
    },

    getCsv: function () {
        var s = "";
        var i = 0;
        for (var k in this.items) {
            if (++i > 1)
                s += ",";
            s += scil.Utils.escCsvValue(this.items[k].label);
        }
        s += "\n";

        var n = this.tbody.childNodes.length - this._startrow;
        for (var j = 0; j < n; ++j) {
            var tr = this.tbody.childNodes[j + this._startrow];
            var row = this.getRowData(tr, true);

            i = 0;
            for (var k in this.items) {
                if (++i > 1)
                    s += ",";
                s += scil.Utils.escCsvValue(row[k]);
            }

            s += "\n";
        }
        return s;
    },

    /**
    * Get table data  - collection: { id.1: {...}, id.2 : {...}, ... }
    * @function getData
    * @param {dictionary} collection - the collection that data will be placed in
    * @param {string} id - id prefix
    */
    getData: function (collection, id, rowcheck) {
        if (collection == null) {
            var rows = [];
            var n = this.tbody.childNodes.length - this._startrow;
            for (var i = 0; i < n; ++i) {
                var tr = this.tbody.childNodes[i + this._startrow];
                var row = this.getRowData(tr, rowcheck);
                rows.push(row);
            }
            return rows;
        }
        else {
            var n = this.tbody.childNodes.length - this._startrow;
            collection[id + ".n"] = n;
            for (var i = 0; i < n; ++i) {
                var tr = this.tbody.childNodes[i + this._startrow];
                var key = id + "." + i + ".";
                if (tr.getAttribute("isnew") == "1")
                    collection[key + "isnew"] = 1;

                var j = this.dataIndex;
                for (var k in this.items)
                    collection[key + k] = scil.Form.getFieldData(tr.childNodes[j++].field);
            }
        }
    },

    /**
    * Get JSON data of a row
    * @function getRowData
    */
    getRowData: function (tr, rowcheck) {
        if (tr == null)
            return null;
        if (typeof (tr) == "number") {
            tr = this.tbody.childNodes[tr + this._startrow];
            if (tr == null)
                return null;
        }

        var row = {};
        if (tr.getAttribute("isnew") == "1")
            row.isnew = 1;

        var j = this.dataIndex;
        for (var k in this.items) {
            var td = tr.childNodes[j++];
            var v = td == null ? null : scil.Form.getFieldData(td.field);
            if (v != null && v != "")
                row[k] = v;
        }

        if (rowcheck && tr.childNodes[this.checkIndex].firstChild.checked)
            row.rowchecked = true;

        return row;
    },

    getRowTexts: function (tr) {
        if (tr == null)
            return null;
        if (typeof (tr) == "number") {
            tr = this.tbody.childNodes[tr + this._startrow];
            if (tr == null)
                return null;
        }

        var row = {};
        if (tr.getAttribute("isnew") == "1")
            row.isnew = 1;

        var j = this.dataIndex;
        for (var k in this.items) {
            var e = tr.childNodes[j++];
            var v = e.text || e.textContent;
            if (v != null && v != "")
                row[k] = v;
        }

        return row;
    },

    /**
    * Get JSON data of the current selected row
    * @function getCurrentRowData
    */
    getCurrentRowData: function () {
        return this.getRowData(this.currow);
    },

    /**
    * Set table data
    * @function setData
    * @param {array} data - the array of table data, one array item is for one row
    * @returns null
    */
    setData: function (data, lockeditems) {
        this.clear();
        if (data != null) {
            for (var i = 0; i < data.length; ++i)
                this.addRow(data[i], lockeditems);
        }

        if (!this.viewonly && this.options.addrow != false)
            this.addRow();
    },

    /**
    * Remove all rows
    * @function clear
    * @returns null
    */
    clear: function () {
        this.dirty = false;
        for (var i = this.tbody.childNodes.length - 1; i >= this._startrow; --i)
            this.tbody.removeChild(this.tbody.childNodes[i]);
        this.currow = null;
    },

    /**
    * Render table
    * @function render
    * @param {string or DOM} parent - parent element
    * @param {array} item - column definition as an array
    * @returns null
    */
    render: function (parent, items) {
        this.items = {};
        for (var id in items) {
            if (items[id] != null) {
                this.items[id] = items[id];
                if (items[id].iskey)
                    this.key = id;
            }
        }
        this._hideCookieCols(this.items);
        if (this.options.pushleft)
            this.items[""] = { label: "", width: this.options.pushleft > 100 ? this.options.pushleft : 5000 };

        if (typeof (parent) == "string")
            parent = dojo.byId(parent);

        var me = this;
        var div = scil.Utils.createElement(parent, 'div');
        this.tbody = scilligence.Utils.createTable(div, 0, 3, { borderRight: JSDraw2.Skin.jssdf.border, borderBottom: JSDraw2.Skin.jssdf.border, borderTop: JSDraw2.Skin.jssdf.border });
        this.tbody.parentNode.setAttribute("class", "scil_table");
        if (!this.viewonly && this.options.addrow != false) {
            var addbtn = scil.Utils.createElement(scil.Utils.createElement(div, "div"), "img", null, null, { src: scil.Utils.imgSrc("img/add.gif"), title: scil.Lang.res("Add") });
            dojo.connect(addbtn, "onclick", function () { if (me.options.onAdd != null) me.options.onAdd(me); else me.addRow(); });
        }

        if (this.options.draggable) {
            var me = this;
            scil.Utils.unselectable(this.tbody.parentNode);
            new scil.DnD(this.tbody.parentNode, {
                onstartdrag: function (e) {
                    var src = e.target || e.srcElement;
                    if (src.tagName == "DIV" && src.parentNode.tagName == "TD")
                        return src.parentNode.parentNode;
                },
                oncreatecopy: function (e, dd) {
                    var src = dd.src;
                    var tbody = scil.Utils.createTable(document.body, 0, 0, { position: "absolute", border: "solid 1px #888", background: "white", opacity: 0.6 });
                    var tr = scil.Utils.createElement(tbody, "tr");
                    var list = src.childNodes;
                    for (var i = 0; i < Math.min(8, list.length); ++i) {
                        td = list[i].cloneNode(true);
                        td.style.width = list[i].offsetWidth + "px";
                        td.style.height = list[i].offsetHeight + "px";
                        tr.appendChild(td);
                    }
                    return tbody.parentNode;
                },
                ondrop: function (e, dd) {
                    if (dd.copy != null)
                        dd.copy.parentNode.removeChild(dd.copy);

                    var src = e.target || e.srcElement;
                    if (src.tagName == "DIV" && src.parentNode.tagName == "TD") {
                        if (me.options.ondrop != null)
                            me.options.ondrop(dd.src, src.parentNode.parentNode, me);
                    }
                },
            });
        }

        var style = scil.clone(scil.Table.headerstyles);
        style.borderBottom = JSDraw2.Skin.jssdf.border;
        style.borderLeft = JSDraw2.Skin.jssdf.border;

        var r0 = scil.Utils.createElement(this.tbody, "tr");
        var header0 = this.options.header0;
        var r = scil.Utils.createElement(this.tbody, "tr");
        if (header0 != null) {
            scil.Utils.createElement(r0, "td", null, { display: this.options.grouping ? "" : "none" });
            var td = scil.Utils.createElement(r0, "td", null, style);
            td.style.display = this.options.rowcheck ? "" : "none";

            for (var i = 0; i < header0.length; ++i) {
                var item = header0[i];
                if (item == null) {
                    scil.Utils.createElement(r0, "td");
                }
                else {
                    var td = scil.Utils.createElement(r0, "td", scil.Lang.res(item.label), style, { colSpan: item.colspan });
                    td.style.textAlign = "center";
                }
            }
        }

        var td = scil.Utils.createElement(r, "td", null, scil.Table.headerstyles);
        if (this.options.grouping) {
            td.style.width = "5px";
            scil.Utils.createElement(td, "img", null, null, { src: scil.Utils.imgSrc("img/minus.gif") }, function (e) { me.groupExpandAll(e); });
        }
        else {
            td.style.display = "none";
        }

        var td = scil.Utils.createElement(r, "td", null, scil.Table.headerstyles);
        if (this.options.rowcheck) {
            td.style.width = "5px";
            if (this.options.rowcheck != "radio")
                scil.Utils.createElement(td, "checkbox", null, null, null, function (e) { me.checkAll((e.srcElement || e.target).checked); });
        }
        else {
            td.style.display = "none";
        }

        for (var id in this.items) {
            var item = this.items[id];
            var s = scil.Lang.res(item.label);
            if (item.unit != null && item.unit != "")
                s += " (" + scil.Lang.res(item.unit) + ")";
            var td = scil.Utils.createElement(r, "td", null, style, { key: id });
            var div = scil.Utils.createElement(td, "div", s, { width: "100%" });
            if (item.width > 0)
                td.style.width = item.width + "px";
            if (item.type == "hidden" || item.ishidden)
                td.style.display = "none";

            if (item.whitespace != null)
                td.style.whiteSpace = item.whitespace;

            if (item.type == "checkbox" && item.headercheckbox != false && !this.viewonly && !item.viewonly) {
                var chk = scil.Utils.createElement(td, "checkbox");
                this.connectCheckAll(chk, id);
            }
        }
        if (this.header == false)
            r.style.display = "none";
        if (!this.viewonly) {
            if (this.options.delrow != false)
                scil.Utils.createElement(r, "td", "&nbsp;", style);
            this.addRow();
        }

        if (this.options.selectrow)
            dojo.connect(this.tbody, "onclick", function (e) { me.clickRow(e); });
    },

    connectCheckAll: function (chk, id) {
        var me = this;
        dojo.connect(chk, "onclick", function (e) { me.checkAll((e.srcElement || e.target).checked, id); });
    },

    hidColumn: function (key) {
        return this.showColumn(key, false);
    },

    /**
    * Show or hide a column
    * @function showColumn
    * @param {string} key
    * @param {bool} f
    * @returns true or false
    */
    showColumn: function (key, f) {
        if (this.options.header0 != null)
            return false;

        if (f == null)
            f = true;

        var item = this.items[key];
        if (item == null || item.type == "hidden")
            return false;
        item.ishidden = !f;

        if (this.tbody == null || this.tbody.childNodes.length <= 1)
            return false;

        var icol = this.getColIndex(key);
        if (icol == -1)
            return false;

        for (var i = 1; i < this.tbody.childNodes.length; ++i)
            this.tbody.childNodes[i].childNodes[icol].style.display = f ? "" : "none";

        return true;
    },

    getColIndex: function (key) {
        var tr = this.tbody.childNodes[1];
        for (var i = 0; i < tr.childNodes.length; ++i) {
            if (tr.childNodes[i].getAttribute("key") == key)
                return i;
        }

        return -1;
    },

    /**
    * Check all rows
    * @function checkAll
    */
    checkAll: function (f, key) {
        var nodes = this.tbody.childNodes;
        if (key == null) {
            for (var i = this._startrow; i < nodes.length; ++i) {
                if (nodes[i].style.display == "none")
                    nodes[i].childNodes[this.checkIndex].firstChild.checked = false;
                else
                    nodes[i].childNodes[this.checkIndex].firstChild.checked = f;
            }
        }
        else {
            var icol = this.getColIndex(key);
            if (icol == -1)
                return false;

            for (var i = this._startrow; i < nodes.length; ++i) {
                if (nodes[i].style.display == "none") {
                    nodes[i].childNodes[this.checkIndex].firstChild.checked = false;
                }
                else {
                    var td = nodes[i].childNodes[icol];
                    var list = td.getElementsByTagName("input");
                    if (list != null && list.length == 1)
                        list[0].checked = f;
                }
            }
        }
    },

    _isChecked: function (tr) {
        return tr.childNodes[this.checkIndex].firstChild.checked;
    },

    /**
    * Get checked rows
    * @function getCheckedRows
    */
    getCheckedRows: function (withcurrent) {
        var ret = [];
        var list = this.tbody.childNodes;
        for (var i = this._startrow; i < list.length; ++i) {
            if (this._isChecked(list[i]))
                ret.push(i - this._startrow);
        }

        if (ret.length == 0 && withcurrent && this.currow != null) {
            for (var i = this._startrow; i < list.length; ++i) {
                if (this.currow == list[i]) {
                    ret.push(i - this._startrow);
                    break;
                }
            }
        }
        return ret;
    },

    /**
    * Check a row by using its key.  If no row checked, it returns selected row.
    * @function getCheckedKeys2
    */
    getCheckedRows2: function () {
        return this.getCheckedKeys(true);
    },

    /**
    * Get checked row data
    * @function getCheckedRowData
    */
    getCheckedRowData: function (withcurrent) {
        var ret = [];
        var list = this.tbody.childNodes;
        for (var i = this._startrow; i < list.length; ++i) {
            if (this._isChecked(list[i]))
                ret.push(this.getRowData(list[i]));
        }

        if (ret.length == 0 && withcurrent) {
            var d = this.getCurrentRowData();
            if (d != null)
                ret.push(d);
        }
        return ret;
    },

    /**
    * Get checked row data.  If no row checked, it will use the current row
    * @function getCheckedRowData2
    */
    getCheckedRowData2: function () {
        return this.getCheckedRowData(true);
    },

    /**
    * Get key of a row
    * @function getKey
    */
    getKey: function (tr) {
        return tr == null ? null : tr.getAttribute("key");
    },

    /**
    * Check a row by using its key
    * @function checkRow
    */
    checkRow: function (key) {
        if (!this.options.rowcheck)
            return;

        if (typeof key == "string") {
            var tr = this._findByKey(key);
            if (tr != null)
                tr.childNodes[this.checkIndex].firstChild.checked = true;
        }
        else if (typeof key == "object") {
            var tr = key;
            if (tr.tagName == "TR")
                tr.childNodes[this.checkIndex].firstChild.checked = true;
        }
    },

    _findByKey: function (key) {
        var list = this.tbody.childNodes;
        for (var i = this._startrow; i < list.length; ++i)
            if (list[i].getAttribute("key") == key)
                return list[i];
        return null;
    },

    checkRows: function (keys) {
        if (keys == null)
            return;

        var list = this.tbody.childNodes;
        for (var i = 0; i < list.length; ++i) {
            if (scil.Utils.indexOf(keys, list[i].getAttribute("key")) >= 0)
                this.checkRow(list[i], true);
        }
    },

    /**
    * Get all keys of checked rows
    * @function getCheckedKeys
    */
    getCheckedKeys: function (withcurrent) {
        var ret = [];
        var list = this.tbody.childNodes;
        for (var i = this._startrow; i < list.length; ++i) {
            if (this._isChecked(list[i]))
                ret.push(list[i].getAttribute("key"));
        }

        if (ret.length == 0 && withcurrent) {
            var key = this.getCurrentKey();
            if (key != null)
                ret.push(key);
        }
        return ret;
    },

    /**
    * Get all keys of checked rows.  If no row checked, it returns selected row.
    * @function getCheckedKeys2
    */
    getCheckedKeys2: function () {
        return this.getCheckedKeys(true);
    },

    /**
    * Get the key of current row
    * @function getCurrentKey
    */
    getCurrentKey: function () {
        if (this.currow == null)
            return null;

        var key = this.currow.getAttribute("key");
        return key == "" ? null : key;
    },

    clickRow: function (e) {
        var src = e.srcElement || e.target;
        var src;
        if (src.tagName == "TR")
            tr = src;
        else if (src.tagName == "A")
            return;
        else
            tr = scil.Utils.getParent(src, "TR");

        if (tr != null && this.tbody != tr.parentNode)
            tr = null;
        this.selectRow(tr);
    },

    selectFirstRow: function () {
        var tr = this.tbody.childNodes[this._startrow];
        this.selectRow(tr);
    },

    findRow: function (key) {
        var list = this.tbody.childNodes;
        for (var i = this._startrow; i < list.length; ++i) {
            if (list[i].getAttribute("key") == key)
                return list[i];
        }
        return null;
    },

    selectRow: function (tr) {
        if (typeof (tr) == "string")
            tr = this.findRow(tr);

        var i = scil.Utils.indexOf(this.tbody.childNodes, tr);
        if (i < this._startrow)
            return;

        var old = this.currow;
        if (this.currow != null)
            this.currow.style.backgroundColor = this.currow.getAttribute("bgcolor");
        this.currow = tr;
        if (this.currow != null)
            this.currow.style.backgroundColor = JSDraw2.Skin.jssdf.rowcolor;

        if (this.options.onselectrow != null)
            this.options.onselectrow(this.currow, old);
    },

    /**
    * Delete a row
    * @function delRow
    * @param {string} key the key value
    * @returns true or false
    */
    delRow: function (key) {
        var list = this.tbody.childNodes;
        for (var i = 0; i < list.length; ++i) {
            if (list[i].getAttribute("key") == key) {
                this.tbody.removeChild(list[i]);
                if (this.options.onchange != null)
                    this.options.onchange(this);
                this.dirty = true;
                return true;
            }
        }
        return false;
    },

    /**
    * Update a row
    * @function updateRow
    * @param {string} key the key value
    * @param {dictionary} data row data
    * @returns true or false
    */
    updateRow: function (key, data) {
        var list = this.tbody.childNodes;
        for (var i = this._startrow; i < list.length; ++i) {
            if (list[i].getAttribute("key") == key) {
                var tr = list[i];
                if (data == null)
                    data = {};
                data.rowchecked = this.options.rowcheck && tr.childNodes[this.checkIndex].firstChild.checked;
                var r = this.addRow(data, null, tr);
                this.tbody.removeChild(tr);
                if (this.currow == tr)
                    this.selectRow(r);
                return true;
            }
        }
        return false;
    },

    /**
    * Set cell value
    * @function setCellValue2
    * @param {string/number/DOM} rowkey the key of the row, or row index, or TR
    * @param {string} colkey the key of the column
    * @param {object} value
    * @returns true or false
    */
    setCellValue2: function (rowkey, colkey, value) {
        if (this.items[colkey] == null)
            return false;

        var tr = null;
        if (typeof (rowkey) == "number") {
            tr = this.tbody.childNodes[this._startrow + rowkey];
        }
        else if (typeof (rowkey) == "object" && rowkey.tagName == "TR") {
            tr = rowkey
        }
        else {
            var list = this.tbody.childNodes;
            for (var i = this._startrow; i < list.length; ++i) {
                if (list[i].getAttribute("key") == rowkey) {
                    tr = list[i];
                    break;
                }
            }
        }

        if (tr == null)
            return false;

        for (var i = 0; i < tr.childNodes.length; ++i) {
            var td = tr.childNodes[i];
            if (td.getAttribute("__tid") == colkey && td.field != null) {
                scil.Form.setFieldData(td.field, this.items[colkey], this.viewonly, value);
                return true;
            }
        }

        return false;
    },

    /**
    * Get cell value
    * @function getCellValue2
    * @param {string/number} rowkey the key of the row, or row index
    * @param {string} colkey the key of the column
    * @returns the cell value
    */
    getCellValue2: function (rowkey, colkey) {
        if (this.items[colkey] == null)
            return null;

        var tr = null;
        if (typeof (rowkey) == "number") {
            tr = this.tbody.childNodes[this._startrow + rowkey];
        }
        else {
            var list = this.tbody.childNodes;
            for (var i = this._startrow; i < list.length; ++i) {
                if (list[i].getAttribute("key") == rowkey) {
                    tr = list[i];
                    break;
                }
            }
        }

        if (tr == null)
            return null;

        for (var i = 0; i < tr.childNodes.length; ++i) {
            var td = tr.childNodes[i];
            if (td.getAttribute("__tid") == colkey && td.field != null)
                return scil.Form.getFieldData(td.field);
        }

        return null;
    },

    _hilitRow: function (e, f) {
        var tr = e.target || e.srcElement;
        if (tr.tagName != "TR")
            tr = scil.Utils.getParent(tr, "TR");
        if (tr == null || tr.getAttribute("sciltable") != "1")
            return;

        if (f || tr == this.currow)
            tr.style.backgroundColor = JSDraw2.Skin.jssdf.rowcolor;
        else
            tr.style.backgroundColor = tr.getAttribute("bgcolor");
    },

    groupExpandAll: function (e) {
        var img = e.target || e.srcElement;
        var f = scil.Utils.endswith(img.src, "minus.gif");
        img.src = scil.Utils.imgSrc("img/" + (f ? "plus" : "minus") + ".gif");

        var tr = this.tbody.childNodes[this._startrow];
        while (tr != null)
            tr = this.groupExpand(tr, f);
    },

    groupExpand: function (tr, f) {
        var s0 = this.getCellValue(tr, this.options.grouping);
        if (scil.Utils.isNullOrEmpty(s0))
            return null;

        var img = tr.childNodes[this.groupIndex].firstChild;
        if (img.tagName != "IMG")
            return null;
        if (f == null) {
            f = scil.Utils.endswith(img.src, "minus.gif");
        }

        var n = 0;
        while ((tr = tr.nextSibling) != null) {
            var s = this.getCellValue(tr, this.options.grouping);
            if (s0 != s)
                break;
            ++n;
            tr.style.display = f ? "none" : "";
        }

        img.src = scil.Utils.imgSrc("img/" + (f ? (n > 0 ? "plus" : "plus0") : "minus") + ".gif");
        return tr;
    },

    /**
    * Add a row
    * @function addRow
    * @param {dictionary} values row values
    * @param {reserved} lockeditems
    * @param {DOM} beforerow new row will be inserted before this row
    * @returns null
    */
    addRow: function (values, lockeditems, beforerow) {
        if (values == null && this.options.onAdd != null)
            return null;

        if (this.options.onBeforeAddRow != null)
            values = this.options.onBeforeAddRow(values);

        var me = this;
        var bgcolor = this.tbody.childNodes.length % 2 == 1 ? JSDraw2.Skin.jssdf.oddcolor : JSDraw2.Skin.jssdf.evencolor;
        var r = scil.Utils.createElement(null, "tr", null, { backgroundColor: bgcolor }, { sciltable: "1", bgcolor: bgcolor });
        if (beforerow == null)
            this.tbody.appendChild(r);
        else
            this.tbody.insertBefore(r, beforerow);

        dojo.connect(this.tbody.parentNode, "onmouseover", function (e) { me._hilitRow(e, true); });
        dojo.connect(this.tbody.parentNode, "onmouseout", function (e) { me._hilitRow(e, false); });

        var newgroup = false;
        var td = scil.Utils.createElement(r, "td");
        if (this.options.grouping) {
            var s = values == null ? null : values[this.options.grouping];
            var s0 = this.getCellValue(r.previousSibling, this.options.grouping);
            if (scil.Utils.isNullOrEmpty(s) || s != s0) {
                newgroup = true;
                var img = scil.Utils.createElement(td, "img", null, null, { title: "Expand/Collapse All", src: scil.Utils.imgSrc("img/minus.gif") });
                scil.connect(img, "onclick", function (e) { me.groupExpand(r); })
            }
        }
        else {
            td.style.display = "none";
        }

        var td = scil.Utils.createElement(r, "td");
        if (this.options.rowcheck) {
            var name = this.options.rowcheck == "radio" ? "__scil_table_" + this._tableid + "_radio" : null;
            var checktype = this.options.rowcheck == "radio" ? "radio" : "checkbox";
            var check = scil.Utils.createElement(td, checktype, null, null, { name: name });
            check.checked = values == null ? false : values.rowchecked;
            if (this.options.onrowcheck != null)
                dojo.connect(check, "onchange", function () { me.options.onrowcheck(r, check.checked); });

            if (checktype == "checkbox")
                scil.connect(check, "onclick", function (e) { me.checkedClick(e); });
        }
        else {
            td.style.display = "none";
        }

        if (values == null) {
            r.setAttribute("isnew", "1");
        }
        else {
            if (this.key != null && values[this.key] != null)
                r.setAttribute("key", values[this.key]);
        }

        for (var id in this.items) {
            var item = this.items[id];
            var td = scil.Utils.createElement(r, "td", null, item.styles, item.attributes);
            td.style.borderLeft = JSDraw2.Skin.jssdf.border;
            if (item.type == "hidden" || item.ishidden)
                td.style.display = "none";

            var viewonly = this.viewonly || item.viewonly || lockeditems != null && lockeditems[id];
            var v = values == null ? item.value : values[id];
            if (!(viewonly && this.options.notshowifnovalue && scil.Utils.isNullOrEmpty(v))) {
                td.field = scil.Form.createField(td, item, viewonly, v, values, true, true);
                if (viewonly && item.type != "img") {
                    td.field.style.width = "100%";
                }
                else {
                    if (td.field.tagName == "INPUT" || td.field.tagName == "SELECT" || td.field.tagName == "TEXTAREA") {
                        this._connectOnchange(td.field, item);
                        if (item.addrowonenter && beforerow == null)
                            td.field.focus();
                    }
                }
            }

            if (item.whitespace != null)
                td.style.whiteSpace = item.whitespace;

            td.setAttribute("__tid", id);
            this.connectKeydown(td, item);
        }

        if (!this.viewonly && lockeditems == null && this.options.delrow != false) {
            var td = scil.Utils.createElement(r, "td");
            td.style.borderLeft = JSDraw2.Skin.jssdf.border;
            var b = scil.Utils.createElement(td, "img", null, null, { src: scil.Utils.imgSrc("img/del.gif"), title: scil.Lang.res("Delete") });
            dojo.connect(b, "onclick", function () { me.removeRow(this); });
        }

        if (this.options.onAddRow != null)
            this.options.onAddRow(r, values);

        if (newgroup && this.options.grouplinestyle != null) {
            for (var i = 0; i < r.childNodes.length; ++i)
                r.childNodes[i].style.borderTop = this.options.grouplinestyle;
        }

        return r;
    },

    checkedClick: function (e) {
        var check = e.srcElement || e.target;
        if (!check.checked)
            return;

        if (e.shiftKey) {
            var nodes = this.tbody.childNodes;
            var start = scil.Utils.indexOf(nodes, scil.Utils.getParent(this._lastcheck, "TR"));
            var end = scil.Utils.indexOf(nodes, scil.Utils.getParent(check, "TR"));
            if (st != -1 && ed != -1) {
                var st = Math.min(start, end);
                var ed = Math.max(start, end);
                for (var i = st; i <= ed; ++i) {
                    if (nodes[i].style.display == "none")
                        nodes[i].childNodes[this.checkIndex].firstChild.checked = false;
                    else
                        nodes[i].childNodes[this.checkIndex].firstChild.checked = true;
                }
            }
        }
        this._lastcheck = check;
    },

    _connectOnchange: function (field, item) {
        var me = this;
        dojo.connect(field, "onchange", function (e) { me.onchange(e, item); });
    },

    setCellValue: function (tr, key, v) {
        for (var i = 0; i < tr.childNodes.length; ++i) {
            var td = tr.childNodes[i];
            if (td.field != null && td.getAttribute("__tid") == key) {
                scil.Form.setFieldData(td.field, this.items[key], this.viewonly, v);
                break;
            }
        }
    },

    getCellValue: function (tr, key) {
        for (var i = 0; i < tr.childNodes.length; ++i) {
            var td = tr.childNodes[i];
            if (td.field != null && td.getAttribute("__tid") == key)
                return scil.Form.getFieldData(td.field);
        }
        return null;
    },

    connectKeydown: function (td, item) {
        if (this.viewonly || td.field.tagName != "INPUT" || !item.addrowonenter)
            return;

        var me = this;
        dojo.connect(td.field, "onkeydown", function (e) {
            if (e.keyCode == 13) {
                var tr = scil.Utils.getParent(td, "TR");
                if (typeof (item.addrowonenter) == "function")
                    item.addrowonenter(td, item, me);
                if (me.tbody.childNodes[me.tbody.childNodes.length - 1] == tr)
                    me.addRow();
            }
        });
    },

    onchange: function (e, item) {
        this.dirty = true;
        if (this.options.onchange != null)
            this.options.onchange(this, e, item);
    },

    removeRow: function (img) {
        var me = this;
        scil.Utils.confirmYes("Delete this row?", function () {
            var tr = scilligence.Utils.getParent(img, "TR");
            tr.parentNode.removeChild(tr);
            if (me.options.onchange != null)
                me.options.onchange(this);
            me.dirty = true;
        });
    },

    showHideColumns: function () {
        if (this.showhideDlg == null) {
            var columns = {
                caption: { label: "Caption", width: 400 },
                key: { label: "Key", width: 100, iskey: true }
            };

            var me = this;
            var fields = { table: { type: "table", columns: columns, options: { rowcheck: true, viewonly: true } } };
            this.showhideDlg = scil.Form.createDlgForm("Show/Hide Columns", fields, { label: "OK", onclick: function () { me.showHideColumns2(); } }, { hidelabel: true });
        }

        this.showhideDlg.show();

        var rows = [];
        for (var k in this.items) {
            if (this.items[k].type != "hidden")
                rows.push({ caption: this.items[k].label, key: k, rowchecked: !this.items[k].ishidden });
        }
        this.showhideDlg.form.setData({ table: rows });
        this.showhideDlg.moveCenter();
    },

    showHideColumns2: function () {
        var cols = "";

        var table = this.showhideDlg.form.fields.table.jsd;
        var list = table.getData(null, null, true);
        for (var i = 0; i < list.length; ++i) {
            var f = list[i].rowchecked == true;
            this.showColumn(list[i].key, f);
            if (!f)
                cols += list[i].key + ",";
        }
        this.showhideDlg.hide();

        if (!scil.Utils.isNullOrEmpty(this.options.hidecolumncookiekey))
            scil.Utils.createCookie(this.options.hidecolumncookiekey + "_scil_table_hidecols", cols, 3650); // 10 years
    },

    _hideCookieCols: function (cols) {
        if (scil.Utils.isNullOrEmpty(this.options.hidecolumncookiekey))
            return;

        var s = scil.Utils.readCookie(this.options.hidecolumncookiekey + "_scil_table_hidecols");
        if (scil.Utils.isNullOrEmpty(s))
            return;

        var ss = s.split(',');
        for (var i = 0; i < ss.length; ++i) {
            var col = cols[ss[i]];
            if (col != null)
                cols[ss[i]].ishidden = true;
        }
    }
});


scilligence.apply(scilligence.Table, {
    headerstyles: { /*border: "solid 1px #eee", */whiteSpace: "nowrap", textAlign: "center", verticalAlign: "top", backgroundColor: "#bbb" }, //scil.Utils.imgSrc("img/header-bg.gif", true) + " repeat-x" },

    /**
    * Create a table
    * @function {static} create
    * @param {object} obj the data object to be loaded into the table. obj.load() will be called
    * @param {string or DOM} parent parent element
    * @param {array} items table column items. item: { id, iskey ... }
    * @param {bool} viewonly indicate if creating a viewonly table
    * @returns a new Table object
    */
    create: function (obj, parent, items, viewonly, loadimmediately) {
        if (typeof parent == "string")
            parent = dojo.byId(parent);

        var div = scil.Utils.createElement(parent, "div");
        var table = new scil.Table(viewonly);
        table.render(div, items);

        if (loadimmediately != false && obj.load != null)
            scil.onload(function () { obj.load(); });
        return table;
    },

    /**
    * List pages
    * @function {static} listPages
    * @param {DOM} div - parent div
    * @param {number} page
    * @param {number} totalpages
    * @param {function} onclick(page) {}
    */
    listPages: function (div, page, totalpages, onclick) {
        scil.Utils.removeAll(div);
        if (!(page >= 1) || !(totalpages > 1))
            return;

        --page;

        var st, ed;
        if (totalpages <= 11) {
            st = 0;
            ed = totalpages;
        }
        else {
            st = page - 5;
            if (st < 0)
                st = 0;
            ed = st + 11;
            if (ed > totalpages)
                ed = totalpages;
            if (ed - st < 11) {
                st = ed - 11;
                if (st < 0)
                    st = 0;
            }
        }

        this.createPage(div, scil.Lang.res("Previous Page"), page > 0 ? page : null, onclick);

        if (st > 0) {
            this.createPage(div, 1, 1, onclick);
            if (st > 1)
                this.createPage(div, "...", null, onclick);
        }

        for (var k = st; k < page; ++k)
            this.createPage(div, k + 1, k + 1, onclick);
        this.createPage(div, page + 1, null, onclick);
        for (var k = page + 1; k < ed; ++k)
            this.createPage(div, k + 1, k + 1, onclick);
        if (ed < totalpages) {
            if (ed + 1 < totalpages)
                this.createPage(div, "...", null, onclick);
            this.createPage(div, totalpages, totalpages, onclick);
        }

        this.createPage(div, scil.Lang.res("Next Page"), page + 1 < totalpages ? page + 2 : null, onclick);
    },

    createPage: function (div, label, page, onclick) {
        if (page == null)
            scil.Utils.createElement(div, "span", label);
        else
            scil.Utils.createButton(div, { label: label, type: "a", onclick: function () { onclick(page); } });

        scil.Utils.createElement(div, "span", "&nbsp;");
    },

    rows2xml: function (rows) {
        if (rows == null)
            return null;

        var s = "<table>";
        for (var i = 0; i < rows.length; ++i) {
            var r = rows[i];
            s += "<r>";
            for (var k in r) {
                var v = r[k];
                if (!scil.Utils.isNullOrEmpty(v))
                    s += "<i n='" + scil.Utils.escXmlValue(k) + "'>" + scil.Utils.escXmlValue(v) + "</i>";
            }
            s += "</r>";
        }
        s += "</table>";
        return s;
    },

    xml2rows: function (xml) {
        var root = null;
        if (typeof xml == "object") {
            root = xml;
        }
        else if (typeof xml == "string") {
            var doc = scil.Utils.parseXml(xml);
            if (doc != null)
                root = doc.documentElement || doc.firstElementChild;
        }

        var data = [];
        try {
            if (root != null && root.getElementsByTagName == null)
                root = null;
        }
        catch (e) {
        }

        if (root != null) {
            var rows = root.getElementsByTagName("r");
            for (var i = 0; i < rows.length; ++i) {
                var row = {};

                var cells = rows[i].getElementsByTagName("i");
                for (var j = 0; j < cells.length; ++j) {
                    var e = cells[j];
                    var k = e.getAttribute("n");
                    row[k] = e.text || e.textContent;
                }

                data.push(row);
            }
        }

        return data;
    }
});
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Tree class - Tree Control
* @class scilligence.Tree
* <pre>
* <b>Example:</b>
*    var parent = scil.Utils.createElement(document.body, "div");
*    var ac = scil.Tree(parent, { url: "/path/ajax.ashx?cmd=loadtree" });
* </pre>
*/
scil.Tree = scil.extend(scil._base, {
    /**
    * @constructor Tree
    * @param {string or DOM} parent - the parent element
    * @param {dictionary} options
    * @param {bool} solo
    */
    constructor: function (parent, options, solo, dropdown) {
        this.container = parent;
        this.options = options == null ? {} : options;
        this.solo = solo != null ? solo : this.options.solo;
        this.dropdown = dropdown != null ? dropdown : this.options.dropdown;

        this.onAddItem = null;
        this.onSelectItem = null;
        this.onExpandItem = null;
        this.cur = null;
        this.margin = 28;
        this.idname = "id";

        var me = this;
        scil.Utils.removeAll(parent);
        //dojo.connect(parent, "onclick", function (e) { me.onSelect(e.srcElement || e.target); });
    },

    clear: function () {
        scil.Utils.removeAll(this.container);
    },

    reloadCur: function () {
        if (this.cur == null)
            return;

        this.reload(this.cur);
    },

    reload: function (node) {
        if (node == null)
            return false;

        node.removeAttribute("loaded");
        if (node.firstChild.nextSibling != null)
            node.removeChild(node.firstChild.nextSibling);

        if (!node.item.leaf) {
            var img = this._expand(node);
            this.onExpand(img);
        }
        return true;
    },

    getCurRoot: function () {
        return this.getRoot(this.cur);
    },

    getRoot: function (node) {
        if (node == null)
            return null;

        var n = this.getParent(node);
        var p = node;
        while (n != null) {
            p = n;
            n = this.getParent(p);
        }
        return p;
    },

    getParent: function (node) {
        return node.parentNode == null || node.parentNode == this.container ? null : node.parentNode.parentNode;
    },

    add: function (parent, item) {
        if (item == null)
            return null;

        if (item.length != null) {
            for (var i = 0; i < item.length; ++i)
                this.add(parent, item[i]);
            return null;
        }

        if (item._more)
            item.leaf = true;
        if (this.options.onAddItem != null)
            item = this.options.onAddItem(item);
        else if (this.onAddItem != null)
            item = this.onAddItem(item);

        var n = null;
        if (parent == null) {
            n = scilligence.Utils.createElement(this.container, "div");
        }
        else {
            var container = parent.firstChild.nextSibling;
            if (container == null)
                container = scil.Utils.createElement(parent, "div", null, { marginLeft: this.margin + "px" });
            n = scil.Utils.createElement(container, "div");
        }

        n.item = item;

        var m = scil.Utils.createElement(n, "div", null, { padding: "3px 0 3px 0", whiteSpace: "nowrap" });
        var img = scil.Utils.createElement(m, "img", null, { width: "16px" }, item.leaf || item.disabled ? { src: scil.Utils.imgSrc("img/blank.gif")} : { src: scil.Utils.imgSrc("img/plus.gif"), title: "Expand" });
        var me = this;
        dojo.connect(img, "onclick", function (e) { me.onExpand(e.srcElement || e.target); });
        if (this.dropdown)
            scil.Utils.createElement(m, "img", null, null, { src: item.shortcut ? "img/status_shortcut.gif" : "img/status_" + (item.status == null || item.status == "" ? "open" : item.status) + ".gif" });
        if (item.icon != null) {
            if (item.icon.indexOf('/') < 0)
                item.icon = "img/icons/" + item.icon + ".gif";
            scil.Utils.createElement(m, "img", null, { paddingRight: this.options.icongap }, { src: item.icon });
        }

        scil.Utils.createElement(m, "span", item._more ? "<u style='color:blue;cursor:pointer'>more...</u>" : item.name, null, { title: item.tooltip });
        m.className = "tbar";
        if (item.disabled) {
            m.style.color = "gray";
            m.setAttribute("disabled", "on");
        }
        else {
            m.style.cursor = "pointer";
            dojo.connect(m, "onclick", function (e) { if ((e.target || e.srcElement) != m.firstChild) me.select(m.parentNode); });
        }

        this.add(n, item.children);
        if (parent != null)
            this.expand(parent, true);
        if (item.expand == false)
            this.expand(n, false);

        if (item.selected)
            this.select(n);
        return n;
    },

    expand: function (node, f) {
        var bar = node.firstChild;
        var img = bar.firstChild;
        if (bar.nextSibling == null) {
            img.src = "img/blank.gif";
            img.removeAttribute("title");
        }
        else {
            bar.nextSibling.style.display = f ? "" : "none";
            this._expand(node, f);
        }
    },

    _expand: function (node, f) {
        var img = node.firstChild.firstChild;
        img.src = scil.Utils.imgSrc(f ? "img/minus.gif" : "img/plus.gif");
        img.setAttribute("title", f ? "Shrink" : "Expand");
        return img;
    },

    shrinkSiblings: function (node) {
        var list = node.parentNode.childNodes;
        for (var i = 0; i < list.length; ++i) {
            if (list[i] != node)
                this.expand(list[i], false);
        }
    },

    onExpand: function (img) {
        if (img == null)
            return null;

        var bar = img.parentNode;
        if (bar.tagName != "DIV" || bar.className != "tbar")
            return;

        var f = null;
        var n = bar.parentNode;
        if (n != null && n.item != null && n.item.leaf)
            return;

        if (this.options.url == null || n.getAttribute("loaded") == "1" || bar.nextSibling != null) {
            f = bar.nextSibling == null || bar.nextSibling.style.display == "none";
            this.expand(n, f);
            if (f && this.solo)
                this.shrinkSiblings(n);
            return;
        }

        if (this.onExpandItem != null) {
            if (this.onExpandItem(n, f))
                return;
        }

        this.loadNodes(n);
    },

    loadNodes: function (n) {
        var me = this;
        var fn = function (ret) {
            if (n.item._more) {
                var parent = n.parentNode;
                parent.removeChild(n);
                n = parent.parentNode;
            }
            else {
                if (n.getAttribute("loaded") == "1")
                    return;
                n.setAttribute("loaded", "1");
            }

            if (ret.rows != null && ret.rows.length > 0)
                me.add(n, ret.rows);
            else if (ret.length > 0)
                me.add(n, ret);
            me.expand(n, true);
        };

        if (n.item.children != null) {
            fn(n.item.children);
            return;
        }

        var beforeload = function () { n.firstChild.firstChild.src = scil.Utils.imgSrc("img/animatorsmall.gif") };
        var afterload = function () { n.firstChild.firstChild.src = scil.Utils.imgSrc("img/plus.gif") };

        var args = n.item;
        if (args._more) {
            var p = this.getParent(n);
            args = scil.clone(p.item);
            scil.apply(args, n.item);
        }
        if (this.onAjaxData != null)
            args = this.onAjaxData(n);
        if (this.options.url != null && this.options.url != "")
            scil.Utils.ajax(this.options.url, fn, args, { popup: false, beforeload: beforeload, afterload: afterload });
    },

    select: function (node) {
        if (typeof node == "string")
            node = this.find(null, node);

        if (node == null)
            return null;

        if (node.item != null && node.item.selectable == false) {
            if (node.firstChild != null)
                this.onExpand(node.firstChild.firstChild);
            return;
        }

        if (node.item != null && node.item._more) {
            this.loadNodes(node);
            return;
        }

        if (this.cur != null)
            this.cur.firstChild.style.background = "";
        this.cur = node;
        if (this.dropdown && this.cur != null)
            this.cur.firstChild.style.background = "#f6f4b9";
        this.cur.firstChild.style.background = "#ddf";
        if (this.onSelectItem != null) {
            var isleaf = null;
            if (this.cur != null)
                isleaf = this.cur.firstChild.nextSibling == null;
            this.onSelectItem(this.cur, isleaf);
        }
    },

    getIconText: function (node) {
        if (node == null)
            return null;
        var img = node.firstChild.childNodes[2];
        if (img.tagName == "SPAN")
            return img.innerHTML;
        return "<img src='" + img.src + "'>" + img.nextSibling.innerHTML;
    },

    setCurrent: function (value, key) {
        var n = this.find(null, value, key);
        if (n != null)
            this.select(n);

        return n;
    },

    find: function (parent, value, key) {
        var container = parent == null ? this.container : parent.firstChild.nextSibling;
        if (container == null)
            return null;

        if (key == null)
            key = "id";

        var children = container.childNodes;
        for (var i = 0; i < children.length; ++i) {
            var n = children[i];
            if (n.item != null && n.item[key] == value)
                return n;

            var c = this.find(n, value, key);
            if (c != null)
                return c;
        }
        return null;
    },

    getChildren: function (parent) {
        var container = parent == null ? this.container : parent.firstChild.nextSibling;
        return container == null ? null : container.childNodes;
    },

    getParent: function (n) {
        return n.parentNode.parentNode;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* DropdownInput class
* @class scilligence.DropdownInput
* <pre>
* <b>Example:</b>
*    &lt;input id='d'/&gt;
*    &lt;script type="text/javascript"&gt;
*        scil.ready(function () {
*            new scil.DropdownInput('d', { items: ["Boston", "New York", "London"],
*                onclickitem: function (city) { alert(city); } 
*            });
*        });
*    &lt;/script&gt;
* </pre>
*/

document.write('<style type="text/css">input._scil_dropdown::-ms-clear {display: none;}</style>');

scil.DropdownInput = scil.extend(scilligence._base, {
    /**
    * @constructor DropdownInput
    * @param {string or DOM} input - the INPUT element to be converted
    * @param {dict} options - { items: [], overwrite: true/false, onclickitem: function(item) {}, onsuggest: function(args) {}, augto }
    */
    constructor: function (input, options) {
        this.auto = null;
        this.options = options == null ? {} : options;
        this.input = typeof (input) == "string" ? document.getElementById(input) : input;
        this.itemschanged = true;
        this.sugid = 0;
        this.suggestlength = this.options.suggestlength > 0 ? this.options.suggestlength : 1;

        if (this.options.autosuggest == "")
            this.options.autosuggest = null;

        var me = this;
        this.input.style.background = "#fff " + scil.Utils.imgSrc("img/dropdown.gif", true) + " no-repeat right center";
        this.input.style.border = "solid 1px #999";
        this.input.style.padding = "2px";
        this.input.className = "_scil_dropdown";
        this.updateReadonly();

        dojo.connect(this.input, "onkeyup", function (e) { me.keyup(e); });
        dojo.connect(this.input, "onclick", function (e) { me.clickMe(e); });
    },

    updateDropdown: function (readonly) {
        if (readonly != null) {
            this.options.readonly = readonly;
            this.updateReadonly();
        }
        this.input.style.backgroundImage = this.options.items == null ? "" : scil.Utils.imgSrc("img/dropdown.gif", true);
    },

    updateReadonly: function () {
        this.input.readOnly = this.options.readonly;
        this.input.style.backgroundColor = this.options.readonly ? "#eee" : "#fff";
    },

    keyup: function (e) {
        if (this.disabled || this.input == null || this.options.autosuggest == null && this.options.onFilter == null && this.options.items == null)
            return;

        if (this.options.readonly) {
            if (this.options.items != null)
                this.highlight(e);
            return;
        }

        if (this.input.value.length < this.suggestlength || e.keyCode == 9 || e.keyCode == 13) {
            if (this.auto != null)
                this.auto.style.display = "none";
            return;
        }

        var sugid = ++this.sugid;
        if (this.options.onFilter != null) {
            var ret = this.options.onFilter(this.input.value);
            this.list(ret, sugid);
            this.itemschanged = true;
        }
        else if (scil.Utils.startswith(this.options.autosuggest, "data:")) {
            // local data
            var ret = this.filterlist(this.options.autosuggest.substr(5).split(','), this.input.value);
            this.list(ret, sugid);
            this.itemschanged = true;
        }
        else if (scil.Utils.startswith(this.options.autosuggest, "javascript:")) {
            var s = this.options.autosuggest.substr(11);
            var fn = scil.Utils.eval(s);
            var items = fn(this);

            var ret = this.filterlist(items, this.input.value);
            this.list(ret, sugid);
            this.itemschanged = true;
        }
        else if (this.options.items != null && this.options.autosuggest == null) {
            // local data
            var ret = this.filterlist(this.options.items, this.input.value);
            this.list(ret, sugid);
            this.itemschanged = true;
        }
        else if (this.options.autosuggest != null) {
            // url to ajax call
            var me = this;
            var args = { q: this.input.value };
            if (this.options.onsuggest != null)
                this.options.onsuggest(args);
            scil.Utils.jsonp(this.options.autosuggest, function (ret) { me.list(ret.items == null ? ret : ret.items, sugid); me.itemschanged = true; }, args);
        }
    },

    filterlist: function (list, q) {
        var ret = [];
        if (q != null && q != "" && list != null) {
            q = q.toLowerCase();
            for (var i = 0; i < list.length; ++i) {
                if (list[i].toLowerCase().indexOf(q) >= 0)
                    ret.push(scil.Utils.trim(list[i]));
            }
        }
        return ret;
    },

    clickMe: function (e) {
        if (this.options.items == null)
            return;

        var input = e.srcElement || e.target;
        if (input.offsetWidth - (e.offsetX == null ? e.layerX : e.offsetX) < 16)
            this.show();
    },

    setItems: function (list) {
        if (list == null)
            return;
        this.options.items = list;
        this.itemschanged = true;
    },

    isChildOf: function (src) {
        return src == this.input || JsUtils.isChildOf(src, this.auto)
    },

    isDropdownVisible: function () {
        return this.auto != null && this.auto.style.display == "";
    },

    isVisible: function () {
        return this.input != null && this.input.style.display == "";
    },

    show: function () {
        if (this.auto == null) {
            var me = this;
            var pos = scil.Utils.isFixedPosition(this.input) ? "fixed" : "absolute";
            this.auto = scil.Utils.createElement(document.body, "div", null, { display: "none", backgroundColor: "white", overflow: "hidden", border: "solid 1px gray", position: pos, zIndex: 99999 });
            dojo.connect(document.body, "onmousedown", function (e) { var src = e.srcElement || e.target; if (src != me.q && src.parentNode != me.auto) me.clickout(); });
        }

        if (this.itemschanged)
            this.list(this.options.items, ++this.sugid);
        this.auto.style.display = "";
        this.auto.style.zIndex = scil.Utils.getZindex(this.input) + 1;
        this.updateDropdownSize();
    },

    highlight: function (e) {
        if (this.auto == null || this.auto.style.display == "none") {
            if (e.keyCode == 13 || e.keyCode == 40) {
                this.show();
                e.preventDefault();
            }
            return;
        }

        e.preventDefault();
        if (e.keyCode == 27) {
            this.hide();
            return;
        }

        var children = this.auto.childNodes;
        var sel = null;
        for (var i = 0; i < children.length; ++i) {
            var item = children[i];
            if (item.getAttribute("sel") == "1") {
                sel = i;
                break;
            }
        }

        if (e.keyCode == 13) {
            if (sel != null)
                this.clickItem(children[sel]);
            return;
        }

        var newsel = null;
        if (e.keyCode == 38 || e.keyCode == 40) {
            if (sel == null) {
                newsel = 0;
            }
            else if (e.keyCode == 38) {
                newsel = sel - 1;
                if (newsel < 0)
                    newsel = children.length - 1;
            }
            else {
                newsel = sel + 1;
                if (newsel >= children.length)
                    newsel = 0;
            }

            e.preventDefault();
        }
        else {
            if (e.char != null) {
                var c = e.char.toLowerCase();
                newsel = this.findNextMatch(c, sel == null ? 0 : sel + 1, children.length);
                if (newsel == null && sel != null)
                    newsel = this.findNextMatch(c, 0, sel);
            }
        }

        if (newsel != null && newsel != sel) {
            if (sel != null)
                this._hilitItem(children[sel], false);
            this._hilitItem(children[newsel], true);
        }
    },

    findNextMatch: function (c, start, end) {
        for (var i = start; i < end; ++i) {
            var item = this.auto.childNodes[i];
            if (item.innerHTML) {
                var s = this.getItemValue(item);
                if (s.length > 0 && s.substr(0, 1).toLowerCase() == c)
                    return i;
            }
        }
        return null;
    },

    updateDropdownSize: function () {
        if (!this.isDropdownVisible())
            return;

        var p = scil.Utils.getOffset(this.input);
        var scroll = scilligence.Utils.scrollOffset();
        if (scil.Utils.isIE) {
            var s2 = JsUtils.getScrollOffset(this.e);
            scroll.offset(-s2.x, -s2.y);
        }
        var w = this.input.offsetWidth;
        if (this.options.minautowidth > 0 && this.options.minautowidth > w)
            w = this.options.minautowidth;
        if (w < 100)
            w = 100;
        dojo.style(this.auto, { left: (p.x + scroll.x) + "px", top: (p.y + scroll.y + this.input.offsetHeight) + "px", width: (w - 2) + "px" });
    },

    hide: function () {
        if (this.auto != null && this.auto.style.display != "none")
            this.auto.style.display = "none";
    },

    isParentHidden: function (q) {
        var obj = q;
        while (obj != null && obj.style != null) {
            if (obj.style.display == "none" || obj.style.visibility == "hidden")
                return true;
            obj = obj.parentNode;
        }
        return false;
    },

    list: function (items, sugid) {
        if (items == null || items.length == 0 || sugid != this.sugid || this.isParentHidden(this.input)) {
            if (this.auto != null) {
                scilligence.Utils.removeAll(this.auto);
                this.auto.style.display = "none";
            }
            return;
        }
        if (this.auto == null || this.auto.style.display == "none") {
            this.itemschanged = false;
            this.show();
        }

        this.itemschanged = false;
        scilligence.Utils.removeAll(this.auto);
        if (items == null || items.length == 0)
            return;

        var me = this;
        for (var i = 0; i < items.length; ++i) {
            var s = items[i];
            var div = scilligence.Utils.createElement(this.auto, 'div', scil.Utils.isNullOrEmpty(s) ? "&nbsp;" : s, { padding: "2px", textAlign: this.options.align });
            dojo.connect(div, "onclick", function (e) { me.click(e); });
            dojo.connect(div, "onmouseover", function (e) { me.mouseover(e); });
            dojo.connect(div, "onmouseout", function (e) { me.mouseout(e); });
        }
    },

    mouseover: function (e) {
        this._hilitItem(e.srcElement || e.target, true);
    },

    mouseout: function (e) {
        this._hilitItem(e.srcElement || e.target, false);
    },

    _hilitItem: function (item, f) {
        if (f) {
            item.style.backgroundColor = "#ddf";
            item.setAttribute("sel", "1");
        }
        else {
            item.style.backgroundColor = "white";
            item.removeAttribute("sel");
        }
    },

    clickout: function (e) {
        this.hide();
    },

    click: function (e) {
        var src = e.srcElement || e.target;
        this.clickItem(src);
    },

    getItemValue: function (src) {
        var s = scil.Utils.htmlDecode(src.innerHTML);
        if (s == "&nbsp;")
            s = "";
        return s;
    },

    clickItem: function (src) {
        var s = this.getItemValue(src);
        if (this.options.onSetValue != null)
            this.options.onSetValue(this.input, s);
        else if (this.options.overwrite == "unit")
            this.input.value = this.changeUnit(this.input.value, s);
        else if (this.options.overwrite == false)
            this.input.value += s;
        else
            this.input.value = s;
        this.hide();
        if (this.options.overwrite)
            this.input.select();
        this.input.focus();

        if (this.options.onclickitem != null)
            this.options.onclickitem(s);

        scil.Utils.fireEvent(this.input, "change", false, true);
    },

    changeUnit: function (s, unit) {
        var r = JSDraw2.Table.parseValueUnit(s);
        if (r == null || r.value == null)
            return "";
        return r.value + (unit == null ? "" : unit);
    }
});

﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Popup class
* @class scilligence.Popup
* <pre>
* <b>Example:</b>
* &lt;span id='k'&gt;Test&lt;/span&gt; More words
* &lt;span id='Span1'&gt;Test2&lt;/span&gt;
* &lt;script type="text/javascript"&gt;
*     scil.onload(function () {
*         new scil.Popup('k', { html: "Hello, World!", caption: "Hellow" });
*         new scil.Popup('Span1', { html: "&lt;img src='face.gif'&gt;", caption: "Picture" });
*     });
* &lt;/script&gt;
* </pre>
*/
scil.Popup = scil.extend(scil._base, {
    /**
    * @constructor Popup
    * @param {string or DOM} element - the INPUT element to be converted
    * @param {dictionary} options - { caption, html, ongethtml: function() {} }
    */
    constructor: function (a, options) {
        if (typeof (a) == "string")
            this.a = scil.byId(a);
        else
            this.a = a;

        if (options == null)
            this.options = {};
        else
            this.options = options;

        if (this.a != null) {
            var me = this;
            dojo.connect(this.a, "onmouseout", function () { scil.Popup.hide(); });
            dojo.connect(this.a, "onmouseover", function (e) {
                scil.Popup.show(me, e);
            });
        }

        scil.Popup.init();
    },

    getHtml: function (e) {
        if (this.options.ongethtml2 != null)
            return this.options.ongethtml2(this, e);

        if (this.options.html == null) {
            if (this.options.ongethtml != null)
                this.options.html = this.options.ongethtml(this);
        }
        return this.options.html;
    },

    getCaption: function (e) {
        if (this.options.ongetcaption2 != null)
            return this.options.ongetcaption2(this, e);

        return this.options.caption;
    }
});

scil.apply(scil.Popup, {
    current: null,
    inited: null,

    show: function (popup, e2) {
        this.hide();
        this.current = popup;
        e = new scil.Popup.Event(e2);

        var caption = this.current.getCaption(e2);
        var html = this.current.getHtml(e2);

        if (scil.Utils.isNullOrEmpty(html)) {
            this.hide();
            return;
        }

        this.create();
        this.area.innerHTML = "";
        this.title.innerHTML = "";
        this.div.style.display = "";

        this.title.innerHTML = caption == null ? "" : caption;
        this.area.innerHTML = html;

        if (e != null)
            this.move(e);
    },

    hide: function () {
        this.current = null;
        if (this.div != null) {
            this.title.innerHTML = "";
            this.area.innerHTML = "";
            this.div.style.display = 'none';
        }
    },

    move: function (e) {
        if (this.current == null)
            return;

        if (this.div == null || this.div.style.display == "none")
            return;

        var obj = e.srcElement == null ? e.target : e.srcElement;
        if (this.current.a == obj || this.isChildOf(obj, this.current.a)) {
            this.moveto(e);
            return;
        }

        if (this.isChildOf(obj, this.div))
            return;

        this.hide();
    },

    moveto: function (e) {
        this.create();
        var scrollLeft = this.scrollLeft();
        var scrollTop = this.scrollTop();

        var winWidth = 0;
        var winHeight = 0;

        if (document.all == null) {
            winWidth = window.innerWidth;
            winHeight = window.innerHeight;
        }
        else {
            winWidth = document.documentElement.clientWidth;
            winHeight = document.documentElement.clientHeight;
        }

        var w = this.div.offsetWidth;
        var h = this.div.offsetHeight;

        var x = e.clientX + scrollLeft + 10;
        var y = e.clientY + scrollTop + 20;
        if (x - scrollLeft + w > winWidth && x - scrollLeft - w > 0)
            x -= w + 15;
        if (y - scrollTop + h > winHeight && y - scrollTop - h > 0)
            y -= h + 25;

        this.div.style.left = x + "px";
        this.div.style.top = y + "px";
    },

    isChildOf: function (obj, parent) {
        while (obj != null) {
            if (obj == parent)
                return true;
            obj = obj.parentNode;
        }

        return false;
    },

    scrollLeft: function (e) {
        return this.filterResults(
		    window.pageXOffset ? window.pageXOffset : 0,
		    document.documentElement ? document.documentElement.scrollLeft : 0,
		    document.body ? document.body.scrollLeft : 0
	    );
    },

    scrollTop: function (e) {
        return this.filterResults(
		    window.pageYOffset ? window.pageYOffset : 0,
		    document.documentElement ? document.documentElement.scrollTop : 0,
		    document.body ? document.body.scrollTop : 0
	    );
    },

    filterResults: function (n_win, n_docel, n_body) {
        var n_result = n_win ? n_win : 0;
        if (n_docel && (!n_result || (n_result > n_docel)))
            n_result = n_docel;
        return n_body && (!n_result || (n_result > n_body)) ? n_body : n_result;
    },

    init: function () {
        if (this.inited == true)
            return;
        this.inited = true;

        dojo.connect(document, "onmousemove", function (e) { scil.Popup.move(e); });
    },

    create: function () {
        if (this.div != null)
            return;

        this.div = document.createElement("div");
        this.div.style.display = "none";
        this.div.style.whiteSpace = "nowrap";
        this.div.style.backgroundColor = "white";
        this.div.style.borderStyle = "solid";
        this.div.style.borderColor = "#f0f0f0 #a0a0a0 #a0a0a0 #f0f0f0";
        this.div.style.borderWidth = "2px";
        this.div.style.position = "absolute";
        this.div.style.zIndex = scil.Utils.getMaxZindex();
        this.div.style.textAlign = "left";
        document.body.appendChild(this.div);

        var div = document.createElement("div");
        div.style.border = "1px solid highlight";
        div.style.padding = "1px";
        this.div.appendChild(div);

        this.title = document.createElement("div");
        this.title.style.textAlign = "center";
        this.title.style.border = JSDraw2.Skin.dialog.border;
        this.title.style.backgroundColor = JSDraw2.Skin.dialog.bkcolor;
        this.title.style.color = "white";
        div.appendChild(this.title);

        this.area = document.createElement("div");
        this.area.style.padding = "2px";
        this.area.style.backgroundColor = "white";
        div.appendChild(this.area);
    }
});


scil.Popup.Event = scil.extend(scil._base, {
    constructor: function (e) {
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.srcElement = e.target || e.srcElement;
    }
});
﻿////////////////////////////////////////////////////////////////////////////////////
////
//// JSDraw.Lite
//// Copyright (C) 2018 Scilligence Corporation
//// http://www.scilligence.com/
////
//// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
////
////////////////////////////////////////////////////////////////////////////////////

//scil.UploadFile = {
//    dlg: null,
//    form: null,
//    msg: null,
//    files: [],
//    filetypes: [],
//    kIframe: "__scil_uploadfile_iframe",

//    show: function (options) {
//        this.create();
//        this.dlg.show();
//        this.form.reset();
//        this.options = options == null ? {} : options;

//        if (options.msg != null)
//            this.msg.innerHTML = options.msg;

//        for (var i = 0; i < this.files.length; ++i)
//            this.files[i].value = "";
//        for (var i = 0; i < this.filetypes.length; ++i) {
//            scil.Utils.removeAll(this.filetypes[i]);
//            this.filetypes[i].style.display = this.options.filetypes != null ? "" : "none";
//            if (this.options.filetypes != null)
//                scil.Utils.listOptions(this.filetypes[i], this.options.filetypes);
//        }
//    },

//    upload: function () {
//        var me = this;
//        var params = this.options.params;
//        scil.Utils.ajaxUploadFile(this.form, this.options.url, params == null ? {} : params, function (ret) { me.dlg.hide(); me.options.callback(ret); });
//    },

//    create: function (parent) {
//        if (this.dlg != null)
//            return;

//        var me = this;
//        // form method='post' id='__newfile' enctype=''
//        var div = JsUtils.createElement(null, "div", "<form method='post' enctype='multipart/form-data'></form>", { padding: "15px" });
//        this.form = div.firstChild;
//        this.msg = scil.Utils.createElement(this.form, "div", "Please specify files to be uploaded");
//        var tbody = scil.Utils.createTable(this.form);
//        for (var i = 0; i < 5; ++i) {
//            var tr = scil.Utils.createElement(tbody, "tr");
//            var td = scil.Utils.createElement(tr, "td");
//            var file = scil.Utils.createElement(td, "file", null, null, { name: "f" + i });

//            td = scil.Utils.createElement(tr, "td");
//            var type = scil.Utils.createElement(td, "select", null, null, { name: "filetype.f" + i });

//            this.files.push(file);
//            this.filetypes.push(type);
//        }

//        var tr = scil.Utils.createElement(tbody, "tr");
//        var td = scil.Utils.createElement(tr, "td", null, { paddingTop: "10px", textAlign: "center" }, { colSpan: 2 });
//        scil.Utils.createButton(td, { src: scil.App.imgSmall("submit.png"), label: "Upload", onclick: function () { me.upload(); } });

//        this.dlg = new scil.Dialog("Upload File", div);
//    }
//};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Tabs class - Tabs Control
* @class scilligence.Tabs
* <pre>
* <b>Example:</b>
        &lt;div id="div1"&gt;&lt;/div&gt;
        &lt;script type="text/javascript"&gt;
            scil.ready(function () {
                var options = {
                    tabs: {
                        a: { caption: "Tab A" },
                        b: { caption: "Tab B", closable: true }
                    },
                    onRemoveTab: function (td, tabs) { alert("remove tab"); },
                    onBeforeShowTab: function (td, old, tabs) { },
                    onShowTab: function (td, old, tabs) { },
                    onCreateTab: function(td, clientarea, tabs) { },
                    border: true
                };

                var tabs = new scil.Tabs("div1", options);
            });
        &lt;/script&gt;
* </pre>
*/
scil.Tabs = scil.extend(scil._base, {
    constructor: function (parent, options) {
        var me = this;
        this.options = options == null ? {} : options;
        this.currenttab = null;
        this.area = null;

        if (typeof (parent) == "string")
            parent = dojo.byId(parent);

        var tabarea;
        var tbody = scil.Utils.createTable(parent, 0, 0, { width: "100%", marginBottom: this.options.marginBottom == null ? "20px" : this.options.marginBottom });
        this.dom = this.table = tbody.parentNode;
        this.vertical = true;
        var tabborder = this.options.border ? null : scil.Tabs.kBorderStyle;
        var areapadding = this.options.border ? "5px" : 0;
        var areaborder = this.options.border ? scil.Tabs.kBorderStyle : null;
        var taggap = this.options.tabgap == null ? "4px" : this.options.tabgap;
        switch (this.options.tablocation) {
            case "left":
                var tr = scil.Utils.createElement(tbody, "tr");
                tabarea = scil.Utils.createElement(tr, "td", null, { borderRight: tabborder, width: "1%", verticalAlign: "top", borderRightWidth: taggap });
                this.area = scil.Utils.createElement(tr, "td", null, { padding: areapadding, border: areaborder, width: "99%", verticalAlign: "top" });
                this.vertical = false;
                break;
            case "right":
                var tr = scil.Utils.createElement(tbody, "tr");
                this.area = scil.Utils.createElement(tr, "td", null, { padding: areapadding, border: areaborder, width: "1%", verticalAlign: "top" });
                tabarea = scil.Utils.createElement(tr, "td", null, { borderLeft: tabborder, width: "99%", verticalAlign: "top", borderLeftWidth: taggap });
                this.vertical = false;
                break;
            case "bottom":
                this.area = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", null, { padding: areapadding, border: areaborder });
                tabarea = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", null, { borderTop: tabborder, borderTopWidth: taggap });
                break;
            default: // top
                tabarea = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", null, { borderBottom: tabborder, borderBottomWidth: taggap });
                this.area = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", null, { padding: areapadding, border: areaborder });
                break;
        }

        this.tabcontainer = scil.Utils.createTable(tabarea, 0, 0);
        if (this.vertical)
            this.tr = scil.Utils.createElement(this.tabcontainer, "tr");

        if (this.options.showtabs == false)
            this.tr.style.display = "none";

        var tabs = this.options.tabs;
        if (tabs != null) {
            if (tabs.length > 0) {
                for (var i = 0; i < tabs.length; ++i)
                    this.addTab(tabs[i]);
            }
            else {
                for (var k in tabs)
                    this.addTab(tabs[k], k);
            }
        }
    },

    getLastTab: function () {
        var list = this.vertical ? this.tr.childNodes : this.tabcontainer.childNodes;
        return list[list.length - 1];
    },

    resizeClientarea: function (width, height) {
        var list = this.vertical ? this.tr.childNodes : this.tabcontainer.childNodes;
        for (var i = 0; i < list.length; ++i) {
            var td;
            if (this.vertical)
                td = list[i];
            else
                td = list[i].childNodes[0];

            if (td.clientarea == null)
                continue;

            if (width > 0) {
                td.clientarea.style.width = width + "px";
                this.options.clientareawidth = width;
            }
            if (height > 0) {
                td.clientarea.style.height = height + "px";
                this.options.clientareaheight = height;
            }
        }

        if (this.options.onresizeclientarea != null)
            this.options.onresizeclientarea(width, height, this);
    },

    addTab: function (options, key) {
        if (key == null && options.key != null)
            key = options.key;

        if (this.vertical) {
            if (this.tr.childNodes.length > 0)
                scil.Utils.createElement(this.tr, "td", "&nbsp;");
        }
        else {
            if (this.tabcontainer.childNodes.length > 0)
                scil.Utils.createElement(scil.Utils.createElement(scil.Utils.createElement(this.tabcontainer, "tr"), "td"), "div", null, { height: 5 });
        }

        var me = this;
        var caption = options.caption;
        var icon = options.icon;
        var title = options.tooltip;
        var padding = this.options.tabpadding == null ? "5px 10px 1px 10px" : this.options.tabpadding;
        var tr = this.vertical ? this.tr : scil.Utils.createElement(this.tabcontainer, "tr");
        var style = { border: "solid 1px #ddd", padding: padding, backgroundColor: "#eee" };

        switch (this.options.tablocation) {
            case "left":
                style.borderRight = "none";
                style.borderTopLeftRadius = "5px";
                style.borderBottomLeftRadius = "5px";
                break;
            case "right":
                style.borderLeft = "none";
                style.borderTopRightRadius = "5px";
                style.borderBottomRightRadius = "5px";
                break;
            case "bottom":
                style.borderTop = "none";
                style.borderBottomLeftRadius = "5px";
                style.borderBottomRightRadius = "5px";
                break;
            default: // top
                style.borderBottom = "none";
                style.borderTopLeftRadius = "5px";
                style.borderTopRightRadius = "5px";
                break;
        }

        var td = scil.Utils.createElement(tr, "td", null, style, { key: key || options.tabkey, sciltab: "1" });
        var tbody2 = scil.Utils.createTable2(td, null, { cellSpacing: 0, cellPadding: 0 });
        var s = (icon != null ? "<img src='" + icon + "'>" : "") + (caption == null ? "Tab" : scil.Lang.res(caption));

        var td2 = null;
        switch (this.options.tablocation) {
            case "left":
            case "right":
                td._label = scil.Utils.createElement(scil.Utils.createElement(tbody2, "tr"), "td", s, null, { title: title }, function (e) { me.showTab(td); });
                td2 = scil.Utils.createElement(scil.Utils.createElement(tbody2, "tr"), "td");
                break;
            case "bottom":
            default: // top
                var tr2 = scil.Utils.createElement(tbody2, "tr");
                td._label = scil.Utils.createElement(tr2, "td", s, null, { title: title }, function (e) { me.showTab(td); });
                td2 = scil.Utils.createElement(tr2, "td");
                break;
        }

        if (options.closable) {
            var img = scil.Utils.createButton(td2, { src: scil.Utils.imgSrc("img/del2.gif"), title: "Close", style: {}, onclick: function (e) { me.closeTab(td); } });
            img.style.marginLeft = "10px";
            td.style.paddingRight = "2px";

            scil.connect(td2, "onmouseover", function () { img.style.background = "#fff"; });
            scil.connect(td2, "onmouseout", function () { img.style.background = ""; });
        }

        if (options.onmenu != null) {
            scil.connect(td, "onmouseup",
                function (e) {
                    if (scil.Utils.isRightButton(e))
                        options.onmenu(e);
                    e.preventDefault();
                });
            scil.Utils.disableContextMenu(td);
        }

        options.caption = null;
        options.visible = this.currenttab == null;
        options.marginBottom = 0;
        options.caption = caption;

        td.clientarea = scil.Utils.createElement(this.area, "div", null, { display: "none", width: this.options.clientareawidth, height: this.options.clientareaheight, overflowY: this.options.clientareaheight > 0 ? "scroll" : null });
        if (options.style != null)
            dojo.style(td.clientarea, options.style);

        if (this.currenttab == null)
            this.showTab(td);

        if (options.html != null)
            td.clientarea.innerHTML = options.html;

        if (this.options.onCreateTab != null)
            this.options.onCreateTab(td, td.clientarea, this);

        return td;
    },

    updateTabLabel: function (key, s) {
        var td = typeof (key) == "string" ? this.findTab(key) : key;
        if (td != null && td._label != null)
            td._label.innerHTML = s;
    },

    closeTab: function (td) {
        var me = this;
        if (this.options.onclosetab == null) {
            scil.Utils.confirmYes("Close this tab?", function () { me.removeTab(td); });
        }
        else {
            var r = this.options.onclosetab(td, this);
            if (r == "cancel")
                return;
            else
                this.removeTab(td);
        }
    },

    currentTabKey: function () {
        return this.currenttab == null ? null : this.currenttab.getAttribute("key");
    },

    findTab: function (key) {
        var list = this.vertical ? this.tr.childNodes : this.tabcontainer.childNodes;
        for (var i = 0; i < list.length; ++i) {
            var td;
            if (this.vertical)
                td = list[i];
            else
                td = list[i].childNodes[0];

            if (td.getAttribute("key") == key)
                return td;
        }
        return null;
    },

    removeTab: function (key) {
        var td = typeof (key) == "string" ? this.findTab(key) : key;
        if (td == null)
            return false;

        if (this.options.onRemoveTab != null) {
            if (this.options.onRemoveTab(td, this) == "cancel")
                return false;
        }

        if (td == this.currenttab) {
            var list = this.allTabsAsArray();
            var i = scil.Utils.indexOf(list, td);
            if (i > 0)
                this.showTab(list[i - 1]);
            else
                this.showTab(list[i + 1]);
        }

        td.clientarea.parentNode.removeChild(td.clientarea);
        delete td.clientarea;

        if (this.vertical) {
            var td0 = td.previousSibling;
            if (td0 != null && td0.clientarea == null)
                td0.parentNode.removeChild(td0);
            td.parentNode.removeChild(td);
        }
        else {
            var tr = td.parentNode;
            var tr0 = tr.previousSibling;
            if (tr0 != null)
                tr0.parentNode.removeChild(tr0);
            tr.parentNode.removeChild(tr);
        }

        return true;
    },

    allTabsAsArray: function () {
        var ret = [];
        var list = this.vertical ? this.tr.childNodes : this.tabcontainer.childNodes;
        for (var i = 0; i < list.length; ++i) {
            var td;
            if (this.vertical)
                td = list[i];
            else
                td = list[i].childNodes[0];

            if (td.getAttribute("sciltab") == "1")
                ret.push(td);
        }
        return ret;
    },

    allTabs: function () {
        var ret = {};
        var list = this.vertical ? this.tr.childNodes : this.tabcontainer.childNodes;
        for (var i = 0; i < list.length; ++i) {
            var td;
            if (this.vertical)
                td = list[i];
            else
                td = list[i].childNodes[0];

            if (td.getAttribute("sciltab") == "1") {
                var k = td.getAttribute("key");
                if (k != null && k != "")
                    ret[k] = td;
            }
        }
        return ret;
    },

    showTab: function (td) {
        if (typeof (td) == "string") {
            td = this.findTab(td);
        }
        else if (typeof (td) == "number") {
            var list = this.allTabsAsArray();
            td = list[td];
        }

        if (td != null && td.tagName != "TD")
            td = scil.Utils.getParent(td, "td");

        if (td == null)
            return;

        var old = this.currenttab;
        if (this.options.onBeforeShowTab != null) {
            if (this.options.onBeforeShowTab(td, old) == false)
                return;
        }

        if (this.currenttab != null) {
            this.currenttab.style.backgroundColor = "#eee";
            this.currenttab.style.color = "";
        }

        if (old != null && old.clientarea != null)
            old.clientarea.style.display = "none";

        td.style.backgroundColor = scil.Tabs.kHighlightColor;
        td.style.color = "#fff";
        this.currenttab = td;
        if (td.clientarea != null)
            td.clientarea.style.display = "";

        if (this.options.onShowTab != null)
            this.options.onShowTab(td, old, this);
    },

    show: function () {
        this.table.style.display = "";
    },

    hide: function () {
        this.table.style.display = "none";
    }
});


scil.apply(scil.Tabs, {
    kHighlightColor: "#88f",
    kBorderStyle: "solid 1px #88f"
});﻿﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* TabbedForm class - TabbedForm Control
* @class scilligence.TabbedForm
* <pre>
* <b>Example:</b>
*    dojo.ready(function () {
*        var parent = scil.Utils.createElement(document.body, "div");
*            var options = { tabs: {
*                a: { caption: "Tab A", fields: { field1: { label: "Field1"}} },
*                b: { caption: "Tab B", fields: { field2: { label: "Field2" }, field3: { label: "Field3"}} }
*            }, buttons: { label: "Test", onclick: function() { alert(999); } }, border: true
*            };
*        var form = new scil.TabbedForm(options).render(parent);
*    });
* </pre>
*/
scil.TabbedForm = scil.extend(scil._base, {
    constructor: function (options) {
        this.form = null;
        this.options = options;
        this.buttons = [];
        this.fields = {};
    },

    render: function(parent) {
        if (typeof(parent) == "string")
            parent = dojo.byId(parent);

        var me = this;
        this.options.onShowTab = function(td, old) {
            if (!td.rendered && old != null)
                me.renderTabForm(td);
        };

        this.options.onBeforeShowTab = function(td, old) {
            if (me.options.onbeforeshowtab != null && td != old)
                return me.options.onbeforeshowtab(td, old);
        };

        var first = true;
        for (var k in this.options.tabs)
            this.options.tabs[k].tabkey = k;

        this.tabs = new scil.Tabs(parent, this.options);
        for (var k in this.options.tabs) {
            this.options.tabs[k].tabkey = k;
            var td = this.tabs.findTab(k);
            td.form = new scil.Form(this.options);

            if (!this.options.delayrender || first) {
                this.renderTabForm(td);
                first = false;
            }
        }

        var buttons = this.options.buttons;
        if (buttons != null) {
            var div = scil.Utils.createElement(parent, "div", null, { marginTop: "10px", textAlign: "center"});
            if (buttons.length > 0) {
                for (var i = 0; i < buttons.length; ++i)
                    this.buttons.push(scil.Utils.createButton(div, buttons[i]));
            }
            else {
                this.buttons.push(scil.Utils.createButton(div, buttons));
            }
        }

        return this;
    },

    /**
    * Set a field value
    * @function setFieldValue
    * @param {string} id - the id of the field
    * @param {string} v - value to be set
    */
    setFieldValue: function (id, v, data) {
        var field = this.fields[id];
        scil.Form.setFieldData(this.fields[id], this.items[id], this.viewonly, v, data);
    },

    focus: function (key) {
        scil.Form.focus(this.fields, key);
    },

    /**
    * Check required fields
    * @function checkRequiredFields
    */
    checkRequiredFields: function () {
        var n = 0;
        var tabs = this.tabs.allTabs();
        for (var k in tabs) {
            var form = tabs[k].form;
            if (form != null)
                n += form.checkRequiredFields();
        }
        return n;
    },

    /**
    * Reset required fields
    * @function resetRequiredFields
    */
    resetRequiredFields: function () {
        var tabs = this.tabs.allTabs();
        for (var k in tabs) {
            var form = tabs[k].form;
            if (form != null)
                form.resetRequiredFields();
        }
    },

    renderTabForm: function(td) {
        if (td.rendered)
            return;

        var k = td.getAttribute("key");
        var fields = null;
        if (this.options.tabs!= null && this.options.tabs[k] != null)
            fields = this.options.tabs[k].fields;

        var display = td.clientarea.style.display;
        td.clientarea.style.display = "";
        td.form.render(td.clientarea, fields, this.options.tabs[k]);
        td.clientarea.style.display = display;

        scil.apply(this.fields, td.form.fields);
        td.rendered = true;
    },

    getCurTabData: function (includeNullValues) {
        if (this.tabs.currenttab == null || this.tabs.currenttab.form == null)
            return null;
        return this.tabs.currenttab.form.getData(includeNullValues);
    },

    /**
    * Collect form data in xml format
    * @function getXml
    * @returns xml string
    */
    getXml: function (nowrapper) {
        var ret = nowrapper ? "" : "<data>\n";
        var tabs = this.tabs.allTabs();
        for (var k in tabs) {
            var form = tabs[k].form;
            if (form != null)
                ret += form.getXml(true);
        }
        if (!nowrapper)
            ret += "</data>";
        return ret;
    },

    /**
    * Set form data
    * @function setXml
    * @param {xml} data the form data, *id* is the key
    */
    setXml: function (xml) {
        try {
            var data = scil.Form.xml2Json(xml);
            this.setData(data);
        }
        catch (e) {
            alert("Error raised when setting form data: " + e.message);
        }
    },

    getData: function (includeNullValues) {
        if (this.options.getdata == "tab")
            return this.getCurTabData(includeNullValues);

        var ret = {};
        var tabs = this.tabs.allTabs();
        for (var k in tabs) {
            var form = tabs[k].form;
            if (form != null) {
                var data = form.getData(includeNullValues);
                scil.apply(ret, data);
            }
        }

        return ret;
    },

    setData: function (data, overwritemode) {
        if (this.options.setdata == "tab") {
            if (this.tabs.currenttab != null && this.tabs.currenttab.form != null)
                this.tabs.currenttab.form.setData(data, overwritemode);
        }
        else {
            var tabs = this.tabs.allTabs();
            for (var k in tabs) {
                var form = tabs[k].form;
                if (form != null)
                    form.setData(data, overwritemode);
            }
        }
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* FieldNumber class - FieldNumber Control
* @class scilligence.FieldNumber
*/
scil.FieldNumber = scil.extend(scil._base, {
    /**
    * Constructor
    * @function constroctor
    * @param {DOM} parent
    * @param {dict} options - { width, min, max, allowoperator, scale, units }
    */
    constructor: function (input, options) {
        if (typeof (input) == "string")
            input = scil.byId(input);
        this.options = options == null ? {} : options;
        this.input = input;
        this.unit = null;
        //this.input.style.textAlign = "right";

        var me = this;
        var viewonly = this.options.viewonly || this.input.disabled || this.input.readOnly;
        if (this.options.allowoperator && !viewonly) {
            this.auto = new scil.DropdownInput(input,
                { items: this.options.items == null ? ["", "≥", "≤", "&lt;", "&gt;", "±"] : this.options.items,
                    onSetValue: function (input, s) { me.onSetOperator(input, s); }
                });
        }

        var tr;
        if (this.options.units != null && !viewonly) {
            var tbody = scil.Utils.createTable(null, 0, 0, { border: "solid 1px #ccc" });
            this.input.parentNode.insertBefore(tbody.parentNode, this.input);

            tr = scil.Utils.createElement(tbody, "tr");
            scil.Utils.createElement(tr, "td").appendChild(this.input);
            this.unit = scil.Utils.createElement(scil.Utils.createElement(tr, "td", null, { borderLeft: "solid 1px #ccc" }), "select", null, { width: this.options.unitwidth });
            scil.Utils.listOptions(this.unit, this.options.units, null, true, false);

            scil.connect(this.unit, "onchange", function () { scil.Utils.fireEvent(me.input, "change") });

            this.input.style.border = "none";
            this.unit.style.border = "none";
        }

        var me = this;
        if (!viewonly) {
            scil.connect(input, "onchange", function (e) {
                var s = input.value;
                if (s != "" && s != null && (me.options.accepts == null || !new RegExp(me.options.accepts).test(s)) && !scil.Utils.isNumber(s, me.options.allowoperator)) {
                    input.value = "";
                    scil.Utils.alert("A number is required!");
                }
                else {
                    if (me.unit != null)
                        s += me.unit.value;
                    me.setValue(s);
                }
            });
        }

        if (!viewonly && this.options.mobiledata != null) {
            var me = this;
            new scil.MobileData(input, { weighstation: true, url: scil.MobileData.getDefaultUrl(true), onresult: function (ret) {
                me.setValue(ret.barcode);
                scil.MobileData.markRecieved(input);
                return true;
            } 
            });
            scil.Utils.createButton(scil.Utils.createElement(tr, "td"), { label: "&#9878;", title: "Select Weigh Station", type: "a", onclick: function () { scil.MobileData.selectWeighstation(); } });
        }
    },

    onSetOperator: function (input, op) {
        if (op == "")
            return;

        var s = scil.Utils.trim(input.value);
        if (op == "±") {
            if (s.indexOf("±") >= 0)
                return;
            input.value = s + " ±";
        }
        else {
            var c = s.length > 0 ? s.substr(0, 1) : null;
            if (c == "≥" || c == "≤" || c == ">" || c == "<")
                s = s.substr(1);
            input.value = op + s;
        }
    },

    clear: function () {
        this.setDisplayValue("");
    },

    setValue: function (v) {
        v = v == null ? null : (JSDraw2.Table == null ? { value: v} : JSDraw2.Table.splitUnit(v + ""));
        if (v == null) {
            this.setDisplayValue("");
            return;
        }

        if (this.options.scale > 0 && !isNaN(v.value))
            v.value *= this.options.scale;

        if (this.options.decimal > 0)
            v.value = scil.Utils.round(v.value, this.options.decimal);

        if (v.unit2 == null)
            v.unit2 = this.options.defaultunit;

        // I#13265
        var value = (v.op == null ? "" : v.op) + v.value;
        this.setDisplayValue(value);
        if (this.unit != null) {
            scil.Utils.selectOption(this.unit, v.unit2, true);
        }
        else {
            if (JSDraw2.ColorCoding != null)
                JSDraw2.ColorCoding.show(this.input, v.value, this.options);
        }
    },

    setDisplayValue: function (v) {
        if (v == null)
            v = "";

        if (this.input.tagName == "INPUT")
            this.input.value = v;
        else
            this.input.innerHTML = v;
    },

    getDisplayValue: function () {
        if (this.input.tagName == "INPUT")
            return this.input.value;
        else
            return scil.Utils.getInnerText(this.input);
    },

    getValue: function () {
        var v = scil.Utils.trim(this.getDisplayValue());
        if (!scil.Utils.isNullOrEmpty(v) && !isNaN(v)) {
            if (this.options.scale > 0)
                v /= this.options.scale;

            if (this.unit != null)
                v = v + this.unit.value;
        }

        return v;
    }
});
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Chart class - Chart Control
* @class scilligence.Chart
* Supported chart types: pie, line, stackedline, area, stackedarea, column, clusteredcolumn, bar, clusteredbar, bubble
* <pre>
* <b>Example 1:</b>
*    &lt;script type="text/javascript"&gt;
*        scil.ready(function () {
*            new scil.Chart('div1', { type: "bar", width: 800, height: 300,
*                ajax: { url: "service.aspx?cmd=datasource&source=bug" }
*            });
*        });
*    &lt;/script&gt;
*
* <b>Example 2:</b>
*    &lt;script type="text/javascript"&gt;
*        scil.ready(function () {
*            new scil.Chart('div1', { type: "bar", width: 800, height: 300,
*                series: [
*                    { label: "Series 1", data: { A: 10000, B: 9200, C: 11811, D: 12000, E: 7662, F: 13887} },
*                    { label: "Series 2", data: { A: 3000, B: 12000, D: 12783} }
*                ]
*            });
*        });
*    &lt;/script&gt;
*
* <b>Example 3:</b>
*    &lt;script type="text/javascript"&gt;
*        scil.ready(function () {
*            new scil.Chart('div1', { type: "bar", width: 800, height: 300,
*                xlabels: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
*                series: [
*                    { label: "Series 1", data: [10000, 9200, 11811, 12000, 7662, 13887] }
*                ]
*            });
*        });
*    &lt;/script&gt;
*
* <b>Example 4:</b>
*    &lt;script type="text/javascript"&gt;
*        new scil.Chart('container', { type: "bubble", width: 800, height: 300, xmin: 0, ymin: 0, xmax: 8, ymax: 20, ytitle: "Bubble",
*            series: [
*                    { label: "Series 1", data: [
*                    { x: 1, y: 12.45, size: 1, color: 'red' },
*                     { x: 2, y: 15.45, size: 2, color: "green" },
*                     { x: 3, y: 2, size: 1.5 },
*                     { x: 4, y: 7, size: 3.5 },
*                     { x: 5, y: 12, size: 1.5 },
*                     { x: 6, y: 7, size: 4.5 }
*                     ]
*                    }
*                ]
*        });
*    });
*    &lt;/script&gt;
* </pre>
*/

if (typeof (__JSDraw2_TouchMol) == "undefined") {
    dojo.require("dojox.charting.Chart");
    dojo.require("dojox.charting.plot2d.Areas");
    dojo.require("dojox.charting.plot2d.StackedAreas");
    dojo.require("dojox.charting.plot2d.Bars");
    dojo.require("dojox.charting.plot2d.ClusteredBars");
    dojo.require("dojox.charting.plot2d.Columns");
    dojo.require("dojox.charting.plot2d.ClusteredColumns");
    dojo.require("dojox.charting.plot2d.StackedColumns");
    dojo.require("dojox.charting.plot2d.Lines");
    dojo.require("dojox.charting.plot2d.StackedLines");
    dojo.require("dojox.charting.plot2d.Markers");
    dojo.require("dojox.charting.plot2d.MarkersOnly");
    dojo.require("dojox.charting.plot2d.Pie");
    dojo.require("dojox.charting.plot2d.Scatter");
    dojo.require("dojox.charting.plot2d.Grid");
    dojo.require("dojox.charting.plot2d.Spider");
    dojo.require("dojox.charting.plot2d.Bubble");

    dojo.require("dojox.charting.axis2d.Default");
    dojo.require("dojox.charting.action2d.Highlight");
    dojo.require("dojox.charting.action2d.Tooltip");
    dojo.require("dojox.charting.action2d.MoveSlice");
    dojo.require("dojox.charting.action2d.Magnify");
    dojo.require("dojox.charting.widget.Legend");
    dojo.require("dojox.charting.themes.Claro");
}

// http://demos.dojotoolkit.org/dojox/charting/tests/test_pie_smart_label.html
scil.Chart = scil.extend(scil._base, {
    /**
    * @constructor Chart
    * @param {string or DOM} element - the parent Element
    * @param {dict} options - { type { string }, width, height, title {string}, legend {bool}, labelstyle: { string: hidden, columns, null }, 
    *      theme {string}, animate {bool}, shadow {bool}, xtitle {string}, ytitle {string}, linewith: {int},
    *      series: [{label, data}] } 
    */
    constructor: function (parent, options) {
        scil.Chart.addStylesheet();

        if (typeof (parent) == "string")
            parent = scil.byId(parent);
        this.parent = parent;
        this.loadData(options);
    },

    loadData: function (options) {
        this.options = options == null ? {} : options;
        if (this.options.series != null)
            this.render();
        else
            this.loadDataFromUrl(this.options.ajax == null ? null : this.options.ajax.url, this.options.ajax.data);
    },

    loadDataFromUrl: function (url, args) {
        if (scil.Utils.isNullOrEmpty(url))
            return false;

        this.options.series = null;

        var me = this;
        scil.Utils.jsonp(url, function (ret) {
            if (ret == null || ret.length == null || ret.length == 0)
                return;

            if (typeof (ret[0]) != "object") {
                me.options.series = [{ data: ret}];
            }
            else {
                var keys = [];
                for (var k in ret[0])
                    keys.push(k);

                var x = keys[0];
                var data = [];
                for (var i = 0; i < ret.length; ++i)
                    data.push(ret[i][x]);

                me.options.series = [];
                if (keys.length == 1) {
                    me.options.series.push({ label: x, data: data });
                }
                else {
                    me.options.xlabels = data;

                    for (var k = 1; k < keys.length; ++k) {
                        var data = [];
                        var y = keys[k];
                        for (var i = 0; i < ret.length; ++i)
                            data.push(ret[i][y]);
                        me.options.series.push({ label: y, data: data });
                    }
                }
            }

            me.render();
        }, args);
    },

    downloadImage: function () {
        if (JSDrawServices.url == null || JSDrawServices.url == "") {
            scil.Utils.alert("JSDraw web service is not available");
            return;
        }

        var html = "<div style='width:" + this.parent.offsetWidth + "px'>" + this.parent.innerHTML + "</div>";
        scil.Utils.post(JSDrawServices.url + "?cmd=html2image", { html: html, css: scil.Chart.getCss(), width: this.parent.offsetWidth });
    },

    render: function () {
        scil.Utils.removeAll(this.parent);

        var type = null;
        switch (this.options.type) {
            case "column":
                type = dojox.charting.plot2d.Columns;
                break;
            case "clusteredcolumn":
                type = dojox.charting.plot2d.ClusteredColumns;
                break;
            case "stackedcolumn":
                type = dojox.charting.plot2d.StackedColumns;
                break;
            case "bar":
                type = dojox.charting.plot2d.Bars;
                break;
            case "clusteredbar":
                type = dojox.charting.plot2d.ClusteredBars;
                break;
            case "line":
                type = dojox.charting.plot2d.Lines;
                break;
            case "stackedline":
                type = dojox.charting.plot2d.StackedLines;
                break;
            case "area":
                type = dojox.charting.plot2d.Areas;
                break;
            case "stackedarea":
                type = dojox.charting.plot2d.StackedAreas;
                break;
            case "scatter":
                type = dojox.charting.plot2d.Scatter;
                break;
            case "grid":
                type = dojox.charting.plot2d.Grid;
                break;
            case "spider":
                type = dojox.charting.plot2d.Spider;
                break;
            case "bubble":
                type = dojox.charting.plot2d.Bubble;
                break;
            case "pie":
                type = dojox.charting.plot2d.Pie;
                if (!(this.options.radius > 0))
                    this.options.radius = 100;
                break;
        }

        if (!scil.Utils.isNullOrEmpty(this.options.title)) {
            scil.Utils.createElement(this.parent, "h3", scil.Lang.res(this.options.title), { margin: 0, textAlign: "center", fontSize: this.options.titlesize > 0 ? this.options.titlesize + "px" : null });
        }

        var div = scil.Utils.createElement(this.parent, "div");

        if (this.options.width > 0)
            this.parent.style.width = this.options.width + "px";
        if (this.options.height > 0)
            div.style.height = this.options.height + "px";

        var chart = new dojox.charting.Chart(div);

        if (this.options.theme != null)
            chart.setTheme(dojox.charting.themes[this.options.theme]);
        else
            chart.setTheme(dojox.charting.themes.Claro);

        if (this.options.fontcolor == null)
            this.options.fontcolor = "blue";

        var args = {
            type: type,
            markers: true,
            gap: this.options.gap > 0 ? this.options.gap : 5,
            radius: this.options.radius > 0 ? this.options.radius : null,
            htmlLabels: true,
            fontColor: this.options.fontcolor,
            labelWiring: this.options.fontcolor,
            animate: this.options.animate
        };
        if (this.options.linewidth > 0)
            args.stroke = { width: this.options.linewidth };
        if (this.options.labelstyle != null)
            args.labelStyle = this.options.labelstyle;
        if (this.options.shadow != false)
            args.shadow = { dx: 2, dy: 2, width: 2, color: [0, 0, 0, 0.3] };
        chart.addPlot("default", args);
        if (this.options.plots != null) {
            for (var k in this.options.plots)
                chart.addPlot(k, this.options.plots[k]);
        }

        var xargs = {};
        var yargs = { vertical: true, fixLower: "major", fixUpper: "major" };

        if (this.options.xmin != null)
            xargs.min = this.options.xmin;
        if (this.options.xmax != null)
            xargs.max = this.options.xmax;
        if (this.options.xtitle != null) {
            xargs.title = this.options.xtitle;
            xargs.titleOrientation = "away";
            xargs.titleGap = 1;
        }

        if (this.options.ymin != null)
            yargs.min = this.options.ymin;
        if (this.options.ymax != null)
            yargs.max = this.options.ymax;
        if (this.options.ytitle != null) {
            yargs.title = scil.Lang.res(this.options.ytitle);
            yargs.titleGap = 5;
        }

        var series = this.options.series;
        var xlabels = this.options.xlabels;
        if (series[0].data != null && series[0].data.length == null) {
            xlabels = [];
            var values = [];
            var data = series[0].data;
            for (var k in data) {
                xlabels.push(k);
                values.push(data[k]);
            }

            var series2 = [];
            for (var i = 0; i < series.length; ++i) {
                if (i > 0) {
                    values = [];
                    data = series[i].data;
                    for (var k = 0; k < xlabels.length; ++k) {
                        var v = data[xlabels[k]];
                        values.push(v == null ? 0 : v);
                    }
                }
                series2.push({ label: scil.Lang.res(series[i].label), data: values, args: series[i].args, additup: series[i].additup });
            }
            series = series2;
        }

        if (this.options.type == "pie") {
            chart.addSeries(series[0].label, series[0].xydata != null ? series[0].xydata : this.array2data(series[0].data, null, xlabels, this.options.showpercentage));
        }
        else {
            if (xlabels != null)
                xargs.labels = this.array2data(xlabels, true);

            chart.addAxis("x", xargs);
            chart.addAxis("y", yargs);

            if (this.options.type == "bubble") {
                chart.addSeries(series[0].label, series[0].xydata || series[0].data);
            }
            else {
                for (var i = 0; i < series.length; ++i)
                    chart.addSeries(series[i].label == null ? "Series-" + (i + 1) : series[i].label, series[i].xydata != null ? series[i].xydata : this.array2data(series[i].data, null, xlabels, null, series[i].additup), series[i].args);
            }
        }

        //new dojox.charting.widget.Legend(chart, "default");
        if (this.options.tooltips != false)
            new dojox.charting.action2d.Tooltip(chart, "default");
        switch (this.options.type) {
            case "pie":
            case "scatter":
            case "grid":
                new dojox.charting.action2d.MoveSlice(chart, "default");
                break;
            case "bar":
            case "clusteredbar":
                new dojox.charting.action2d.Highlight(chart, "default");
                break;
            case "column":
            case "clusteredcolumn":
                new dojox.charting.action2d.Highlight(chart, "default");
                break;
            case "line":
            case "stackedline":
                new dojox.charting.action2d.Magnify(chart, "default");
                break;
            case "area":
            case "stackedarea":
                new dojox.charting.action2d.Magnify(chart, "default");
                break;
        }

        chart.render();

        if (this.options.legend) {
            var legend = scil.Utils.createElement(this.parent, "div");
            new dojox.charting.widget.Legend({ chart: chart }, legend);
        }

        var me = this;
        chart.connectToPlot("default", function (evt) {
            if (evt.type == "onclick") {
                if (me.options.onclick != null)
                    me.options.onclick(evt);
            }
            else if (evt.type == "onmouseover") {
                if (me.options.onmouseover != null)
                    me.options.onmouseover(evt);
            }
            else if (evt.type == "onmouseout") {
                if (me.options.onmouseout != null)
                    me.options.onmouseout(evt);
            }
        });
    },

    array2data: function (list, asAxis, xlabels, showpercentage, additup) {
        var sum = 0;
        if (showpercentage) {
            for (var i = 0; i < list.length; ++i) {
                if (!isNaN(list[i]))
                    sum += list[i];
            }
        }

        var v = null;
        var ret = [];
        for (var i = 0; i < list.length; ++i) {
            if (asAxis) {
                ret.push({ value: i + 1, text: list[i] });
            }
            else {
                var v2 = null;
                if (additup) {
                    if (v == null)
                        v = list[i];
                    else if (list[i] != null && !isNaN(list[i]))
                        v += list[i];
                    v2 = list[i] == null ? null : v;
                }
                else {
                    v2 = list[i];
                }

                var s = v2;
                var t = s;
                if (xlabels != null && xlabels[i] != null) {
                    if (showpercentage && !isNaN(s) && sum > 0)
                        s = (Math.round(s / sum * 1000) / 10) + "%";
                    s = xlabels[i] + " (" + s + ")";
                    t = xlabels[i];
                }

                ret.push({ x: i + 1, y: v2, text: t, tooltip: s });
            }
        }

        return ret;
    }
});


scil.apply(scil.Chart, {
    stylesheetAdded: false,

    addStylesheet: function () {
        if (this.stylesheetAdded)
            return;

        this.stylesheetAdded = true;
        scil.Utils.addCss(this.getCss());
    },

    getCss: function () {
        var code = ".dijitTooltip { position: absolute; z-index: 2000; display: block; left: 0; overflow: visible; }\r\n";
        code += ".dijitTooltipContainer { border: solid #aaf 1px; background: #fff; color: blue; padding: 2px; border-radius: 3px; }\r\n";
        code += ".dijitTooltipConnector { position: absolute; }\r\n";
        code += ".dojoxLegendIcon { float: left; }\r\n";

        return code;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

scil.Clipboard = {
    copy: function (text) {
        if (scil.Utils.isNullOrEmpty(text))
            return false;

        var e = scil.Utils.createElement(document.body, "textarea", null, { position: 'fixed', top: 0, left: 0, width: '2px', height: '2px', padding: 0, border: 'none', outline: 'none', boxShadow: 'none', background: 'transparent' });
        e.value = text;
        e.select();

        var ret = false;
        try {
            ret = document.execCommand('copy');
        } catch (err) {
        }

        document.body.removeChild(e);
        return ret;
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

if (typeof (__JSDraw2_TouchMol) == "undefined") {
    dojo.require("dijit.layout.AccordionContainer");
    dojo.require("dijit.layout.ContentPane");
}

scil.Accordion = scil.extend(scil._base, {
    constructor: function (parent, options) {
        scil.Accordion.addStylesheet();

        if (typeof (parent) == "string")
            parent = scil.byId(parent);
        this.options = options == null ? {} : options;

        var style = "";
        if (this.options.width > 0)
            style += "width:" + this.options.width + "px;";
        if (this.options.height > 0)
            style += "height:" + this.options.height + "px;";

        this.container = new dijit.layout.AccordionContainer({ style: style }, parent);
        for (var i = 0; i < this.options.items.length; ++i) {
            var item = this.options.items[i];
            this.container.addChild(new dijit.layout.ContentPane({
                title: item.title,
                content: item.html
            }));
        }
        this.container.startup();

        if (this.options.onafterrender != null)
            this.options.onafterrender(this);
    }
});

scil.apply(scil.Accordion, {
    stylesheetAdded: false,

    addStylesheet: function () {
        if (this.stylesheetAdded)
            return;

        this.stylesheetAdded = true;
        scil.Utils.addCss(this.getCss());
    },

    getCss: function () {
        var code = ".dijitAccordionInnerContainer{background-color: #efefef;border: solid 1px #b5bcc7;}\r\n" +
            ".dijitAccordionContainer .dijitAccordionChildWrapper{background-color: #ffffff;border: 1px solid #759dc0;margin: 0 2px 2px;}\r\n" +
            ".dijitAccordionTitle .arrowTextUp, .dijitAccordionTitle .arrowTextDown {display: none;font-size: 0.65em;font-weight: normal !important;}\r\n" +
            ".dijitAccordionTitle{padding: 5px 7px 2px 7px;min-height: 17px;}\r\n";

        return code;
    }
});
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

scil.DnD = scil.extend(scil._base, {
    constructor: function (parent, options) {
        this.src = null;
        this.copy = null;
        this.dragging = false;
        this.disabled = false;

        this.options = options;
        if (typeof (parent) == "string")
            parent = scil.byId(parent);

        var me = this;
        dojo.connect(parent, "onmousedown", function (e) { if (!me.disabled) me.mousedown(e); });

        dojo.connect(document.body, "onmousemove", function (e) { if (!me.disabled) me.mousemove(e); });
        dojo.connect(document.body, "onmouseup", function (e) { if (!me.disabled) me.mouseup(e); });
    },

    isDragging: function () {
        return this.dragging;
    },

    cancel: function () {
        if (this.src != null) {
            if (this.options.oncancel != null)
                this.options.oncancel(this);
        }

        this.src = null;
        this.copy = null;
        this.dragging = false;
    },

    mousedown: function (e, src) {
        if (this.options.onstartdrag != null) {
            this.src = this.options.onstartdrag(e, this);
            this.startpos = { x: e.clientX, y: e.clientY };
        }
    },

    mousemove: function (e) {
        if (this.src == null)
            return;

        if (this.copy == null && (Math.abs(e.clientX - this.startpos.x) > 10 || Math.abs(e.clientY - this.startpos.y) > 10)) {
            if (this.options.oncreatecopy != null)
                this.copy = this.options.oncreatecopy(e, this);
        }

        if (this.copy != null) {
            var scroll = scil.Utils.scrollOffset();
            this.copy.style.left = (e.clientX + scroll.x + 2) + "px";
            this.copy.style.top = (e.clientY + scroll.y + 2) + "px";

            this.dragging = true;
        }

        if (this.options.ondragover != null)
            this.options.ondragover(e, this);
    },

    mouseup: function (e) {
        if (this.src != null) {
            if (this.options.ondrop != null)
                this.options.ondrop(e, this);
        }

        this.src = null;
        this.copy = null;
        this.dragging = false;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

scil.Resizable = scil.extend(scil._base, {
    constructor: function (handle, options) {
        if (typeof (handle) == "string")
            handle = scil.byId(handle);
        this.options = options == null ? {} : options;
        this.resizing = null;
        this.handle = handle;
        this.bgcolor = this.handle.style.backgroundColor;

        if (this.options.direction == "y")
            handle.style.cursor = "ns-resize";
        else if (this.options.direction == "x")
            handle.style.cursor = "ew-resize";

        var me = this;
        dojo.connect(handle, "onmousedown", function (e) { me.start(e); });
        scil.connect(document.body, "onmousemove", function (e) { if (me.resize(e)) e.preventDefault(); });
        scil.connect(document.body, "onmouseup", function (e) { me.resizing = null; });

        if (this.options.mouseovercolor != null) {
            scil.connect(handle, "onmouseover", function () { me.handle.style.backgroundColor = me.options.mouseovercolor; });
            scil.connect(handle, "onmouseout", function () { me.handle.style.backgroundColor = me.bgcolor; });
        }
    },

    resize: function (e) {
        if (this.resizing == null)
            return false;

        var delta = this.options.direction == "y" ? (e.clientY - this.resizing.y) : (e.clientX - this.resizing.x);
        if (delta == 0)
            return true;

        var f = false;
        if (this.options.onresize != null)
            f = this.options.onresize(delta, this);

        if (f) {
            if (this.options.direction == "y")
                this.resizing.y = e.clientY;
            else
                this.resizing.x = e.clientX;
        }

        return true;
    },

    start: function (e) {
        if (this.options.direction == "y")
            this.resizing = { y: e.clientY };
        else if (this.options.direction == "x")
            this.resizing = { x: e.clientX };
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

scil.Favorite = scil.extend(scil._base, {
    constructor: function (key, onAddFavorite) {
        this.key = key;
        this.items = null;
        this.onAddFavorite = onAddFavorite;
        this.changed = false;
    },

    getList: function(type) {
        this._load();
        return this.items[type];
    },

    contains: function (name, type) {
        this._load();

        var list = this.items[type];
        return list == null ? false : scil.Utils.indexOf(list, name) >= 0;
    },

    add: function (name, f, type) {
        this._load();

        var list = this.items[type];
        if (list == null) {
            if (f) {
                this.items[type] = [name];
                this.changed = true;
            }
        }
        else {
            var p = scil.Utils.indexOf(list, name);
            if (p < 0 && f) {
                list.push(name);
                this.changed = true;
            }
            else if (p >= 0 && !f) {
                list.splice(p, 1);
                this.changed = true;
            }
        }

        if (this.onAddFavorite != null)
            this.onAddFavorite(name, f, type);

        if (this.changed)
            this._save();
    },

    _save: function () {
        if (this.items == null)
            return;

        var s = scil.Utils.json2str(this.items);
        scil.Utils.createCookie("scil_helm_favorites_" + this.key, s);
    },

    _load: function () {
        if (this.items != null)
            return;

        var s = scil.Utils.readCookie("scil_helm_favorites_" + this.key);
        var v = scil.Utils.eval(s);
        this.items = v == null ? {} : v;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* DropdownButton class
* @class scilligence.DropdownButton
* <pre>
* <b>Example:</b>
*    &lt;button id='d'&gt;Select City&lt;/button&gt;
*    &lt;script type="text/javascript"&gt;
*        scil.ready(function () {
*            new scil.DropdownButton('d', { items: ["Boston", "New York", "London"], 
*                callback: function (city) { alert(city); } });
*        });
*    &lt;/script&gt;
* </pre>
*/
scilligence.DropdownButton = scilligence.extend(scilligence._base, {
    /**
    * @constructor DropdownButton
    * @param {string or DOM} button - the BUTTON element to be converted
    * @param {dict} options - { items: [], callback: function(item) {} }
    */
    constructor: function (button, options) {
        this.auto = null;
        this.options = options == null ? {} : options;

        var me = this;
        this.button = typeof (button) == "string" ? document.getElementById(button) : button;
        dojo.connect(this.button, "onclick", function () { me.show(); });

        var s = this.options.dropdown == null ? "&#9660;" : this.options.dropdown;
        if (this.button.tagName == 'TABLE') {
            var list = this.button.getElementsByTagName("TD");
            var td = list[list.length - 1];
            scil.Utils.createElement(td, "span", s);
        }
        else {
            if (this.options.expandright)
                scil.Utils.createElement(this.button, "span", s, { fontSize: "70%" });
            else
                scil.Utils.createElement(this.button, "span", s, { fontSize: "70%" });
        }
    },

    isVisible: function () {
        return this.auto != null && this.auto.style.display != "none";
    },

    show: function () {
        if (this.isVisible())
            return;

        if (this.options.onshowdropdown != null) {
            if (this.options.onshowdropdown(this) == "cancel")
                return;
        }

        this.show2();
    },

    show2: function () {
        if (this.auto == null) {
            var me = this;
            var w = this.options.width;
            if (!(w > 0) && scil.Utils.isIE && scil.Utils.isIE <= 8)
                w = 200;

            var pos = scil.Utils.isFixedPosition(this.button) ? "fixed" : "absolute";
            var tbody = scil.Utils.createTable(document.body, 0, 1, { borderRadius: "1px", border: JSDraw2.Skin.dialog.border, backgroundColor: JSDraw2.Skin.dialog.bkcolor, display: "none", position: pos, width: w, boxShadow: JSDraw2.Skin.menu.boxshadow });
            this.auto = tbody.parentNode;
            scil.Animation.makeExpandable(this.auto, null, "0px");

            var div = JsUtils.createElement(JsUtils.createElement(tbody, "tr"), "td", null, { padding: "5px" });
            this.area = scil.Utils.createElement(div, "div", null, { backgroundColor: "#fff" });
            //this.auto = scil.Utils.createElement(document.body, "div", null, { display: "none", backgroundColor: this.options.backgroundColor == null ? "white" : this.options.backgroundColor, border: "solid 1px gray", position: "absolute", width: w });

            dojo.connect(document.body, "onmousedown", function (e) { var src = e.srcElement || e.target; if (src != me.q && !scil.Utils.isChildOf(src, me.auto)) me.clickout(); });
            this.list(this.options.items);
        }
        //this.auto.style.display = "";
        this.position();

        //this.auto.style.display = "none";
        scil.Animation.expandY(this.auto, this.itemcount * 30);
    },

    hide: function () {
        if (this.isVisible())
            scil.Animation.expandY(this.auto, 0);
    },

    resetItems: function (items) {
        this.options.items = items;
        this.auto = null;
    },

    position: function () {
        var p = scilligence.Utils.getOffset(this.button);
        var scroll = p.fixedposition ? new JSDraw2.Point(0, 0) : scilligence.Utils.scrollOffset();
        this.auto.style.position = p.fixedposition ? "fixed" : "absolute";
        var zIndex = scil.Utils.getZindex(this.button) + 1;
        if (scil.Utils.isIE) {
            var s2 = JsUtils.getScrollOffset(this.e);
            scroll.offset(-s2.x, -s2.y);
        }

        var x, y;
        if (this.options.expandright) {
            x = p.x + scroll.x + this.button.offsetWidth;
            y = p.y + scroll.y;
        }
        else {
            x = p.x + scroll.x;
            y = p.y + scroll.y + this.button.offsetHeight;
        }
        dojo.style(this.auto, { zIndex: zIndex, display: "", x: 0, y: 0 });
        scil.Utils.moveToScreen(x, y, this.auto);
    },

    list: function (items) {
        if (items == null || items.length == 0)
            return;

        if (this.auto.style.display != "")
            this.position();

        if (items.length == null) {
            var list = [];
            for (var k in items)
                list.push({ label: items[k], key: k });
            items = list;
        }

        this.itemcount = 0;
        scil.Utils.removeAll(this.area);
        var me = this;
        for (var i = 0; i < items.length; ++i) {
            var item = items[i];
            if (item == "-" && (i == 0 || items[i - 1] == "-" || i == items.length - 1))
                continue;

            ++this.itemcount;
            this.createItem(item);
        }
    },

    createItem: function (item) {
        if (item == "-") {
            scil.Utils.createElement(this.area, 'hr', null, { margin: 0, padding: 0, borderColor: scil.App.config == null ? null : scil.App.config.frame });
            return;
        }

        if (typeof (item) == "string")
            item = { label: item };

        var label = this.options.translate ? scil.Lang.res(item.label) : item.label;
        if (item.key == null && label != item.label)
            item.key = item.label;

        var div = scil.Utils.createElement(this.area, 'div', null, { padding: "3px 10px 3px 10px", backgroundColor: item.bgcolor, paddingLeft: item.paddingleft == null ? null : item.paddingleft, color: JSDraw2.Skin.menu.color, cursor: "pointer" }, { url: item.url, key: item.key, bgcolor: item.bgcolor, title: item.tooltip || item.title });

        var div2 = div;
        if (item.items != null && item.items.length > 0) {
            var tbody = scil.Utils.createTable(div, 0, 0, { width: "100%" });
            var tr = scil.Utils.createElement(tbody, "tr");
            div2 = scil.Utils.createElement(tr, "td", null, { textAlign: "left" });
            scil.Utils.createElement(tr, "td", "&#9658;", { paddingLeft: "10px", textAlign: "right", fontSize: "50%" });
        }

        if (item.icon != null)
            scil.Utils.createElement(div2, "img", null, { marginRight: "5px" }, { src: item.icon });
        if (label != null)
            scil.Utils.createElement(div2, "span", label);

        var me = this;
        if (item.items != null && item.items.length > 0) {
            item.expandright = true;
            item.dropdown = "";
            new scil.DropdownButton(div, item);
        }
        else {
            if (item.key == null && item.label != null)
                item.key = item.label;
            dojo.connect(div, "onclick", function (e) { if (item.onclick != null) item.onclick(); me.click(e, div); });
        }

        dojo.connect(div, "onmouseover", function (e) { me.mouseover(e, div); });
        dojo.connect(div, "onmouseout", function (e) { me.mouseout(e, div); });
    },

    getItem: function (e) {
        var src = e.srcElement || e.target;
        if (src.tagName != "DIV")
            src = scil.Utils.getParent(src, "DIV");
        return src;
    },

    mouseover: function (e) {
        var div = this.getItem(e);
        div.style.backgroundColor = "#ddf";
        div.style.color = JSDraw2.Skin.menu.highlightcolor;
    },

    mouseout: function (e) {
        var div = this.getItem(e);
        var bgcolor = div.getAttribute("bgcolor");
        div.style.backgroundColor = scil.Utils.isNullOrEmpty(bgcolor) ? "#fff" : bgcolor;
        div.style.color = JSDraw2.Skin.menu.color;
    },

    clickout: function (e) {
        this.hide();
    },

    click: function (e) {
        var src = this.getItem(e);
        var url = src.getAttribute("url");
        var key = src.getAttribute("key");
        if (this.options.callback != null)
            this.options.callback(key == null || key == "" ? src.innerText || src.textContent : key, url);
        else if (this.options.onclick != null)
            this.options.onclick(key == null || key == "" ? src.innerText || src.textContent : key, url);
        else if (url != null) {
            if (this.options.target == null)
                window.location = url;
            else
                window.open(url, this.options.target);
        }
        this.hide();
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Animation class - Animation
* @class scilligence.Animation
* <pre>
* <b>Example:</b>
* &lt;div id='div1'&gt;
* &lt;script type="text/javascript"&gt;
*     scil.ready(function () {
*     });
* &lt;/script&gt;
* </pre>
*/
scil.Animation = {
    enabled: !scil.Utils.isIE && typeof (anime) != "undefined",

    expandX: function (target, width, onfinish) {
        this.expandXY(target, width, null, onfinish);
    },

    expandY: function (target, height, onfinish) {
        this.expandXY(target, null, height, onfinish);
    },

    makeExpandable: function (target, maxwidth, maxheight) {
        target.style.overflow = "hidden";
        if (maxwidth != null)
            target.style.maxWidth = maxwidth;
        if (maxheight != null)
            target.style.maxHeight = maxheight;
        target.style.display = "block";
    },

    expandXY: function (target, width, height, onfinish) {
        var f1 = width != null && scil.Utils.isNullOrEmpty(target.style.maxWidth);
        var f2 = height != null && scil.Utils.isNullOrEmpty(target.style.maxHeight);
        if (f1 || f2) {
            if (f1)
                target.style.maxWidth = (target.offsetWidth == null ? 0 : target.offsetWidth) + "px";
            if (f2)
                target.style.maxHeight = (target.offsetHeight == null ? 0 : target.offsetHeight) + "px";

            var me = this;
            setTimeout(function () { me._expandxy(target, width, height, onfinish); });
        }
        else {
            this._expandxy(target, width, height, onfinish);
        }
    },

    _expandxy: function (target, width, height, onfinish) {
        var duration = 500;

        var transition = "";
        if (width != null)
            transition += (transition == "" ? "" : ",") + "max-width " + (duration / 1000) + "s";
        if (height != null)
            transition += (transition == "" ? "" : ",") + "max-height " + (duration / 1000) + "s";

        target.style.WebkitTransition = transition;
        target.style.transition = transition;
        this.makeExpandable(target, width == null ? null : width + "px", height == null ? null : height + "px");

        setTimeout(function () {
            if (width === 0 || height === 0) {
                target.style.display = "none";
            }
            else {
                if (width != null) {
                    if (target.offsetWidth >= width) {
                        target.style.maxWidth = (width + 1000) + "px";
                        target.style.display = "visible";
                    }
                    target.style.maxWidth = target.offsetWidth + "px";
                }
                if (height != null) {
                    if (target.offsetHeight >= height) {
                        target.style.maxHeight = (height + 1000) + "px";
                        target.style.display = "visible";
                    }
                    target.style.maxHeight = target.offsetHeight + "px";
                }
            }
            if (onfinish != null)
                onfinish();
        }, duration);
    },

    flyin: function (flyer) {
        var d = this.beginfly(flyer);
        this.run(flyer.div, {
            translateX: [{ value: d.dx, duration: 1000 }],
            translateY: [{ value: d.dy, duration: 1000 }],
            scale: [{ value: 0.3, duration: 1500 }],
            opacity: [{ value: 0.3, duration: 1500 }],
            easing: 'easeInOutQuart'
        }, null, function () { flyer.div.style.display = "none"; });
    },

    flyback: function (flyer) {
        var d = this.beginfly(flyer);
        this.run(flyer.div, {
            translateX: [{ value: d.dx, duration: 500 }],
            translateY: [{ value: d.dy, duration: 500 }],
            scale: [{ value: 0.3, duration: 500 }],
            easing: 'easeInOutQuart',
            direction: 'alternate'
        }, null, function () { flyer.div.style.display = "none"; });
    },

    beginfly: function (flyer) {
        var p = scil.Utils.getOffset(flyer.src).offset(flyer.src.offsetWidth / 2, flyer.src.offsetHeight / 2);
        var p2 = scil.Utils.getOffset(flyer.dest);
        switch (flyer.destalign.align) {
            case "left":
                p2.offset(0, flyer.dest.offsetHeight / 2);
                break;
            case "right":
                p2.offset(flyer.dest.offsetWidth, flyer.dest.offsetHeight / 2);
                break;
            case "top":
                p2.offset(flyer.dest.offsetWidth / 2, 0);
                break;
            case "bottom":
                p2.offset(flyer.dest.offsetWidth / 2, flyer.dest.offsetHeight);
                break;
            default:
                p2.offset(flyer.dest.offsetWidth / 2, flyer.dest.offsetHeight / 2);
                break;
        }
        p2.offset(flyer.destalign.dx == null ? 0 : flyer.destalign.dx, flyer.destalign.dy == null ? 0 : flyer.destalign.dy);

        if (!flyer.useimg)
            scil.apply(flyer.div.style, { width: flyer.src.offsetWidth + "px", height: flyer.src.offsetHeight + "px" });
        scil.apply(flyer.div.style, { display: "", transform: "", left: (p.x - flyer.imgwidth / 2) + "px", top: (p.y - flyer.imgheight / 2) + "px" });
        return { dx: p2.x - p.x, dy: p2.y - p.y };
    },

    destoryflyer: function (flyer) {
        if (flyer.div != null) {
            flyer.div.parentNode.removeChild(flyer.div);
            flyer.div = null;
        }
    },

    makeflyer: function (src, dest, img, imgwidth, imgheight, destalign) {
        if (typeof (src) == "string")
            src = scil.byId(src);
        if (typeof (dest) == "string")
            dest = scil.byId(dest);

        var div = null;
        if (typeof (img) == "string")
            div = scil.Utils.createElement(document.body, "img", null, { position: "absolute", zIndex: 1000000, display: "none" }, { src: img });
        else
            div = img;

        var useimg = div != null;
        if (!useimg) {
            var opacity = 75;
            div = scil.Utils.createElement(document.body, "div", null, { position: "absolute", border: "solid 1px blue", background: "yellow", opacity: opacity / 100.0, filter: "alpha(opacity=" + opacity + ")", zIndex: 1000000, display: "none" });
        }

        if (imgwidth == null)
            imgwidth = 50;
        if (imgheight == null)
            imgheight = 50;

        return { div: div, useimg: useimg, src: src, dest: dest, imgwidth: imgwidth, imgheight: imgheight, destalign: destalign == null ? {} : destalign };
    },

    shake: function (target, onfinish) {
        if (!this.enabled) {
            if (onfinish != null)
                onfinish();
            return;
        }

        anime.timeline().add({
            targets: target,
            translateX: 30,
            duration: 50,
            easing: 'easeInOutQuart'
        }).add({
            targets: target,
            translateX: -30,
            duration: 50,
            easing: 'easeInOutQuart'
        }).add({
            targets: target,
            translateX: 30,
            duration: 50,
            easing: 'easeInOutQuart'
        }).add({
            targets: target,
            translateX: 0,
            duration: 50,
            easing: 'easeInOutQuart',
            complete: function () { if (onfinish != null) onfinish(); }
        });
    },

    translateX: function (target, dx, duration, onfinish) {
        if (dx == null)
            dx = 500;
        if (duration == null)
            duration = 1000;

        var me = this;
        var old = { mode: target.style.position, left: target.style.left, top: target.style.top, transform: "" };
        var position = old.mode;
        if (scil.Utils.isNullOrEmpty(position))
            position = "relative";
        this.run(target, { translateX: [{ value: dx, duration: duration }] }, { mode: position, dx: dx }, function () { me._setposition(target, old); if (onfinish != null) onfinish(); });
    },

    translateY: function (target, dy, duration, onfinish) {
        if (dy == null)
            dy = 500;
        if (duration == null)
            duration = 1000;

        var me = this;
        var old = { mode: target.style.position, left: target.style.left, top: target.style.top, transform: "" };
        var position = old.mode;
        if (scil.Utils.isNullOrEmpty(position))
            position = "relative";
        this.run(target, { translateY: [{ value: dy, duration: duration }] }, { mode: position, dy: dy }, function () { me._setposition(target, old); if (onfinish != null) onfinish(); });
    },

    zoomin: function (target, duration, onfinish) {
        if (duration == null)
            duration = 1000;

        var me = this;
        var old = { mode: "scale", transform: "" };
        this.run(target, { scale: [{ value: 1, duration: duration, easing: 'easeInOutQuart' }] }, { mode: "scale", scale: 0 }, function () { me._setposition(target, old); if (onfinish != null) onfinish(); });
    },

    zoomout: function (target, duration, onfinish) {
        if (duration == null)
            duration = 500;

        var me = this;
        var old = { mode: "scale", transform: "" };
        this.run(target, { scale: [{ value: 0, duration: duration, easing: 'easeInOutQuart' }] }, { mode: "scale", scale: 1 }, function () { me._setposition(target, old); if (onfinish != null) onfinish(); });
    },

    run: function (target, args, pos, oncomplete) {
        if (!this.enabled) {
            if (oncomplete != null)
                oncomplete();
            return;
        }

        var x = null;
        var y = null;
        if (pos != null) {
            if (pos.mode == "scale") {
                if (pos.scale != null)
                    this._setposition(target, { mode: pos.mode, transform: "scale(" + pos.scale + ")" });
            }
            else {
                if (pos.dx != null)
                    x = scil.Utils.parsePixel(target.style.left, 0);
                if (pos.dy != null)
                    y = scil.Utils.parsePixel(target.style.top, 0);
                this._setposition(target, { mode: pos.mode, left: x == null ? null : (x - pos.dx) + "px", top: y == null ? null : (y - pos.dy) + "px", transform: "" });
            }
        }

        var me = this;
        if (args.length > 0) {
            var timeline = anime.timeline();
            for (var i = 0; i < args.length; ++i) {
                args[i].targets = target;
                if (i == args.length - 1 && oncomplete != null)
                    args[i].complete = oncomplete;
                timeline.add(args[i]);
            }
        }
        else {
            args.targets = target;
            if (oncomplete)
                args.complete = oncomplete;
            anime(args);
        }
    },

    _setposition: function (e, pos) {
        if (pos.mode != "scale") {
            if (pos.mode == "relative")
                e.style.position = "relative";
            else if (pos.mode == "absolute")
                e.style.position = "absolute";
            else
                e.style.position = pos.mode == null ? "" : pos.mode;

            if (pos.left != null)
                e.style.left = pos.left;
            if (pos.top != null)
                e.style.top = pos.top;
        }

        if (pos.transform != null)
            e.style.transform = pos.transform;
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

scil.App = {
    imgSmall: function (name, wrapasurl) {
        var s = "small/" + name;
        if (wrapasurl)
            s = "url(" + s + ")";
        return s;
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw.Lite
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
// (Released under LGPL 3.0: https://opensource.org/licenses/LGPL-3.0)
//
//////////////////////////////////////////////////////////////////////////////////

/**
* FileUploader class - FileUploader Tool
* @class scilligence.FileUploader
* <pre>
* <b>Example:</b>
*        var fields = {
*            category: { label: "Category" },
*            sheetindex: { label: "Sheet #", type: "select", items: [1, 2, 3, 4, 5] },
*            headerlines: { label: "Header Lines", type: "select", items: [1, 2] }
*        };
*
*        scil.FileUploader.upload({ caption: "Upload Excel", fields: fields, url: "ajax.ashx?cmd=my.cmd", callback: function (ret) { ... }})
* </pre>
*/
scil.FileUploader = {
    upload: function (args) {
        if (args.dlg == null) {
            var fields = { file: { label: "File", type: "rawfile" } };
            scil.apply(fields, args.fields);

            var me = this;
            var caption = args.caption == null ? "Upload File" : args.caption;
            var buttonlabel = args.buttonlabel == null ? "Upload" : args.buttonlabel;
            args.dlg = scil.Form.createDlgForm(caption, fields, { label: buttonlabel, onclick: function (e) { e.preventDefault(); scil.FileUploader.upload2(args); } }, { usepostform: true });
        }

        args.dlg.show();
    },

    upload2: function (args) {
        var me = this;
        args.dlg.form.post(args.url, args.data, function (ret) { args.dlg.hide(); args.callback(ret, args); });
    }
};﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// Version 1.0.0.2013-11-06
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Page class - Page Framework
* JSDraw.Page framework helps to quickly build modern web applications
* @class scilligence.Page
* <pre>
* <b>Example:</b>
*    &lt;div id="placeholder"&gt;&lt;/div&gt;
*
*    &lt;script type="text/javascript"&gt;
*    scil.ready(function () { init(); });
*
*    function init() {
*        var tree = {
*            caption: "Analytical Category",
*            key: "category",
*            name: "category",
*            //object: "instrument",
*            root: { name: "Categories", icon: "img/ext/bmp.gif", children: [
*                { name: "Cambridge", icon: "img/ext/pdf.gif", isleaf: true },
*                { name: "Boston", icon: "img/ext/doc.gif", isleaf: true }
*            ]
*            }
*        };
*        this.page = new scil.Page(scil.byId("placeholder"), tree, { resizable: true, leftwidth: 300 });
*
*        var width = 300;
*        var instruments = this.page.addForm({
*            caption: "Analyticals",
*            key: "analyticalid",
*            name: "name",
*            object: "analytical",
*            columns: {
*                analyticalid: { type: "hidden", iskey: true },
*                name: { label: "Analytical Name", width: 200 },
*                category: { label: "Category", width: 200 },
*                version: { label: "Version", width: 100 }
*            },
*            formcaption: "Analytical",
*            fields: {
*                analyticalid: { type: "hidden", iskey: true },
*                name: { label: "Analytical Name", width: 800 },
*                category: { label: "Category", width: 800 },
*                version: { label: "Version", width: 100 },
*                requestform: { label: "Request Form", type: "textarea", height: 200, width: 800 },
*                resultform: { label: "Request Form", type: "textarea", height: 200, width: 800 }
*            }
*        }, this.page.tree);
*
*    }
*    &lt;/script&gt;
* </pre>
*/
scil.Page = scil.extend(scil._base, {
    constructor: function (parent, tree, forms, middle, onRefreshReceivers) {
        var args;
        if (forms != null && forms.length > 0 || middle != null || onRefreshReceivers != null) {
            args = { middle: middle, onRefreshReceivers: onRefreshReceivers, forms: forms };
        }
        else {
            args = forms == null ? {} : forms;
        }

        if (tree == null && args.left == null)
            args.left = false;

        if (tree != null)
            args.onresize = tree.onresizetree;

        this.onRefreshReceivers = args.onRefreshReceivers;
        this.url = scil.Page.ajaxurl == null ? "ajax.ashx?cmd=" : scil.Page.ajaxurl;
        this.explorer = new scil.Page.Explorer(parent, args);

        if (tree != null && tree.root != null && tree.root.children != null && tree.translate) {
            for (var i = 0; i < tree.root.children.length; ++i)
                tree.root.children[i].name = scil.Lang.res(tree.root.children[i].name);
        }

        this.tree = null;
        if (tree != null) {
            // var div = scil.Utils.createElement(this.explorer.left, "div", null, { width: tree.width > 0 ? tree.width : 240 });
            if (tree.type == "table" || tree.type == "block" || tree.type == "column")
                this.table = new scil.Page.Table(this, tree, this.explorer.left);
            else if (tree.type == "form")
                this.form = new scil.Page.Form(this, tree, this.explorer.left);
            else
                this.tree = new scil.Page.Tree(this, tree, this.explorer.left);
        }

        if (args.forms != null) {
            var last = this.tree == null ? this.form : this.tree;
            for (var i = 0; i < args.forms.length; ++i)
                last = this.addForm(args.forms[i], last);
        }
    },

    addTabs: function (options) {
        var tabs = new scil.Page.Tab(this, options, this.explorer.right);
        if (options != null && options.visible == false || options == false)
            tabs.hide();
        return tabs;
    },

    addDiv: function (text, style) {
        return scil.Utils.createElement(this.explorer.right, "div", text, style);
    },

    addForm: function (options, listento, parent, leftside) {
        return scil.Page.addForm(this, options, listento, parent, leftside);
    },

    addResizeHandle: function (onresize, height) {
        var div = this.addDiv();
        div.style.height = (height > 0 ? height : scil.Page.kHandleWidth) + "px";
        div.style.marginBottom = "2px";
        new scil.Resizable(div, { direction: "y", mouseovercolor: scil.Page.kHandleColor, onresize: onresize });
        return div;
    },

    removeForm: function (form) {
        var root = form.form.root;
        root.parentNode.removeChild(root);
    },

    receiverRefresh: function (form, args) {
        if (this.onRefreshReceivers != null)
            this.onRefreshReceivers(args, form);

        for (var i = 0; i < form.receivers.length; ++i)
            form.receivers[i].refresh(form, args);
    },

    receiverClear: function (form) {
        for (var i = 0; i < form.receivers.length; ++i)
            form.receivers[i].clear();
    }
});


scil.apply(scil.Page, {
    kHandleWidth: 5,
    kHandleColor: "#aaf",

    addForm: function (page, options, listento, parent, leftside) {
        if (parent == null)
            parent = leftside ? page.explorer.left : page.explorer.right;

        var form = null;
        if (options.type == "form")
            form = new scil.Page.Form(page, options, parent);
        else if (options.type == "custom")
            form = new scil.Page.Custom(page, options, parent);
        else if (options.type == "gantt")
            form = new scil.Page.Gantt(page, options, parent);
        else if (options.type == "calendar")
            form = new scil.Page.Calendar(page, options, parent);
        else // table or block
            form = new scil.Page.Table(page, options, parent);

        if (listento != null)
            listento.receivers.push(form);

        scil.Page.setBorder(form.form);
        options.form = form;
        return form;
    },

    setBorder: function (form) {
        form.toolbar.style.borderLeftColor = scil.Tabs.kHighlightColor;
        form.toolbar.style.borderRightColor = scil.Tabs.kHighlightColor;
        form.main.style.borderLeftColor = scil.Tabs.kHighlightColor;
        form.main.style.borderRightColor = scil.Tabs.kHighlightColor;
        form.main.style.borderBottomColor = scil.Tabs.kHighlightColor;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// Version 1.0.0.2013-11-06
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Page.Custom class - Page.Custom Control
* @class scilligence.Page.Custom
* <pre>
* <b>Constructor Parameters:</b>
*    - caption: {string}
*    - expandable: {bool}
*    - expanded: {bool}
*    - buttons: {array}
*    - marginBottom: {int}
*    - marginTop: {int}
*    - norefresh: {bool}
*    - visible: {bool}
*    - onexpandform: function(f)
*    - oncreate: function(parent, options)
*    - onrefresh: function(form, args, this)
*    - onclear: function()
*
* <b>Example:</b>
*        var tabs = this.page.addTabs();
*        scil.pmf.Company.allForms(this, tabs, this.parenttable, true);
*
*        var me = this;
*        this.dynamicform = tabs.addForm({
*            caption: "Dynamic Form",
*            type: "custom",
*            onclear: function () {
*                scil.Utils.removeAll(me.dynamicform.form.div);
*            },
*            onrefresh: function (from, args) {
*                scil.Utils.removeAll(me.dynamicform.form.div);
*                var fields = {
*                    mass: { label: "Mass", type: "number", width: 200, unit: "g" },
*                    name: { label: "Compound Name", type: "input", width: 200, button: { label: "Test", onclick: function () { alert(99); } } },
*                    vendor: { label: "Vendor", type: "select", options: ["Company A", "Company B"], width: 200 }
*                };
*                var form = new scil.Form({ viewonly: false });
*                form.render(me.dynamicform.form.div, fields, { immediately: true });
*            }
*        });
* </pre>
*/
scil.Page.Custom = scil.extend(scil._base, {
    constructor: function (page, options, parent) {
        var me = this;
        this.refreshneeded = true;
        this.page = page;
        this.options = options;
        this.receivers = [];

        var buttons = [];
        if (options.norefresh == false)
            buttons.push({ src: scil.App.imgSmall("refresh.png"), title: "Refresh", onclick: function () { me.refresh(); } });
        if (this.options.buttons != null)
            buttons = buttons.concat(this.options.buttons);

        this.form = new scil.Page.ExplorerForm(parent, scil.Page.ExplorerForm.cloneArgs(this.options, { buttons: buttons }));
        this.form.host = this;
        if (this.options.oncreate != null)
            this.options.oncreate(this.form.div, this.options);
    },

    show: function () {
        this.form.show();
    },

    hide: function () {
        this.form.hide();
    },

    refresh: function (from, args) {
        if (args != null)
            this.args = args;

        if (!this.form.isVisible()) {
            this.refreshneeded = true;
            return;
        }

        this.refreshneeded = false;
        if (this.options.onrefresh != null)
            this.options.onrefresh(from, this.args, this);
    },

    clear: function () {
        if (this.options.onclear != null)
            this.options.onclear();
    }
});
﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////


scil.Page.Explorer = scil.extend(scil._base, {
    constructor: function (parent, options) {
        if (typeof (parent) == "string")
            parent = scil.byId(parent);

        this.options = options;

        this.resizing = null;
        if (options.resizable == null)
            options.resizable = true;

        var tbody = scil.Utils.createTable(parent, 0, 0, { width: "100%" });
        var tr = scil.Utils.createElement(tbody, "tr");

        if (options.left == false) {
            this.left = null;
            this.middle = null;
        }
        else {
            var w = options.leftwidth > 0 ? options.leftwidth : 200;
            var td = scil.Utils.createElement(tr, "td", null, { width: "1%", paddingRight: "1px" }, { vAlign: "top" });
            var tbody2 = scil.Utils.createTable(td, 0, 0, options.resizable ? null : { width: w });
            var tr2 = scil.Utils.createElement(tbody2, "tr");
            var td2 = scil.Utils.createElement(tr2, "td");
            this.left = scil.Utils.createElement(td2, "div", null, options.resizable ? { width: w, overflow: "hidden"} : null);

            if (options.middle != false) {
                this.middle = scil.Utils.createElement(tr, "td");
                var div = scil.Utils.createElement(this.middle, "div", null, { width: scil.Page.kHandleWidth });
                scil.Utils.unselectable(this.middle);
                scil.Utils.unselectable(div);
            }

            if (options.resizable) {
                var me = this;
                new scil.Resizable(this.middle, { direction: "x", mouseovercolor: scil.Page.kHandleColor, onresize: function (delta) { return me.onresize(delta); } });
            }
        }

        this.right = options.right == false ? null : scil.Utils.createElement(tr, "td", null, { width: "99%", paddingLeft: options.left == false ? null : "1px" }, { vAlign: "top" });
    },

    onresize: function (delta) {
        var w = scil.Utils.parsePixel(this.left.style.width) + delta;
        if (w > 20) {
            this.left.style.width = w + "px";
            if (this.options.onresize != null)
                this.options.onresize(w, this);
            return true;
        }
        return false;
    }
});

﻿//////////////////////////////////////////////////////////////////////////////////
//
// JSDraw
// Copyright (C) 2018 Scilligence Corporation
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////


scil.Page.ExplorerForm = scil.extend(scil._base, {
    constructor: function (parent, options) {
        this.options = options == null ? {} : options;

        if (typeof (parent) == "string")
            parent = scil.byId(parent);
        this.parent = parent;

        var tbody = scil.Utils.createTable(this.parent, 0, 0, { width: "100%", background: "#fff" });
        this.dom = this.root = tbody.parentNode;
        if (this.options.visible == false)
            this.root.style.display = "none";

        if (options.caption == null) {
            tbody.parentNode.style.borderTop = "solid 1px " + scil.Page.ExplorerForm.kHeaderStyle.background;
            this.title = null;
        }
        else {
            var s = scil.Lang.res(options.caption);
            if (options.icon != null)
                s = "<img src='" + options.icon + "'>" + s;
            this.title = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", s, scil.Page.ExplorerForm.kHeaderStyle);
        }
        this.toolbar = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", null, scil.Page.ExplorerForm.kToolbarStyle);
        if (options.toolbarvisible == false)
            this.toolbar.style.display = "none";
        this.toolbar.style.whiteSpace = "nowrap"; //I#11762

        this.main = scil.Utils.createElement(scil.Utils.createElement(tbody, "tr"), "td", null, scil.Page.ExplorerForm.kAreaStyle);
        this.div = scil.Utils.createElement(this.main, "div");
        this.table = tbody.parentNode;

        this.recreateToolbar(options.buttons);

        if (this.title != null && options.expandable != false) {
            var me = this;
            dojo.connect(this.title, "onclick", function () {
                var f = !me.isExpanded();
                me.expand(f);
                if (me.options.onexpandform != null)
                    me.options.onexpandform(f);
            });

            if (options.expanded == false)
                this.expand(false);
        }

        if (this.options.marginTop != null)
            this.table.style.marginTop = this.options.marginTop;
        this.table.style.marginBottom = this.options.marginBottom == null ? "25px" : this.options.marginBottom;
    },

    recreateToolbar: function (buttons) {
        scil.Utils.removeAll(this.toolbar);
        scil.Form.createToolbarButtons(this.toolbar, buttons, this.options.padding);
    },

    isVisible: function () {
        return scil.Utils.isAllParentVisible(this.root);
    },

    show: function () {
        if (this.isVisible())
            return;
        this.root.style.display = "";

        if (this.host != null && this.host.refresh != null && this.host.refreshneeded)
            this.host.refresh();
    },

    hide: function () {
        this.root.style.display = "none";
    },

    collapse: function () {
        this.expand(false);
    },

    expanded: true,
    expandedheight: null,
    expandedwidth: null,
    expand: function (f) {
        if (f == null)
            f = true;
        if (this.expanded == f)
            return;

        var dom = this.options.collapsedwidth > 0 ? this.parent : this.dom;
       if (this.expanded) {
            this.expandedheight = dom.offsetHeight;
            this.expandedwidth = dom.offsetWidth;
        }

        var me = this;
        if (this.options.collapsedwidth > 0)
            scil.Animation.expandXY(dom, f ? this.expandedwidth : this.options.collapsedwidth, f ? this.expandedheight : this.title.offsetHeight, function () { me.onexpanded(f); });
        else
            scil.Animation.expandY(dom, f ? this.expandedheight : this.title.offsetHeight, function () { me.onexpanded(f); });
        this.expanded = f;
    },

    onexpanded: function (f) {
        if (f) {
            var dom = this.options.collapsedwidth > 0 ? this.parent : this.dom;

            dom.style.maxHeight = "";
            dom.style.maxWidth = "";

            if (this.host != null && this.host.refresh != null && this.host.refreshneeded)
                this.host.refresh();
        }

        this.title.style.backgroundImage = scil.App.imgSmall(f ? "expand.png" : "collapse.png", true);
        this.title.style.backgroundRepeat = "no-repeat";
        this.title.style.backgroundPosition = "left center";
    },

    isExpanded: function () {
        return this.expanded;
    }
});


scil.apply(scil.Page.ExplorerForm, {
    kHeaderStyle: { background: "#88f", color: "white", padding: "3px 10px 3px 16px", whiteSpace: "nowrap", borderTopLeftRadius: "5px", borderTopRightRadius: "5px" },
    kToolbarStyle: { background: "#f5f5f5", border: "solid 1px #f5f5f5", padding: "0 5px 0 5px" },
    kAreaStyle: { border: "solid 1px #f5f5f5", padding: "5px" },

    cloneArgs: function (options, extra) {
        var ret = {
            toolbarvisible: options.toolbarvisible,
            expandable: options.expandable,
            caption: options.caption,
            visible: options.visible,
            marginTop: options.marginTop,
            marginBottom: options.marginBottom,
            expanded: options.expanded,
            onexpand: options.onexpand
        };

        if (extra != null)
            scil.apply(ret, extra);
        return ret;
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// Version 1.0.0.2013-11-06
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Page.Form class - Page.Form Control
* @class scilligence.Page.Form
* <pre>
* <b>Constructor Parameters:</b>
*    - alternativeforms:
*    - buttons: {array}
*    - caption: {string}
*    - expandable: {bool}
*    - editable: {bool}
*    - expanded: {bool}
*    - fields: {dict}
*    - hidelabel: {bool}
*    - marginBottom:  {int}
*    - marginTop: {int}
*    - norefresh: {bool}
*    - savedoc: {bool}
*    - viewonly: {bool}
*    - visible: {bool}
*    - onformchange: function(field, form, args), form field data changed event
*    - onexpandform: function(f)
*    - onbeforerefresh: function(params, edit)
*    - onsetdata: function(form, ret)
*    - onbeforesave: function(data, args, form), return false to cancel following operations
*    - onaftersave: function(ret, this)
*
* </pre>
*/
scil.Page.Form = scil.extend(scil._base, {
    constructor: function (page, options, parent) {
        var me = this;
        this.refreshneeded = true;
        this.page = page;
        this.options = options;
        this.receivers = [];

        var buttons = [];
        if (options.norefresh == false)
            buttons.push({ src: scil.App.imgSmall("refresh.png"), title: "Refresh", onclick: function () { me.refresh(); } });
        if (this.options.buttons != null)
            buttons = buttons.concat(this.options.buttons);
        if (options.editable)
            buttons.push({ src: scil.App.imgSmall("edit.png"), title: "Edit", onclick: function () { me.edit(); } });

        if (options.viewonly == null)
            options.viewonly = true;

        this.form = new scil.Page.ExplorerForm(parent, scil.Page.ExplorerForm.cloneArgs(this.options, { buttons: buttons }));
        this.form.host = this;
        this.table = new scil.Form({ alternativeforms: this.options.alternativeforms, viewonly: options.viewonly, onchange: this.options.onformchange });
        this.table.render(this.form.div, this.options.fields, { immediately: true, hidelabel: options.hidelabel });
    },

    show: function () {
        this.form.show();
    },

    hide: function () {
        this.form.hide();
    },

    refresh: function (from, args) {
        if (args != null)
            this.args = args;

        if (!this.form.isVisible() || !this.form.isExpanded()) {
            this.refreshneeded = true;
            return;
        }

        if (scil.Utils.isDictEmpty(this.args))
            return;

        this.load(this.table, false);
    },

    load: function (form, edit) {
        form.setData({});

        var me = this;
        this.refreshneeded = false;
        var params = this.args;
        if (params == null)
            params = {};
        if (me.options.onbeforerefresh != null)
            me.options.onbeforerefresh(params, edit);

        this.page.receiverClear(this);

        scil.Utils.ajax(this.page.url + this.options.object + ".load", function (ret) {
            if (ret == null || ret == "")
                ret = params;

            if (me.options.onsetdata != null) {
                me.options.onsetdata(form, ret);
            }
            else if (me.options.savedoc && ret.doc != null && ret.doc != "") {
                form.setXml(ret.doc);
                form.setData(ret, true);
            }
            else {
                form.setData(ret);
            }
        }, params);
    },

    clear: function () {
        this.table.setData({});
        this.page.receiverClear(this);
    },

    edit: function () {
        var me = this;
        if (this.dlg == null)
            this.dlg = scil.Form.createDlgForm(this.options.caption, this.options.fields, { label: "Save", onclick: function () { me.save(); } });
        this.dlg.show();
        this.load(this.dlg.form, true);
    },

    save: function () {
        if (this.dlg.form.checkRequiredFields() > 0) {
            scil.Utils.alert("Some required field(s) are blank");
            return;
        }

        var me = this;
        var data = this.dlg.form.getData();
        if (this.options.savedoc)
            data.doc = this.dlg.form.getXml();
        if (this.options.onbeforesave) {
            if (this.options.onbeforesave(data, this.args, this.dlg.form) == false)
                return false;
        }

        scil.Utils.ajax(this.page.url + this.options.object + ".save", function (ret) {
            me.dlg.hide();
            me.refresh();
            if (me.options.onaftersave)
                me.options.onaftersave(ret, me);
        }, data, { showprogress: true });
    }
});
﻿﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// Version 1.0.0.2013-11-06
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Page.Tab class - Page.Tab Control
* @class scilligence.Page.Tab
*/
scil.Page.Tab = scil.extend(scil._base, {
    constructor: function (page, options, parent) {
        this.page = page;
        this.options = options == null ? {} : options;
        this.onShowTab2 = this.options.onShowTab;

        var me = this;
        this.options.onShowTab = function (tab, old) {
            if (old != null && old.form != null)
                old.form.hide();
            if (tab.form != null)
                tab.form.show();

            if (me.onShowTab2 != null)
                me.onShowTab2(tab, old);
        };
        this.tabs = new scil.Tabs(parent, this.options);
    },

    addForm: function (options, listento) {
        var td = this.tabs.addTab(options);

        var caption = options.captions;
        options.caption = null;
        td.form = scil.Page.addForm(this.page, options, listento, td.clientarea);
        options.caption = caption;

        scil.Page.setBorder(td.form.form);
        return td.form;
    },

    removeTab: function(key) {
        return this.tabs.removeTab(key);
    },

    findTab: function(key) {
        return this.tabs.findTab(key);
    },

    showTab: function (td) {
        this.tabs.showTab(td);
    },

    show: function () {
        this.tabs.show();
    },

    hide: function () {
        this.tabs.hide();
    }
});﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// Version 1.0.0.2013-11-06
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Page.Table class - Page.Table Control
* @class scilligence.Page.Table
* <pre>
* <b>Constructor Parameters:</b>
*    - allowcopy: {bool}, show copy toolbar button
*    - buttons: {array}
*    - caption: {string}
*    - candelete: {bool}
*    - canadd: {bool}
*    - canedit: {bool}
*    - columnhidable: {bool}
*    - columns: {dict}
*    - defaultvalues: {dict}, editing form default values
*    - display: {string}
*    - displays: {dict}
*    - expandable: {bool}
*    - expanded: {bool}
*    - fields: {dict}, editing form fields
*    - formcaption: {string}
*    - key: {string}, ajax parameter key
*    - marginTop: {int}
*    - marginBottom: {int}
*    - name: {string}, ajax parameter name
*    - norefresh: {bool}
*    - object: {string}, ajax cmd namespace
*    - savedoc: editing form saved as xml doc for custom fields
*    - toolbarvisible: {bool}
*    - usetabs: {bool}, use tabbed form for editing
*    - visible: {bool}
*    - onexpandform: function(f)
*    - oncreatetable: function(this)
*    - onselectrow: function(tr, args)
*    - onloadpage: function(args, page, this)
*    - onbeforerefresh: function(params, selectfirstrow), return "cancel" to ignore refresh()
*    - onbeforelisting: function(ret, this)
*    - onrefreshed: function(this)
*    - onAddNew: function(args), return false to cancel following operations
*    - onshowform: function(dlg, args)
*    - onloaddata: function(data, args, dlg)
*    - onEdit: function(data), return false to cancel following operations
*    - onbeforesave: function(data, args, form), return false to cancel following operations
*    - onaftersave: function(ret, this)
* </pre>
*/
scil.Page.Table = scil.extend(scil._base, {
    constructor: function(page, options, parent) {
        var me = this;
        this.refreshneeded = true;
        this.page = page;
        this.options = options;
        this.receivers = [];

        var buttons = [];
        if (!options.norefresh)
            buttons.push({ src: scil.App.imgSmall("refresh.png"), title: "Refresh", onclick: function() { me.refresh(); } });
        if (this.options.fields != null) {
            buttons.push("-");
            if (this.options.canadd != false)
                buttons.push({ src: scil.App.imgSmall("add.png"), title: "New", onclick: function() { me.add(); } });
            if (this.options.canedit != false)
                buttons.push({ src: scil.App.imgSmall("edit.png"), title: "Edit", onclick: function() { me.edit(); } });
            if (this.options.allowcopy)
                buttons.push({ src: scil.App.imgSmall("copy.png"), title: "Copy", onclick: function() { me.edit(null, true); } });
        }
        if (this.options.buttons != null)
            buttons = buttons.concat(this.options.buttons);

        if (this.options.columnhidable) {
            buttons.push("-");
            buttons.push({ src: scil.App.imgSmall("columns.png"), title: "Show/Hide Columns", onclick: function() { me.table.showHideColumns(); } });
        }

        this.form = new scil.Page.ExplorerForm(parent, scil.Page.ExplorerForm.cloneArgs(this.options, { buttons: buttons }));
        this.form.host = this;
        this.form.main.style.padding = "0";
        this.pages = scil.Utils.createElement(this.form.div, "div");

        this.tablediv = scil.Utils.createElement(this.form.div, "div");
        if (this.options.display != null)
            this.switchView(this.options.display);
        this.recreateTable();

        this.msg = scil.Utils.createElement(this.form.div, "div");
    },

    addSubform: function (options, margin) {
        if (margin > 0)
            this.form.dom.style.marginBottom = margin + "px";
        scil.Page.addForm(this.page, options, this, this.form.dom.parentNode);
    },

    recreateTable: function () {
        scil.Utils.removeAll(this.tablediv);

        var me = this;
        var args = scil.clone(this.options);
        args.selectrow = true;
        args.onselectrow = function (tr) { me.selectrow(tr); };

        if (this.options.type == "block") {
            this.table = new scil.CardView(args);
            this.table.render(this.tablediv, this.options.columns);
        }
        else if (this.options.type == "column") {
            this.table = new scil.CardView(args);
            this.table.render(this.tablediv, this.options.columns);
        }
        else {
            this.table = new scil.Table(true, null, args);
            this.table.render(this.tablediv, this.options.columns);
            this.table.tbody.parentNode.style.width = "100%";
        }

        this.recreateneeded = false;
        if (this.options.oncreatetable != null)
            this.options.oncreatetable(this);
    },

    switchView: function(display) {
        if (display == this.display)
            return false;

        var args = this.options.displays[display];
        if (args == null)
            return false;

        if (this.options.rowcheck && this.table != null)
            this.selectedkeys = this.table.getCheckedKeys();

        this.display = display;
        scil.apply(this.options, args);
        this.setRecreate();
        return true;
    },
    
    selectFirstRow: function () {
        this.table.selectFirstRow();
    },

    show: function () {
        this.form.show();
    },

    hide: function () {
        this.form.hide();
    },

    clear: function () {
        scil.Utils.removeAll(this.pages);
        scil.Utils.removeAll(this.msg);
        this.table.setData({});
        this.page.receiverClear(this);
    },

    selectrow: function (tr) {
        var id = tr == null ? null : tr.getAttribute("key");
        var args = null;
        /*if (id != null)*/
        {
            args = {};
            args[this.options.key] = id;
            var data = this.table.getRowData(tr);
            if (this.options.name != null && data != null)
                args[this.options.name] = data[this.options.name];
            this.page.receiverRefresh(this, args);
        }

        if (this.options.onselectrow != null)
            this.options.onselectrow(tr, args);
    },

    loadPage: function (page) {
        if (this.args == null)
            this.args = {};
        if (this.options.onloadpage != null)
            this.options.onloadpage(this.args, page, this);
        this.refresh(null, null, null, page);
    },

    setRecreate: function () {
        this.recreateneeded = true;
    },

    list: function (ret) {
        if (this.recreateneeded)
            this.recreateTable();

        var me = this;
        if (ret == null)
            ret = {};

        var list = ret.rows == null ? ret : ret.rows;
        this.table.setData(list);

        scil.Table.listPages(this.pages, ret.page, ret.pages, function (page) { me.loadPage(page); });
        if (list == null || list.length == 0)
            this.msg.innerHTML = "<div style='color:red;padding:5px;'>" + scil.Lang.res("No Records Found") + "</div>";
        else
            scil.Utils.removeAll(this.msg);
    },

    refresh: function (from, args, selectfirstrow, page) {
        if (args != null)
            this.args = args;
        if (this.args == null)
            this.args = {};
        this.args.page = page;

        if (!this.form.isVisible() || !this.form.isExpanded()) {
            this.refreshneeded = true;
            return;
        }

        this.page.receiverClear(this);
        this.refreshneeded = false;

        var params = this.args;
        if (params == null)
            params = {};
        if (this.options.onbeforerefresh == null || this.options.onbeforerefresh(params, selectfirstrow) != "cancel")
            this.refresh2(params, selectfirstrow);
    },

    refresh2: function (params, selectfirstrow) {
        var me = this;
        var fun = this.options.jsonp ? scil.Utils.jsonp : scil.Utils.ajax;
        fun(this.page.url + this.options.object + ".list", function (ret) { me.refresh3(ret, selectfirstrow); }, params);
    },

    refresh3: function (ret, selectfirstrow) {
        if (this.options.onbeforelisting != null)
            this.options.onbeforelisting(ret, this);

        if (selectfirstrow) {
            this.list(ret);
            this.table.selectFirstRow();
        }
        else {
            var key = this.table.getCurrentKey();
            this.list(ret);
            if (key != null)
                this.table.selectRow(key);
        }
        //if (ret.length == 0)
        //    scil.Utils.alert("No records found.  It might because you don't have access to it.");
        if (this.options.onrefreshed != null)
            this.options.onrefreshed(this);

        if (this.selectedkeys != null) {
            this.table.checkRows(this.selectedkeys);
            this.selectedkeys = null; // use only once
        }
    },

    add: function (values) {
        if (this.options.onAddNew != null && this.options.onAddNew(this.args) == false)
            return;

        this.add2(values, "create");
    },

    add2: function (values, action) {
        this.create();
        this.dlg.show();
        if (this.options.usetabs)
            this.dlg.form.tabs.showTab(0);

        if (this.options.onshowform != null)
            this.options.onshowform(this.dlg, this.args, action);
        var data = values != null ? values : (this.options.defaultvalues == null ? {} : this.options.defaultvalues);
        this.applyArgs(data);
        if (this.options.key != null)
            data[this.options.key] = null;
        if (this.options.onloaddata)
            this.options.onloaddata(data, this.args, this.dlg);
        this.dlg.form.setData(data);
        this.dlg.editkey = null;

        this.setButtons(action);
    },

    copyNew: function (key) {
        if (key == null) {
            for (var k in this.options.fields) {
                if (this.options.fields[k].iskey) {
                    key = k;
                    break;
                }
            }
        }
        if (key == null)
            return;

        var me = this;
        this.edit(function (ret) { ret[key] = " "; me.dlg.editkey = null; }, true);
    },

    edit: function (onsetdata, copying) {
        if (this.table.currow == null) {
            scil.Utils.alert("please select a row first");
            return;
        }

        this.add2(null, copying ? "copy" : "save");

        var me = this;
        var data = {};
        data[this.options.key] = this.table.currow.getAttribute("key");
        this.dlg.editkey = copying ? null : data[this.options.key];

        if (!copying && this.options.onEdit != null && this.options.onEdit(data) == false)
            return;

        scil.Utils.ajax(this.page.url + this.options.object + ".load", function (ret) {
            //me.applyArgs(ret);
            if (me.options.onloaddata)
                me.options.onloaddata(ret, me.args, me.dlg, copying);

            if (onsetdata != null)
                onsetdata(ret, me);

            me.dlg.__copying = copying;
            if (me.options.savedoc && ret.doc != null && ret.doc != "") {
                me.dlg.form.setXml(ret.doc);
                me.dlg.form.setData(ret, true);
            }
            else {
                me.dlg.form.setData(ret);
            }
        }, data);
    },

    applyArgs: function (data) {
        if (this.args != null)
            scil.apply(data, this.args);
    },

    cancel: function () {
        if (this.dlg != null)
            this.dlg.hide();
    },

    save: function () {
        if (this.dlg.form.checkRequiredFields() > 0) {
            scil.Utils.alert("Some required field(s) are blank");
            return;
        }

        var me = this;
        var data = this.dlg.form.getData();
        if (this.options.savedoc)
            data.doc = this.dlg.form.getXml();
        if (this.options.onbeforesave) {
            if (this.options.onbeforesave(data, this.args, this.dlg.form) == false)
                return false;
        }

        data.__copying = this.dlg.__copying;

        scil.Utils.ajax(this.page.url + this.options.object + ".save", function (ret) {
            me.dlg.hide();
            if (ret != null && ret.rows != null && ret.rows.length > 0) {
                for (var i = 0; i < ret.rows.length; ++i) {
                    if (me.dlg.editkey != null)
                        me.table.updateRow(me.dlg.editkey, ret.rows[i]);
                    else
                        me.table.addRow(ret.rows[i]);
                }
            }
            else {
                me.refresh();
            }

            if (me.options.onaftersave)
                me.options.onaftersave(ret, me);
        }, data, { showprogress: true });
    },

    del: function () {
        var me = this;
        scil.Utils.confirmYes("Delete this record?", function () {
            var data = me.dlg.form.getData();
            scil.Utils.ajax(me.page.url + me.options.object + ".del", function (ret) {
                me.dlg.hide();
                me.refresh();
            }, data);
        });
    },

    setButtons: function (action) {
        if (this.dlg == null)
            return;

        for (var i = 0; i < this.dlg.form.buttons.length; ++i) {
            var b = this.dlg.form.buttons[i];
            if (b == null)
                continue;

            var key = b.getAttribute("key");
            if (key == "delete")
                b.style.display = action == "save" ? "" : "none";
            else if (key == "save")
                b.style.display = action != "copy" ? "" : "none";
            else if (key == "copy")
                b.style.display = action == "copy" ? "" : "none";
        }
    },

    create: function () {
        if (this.dlg != null)
            return;

        var me = this;
        var buttons = [{ src: scil.App.imgSmall("submit.png"), label: "Save", key: "save", onclick: function () { me.save(); } }];
        if (this.options.allowcopy) {
            buttons.push(" ");
            buttons.push({ src: scil.App.imgSmall("copy.png"), label: "Copy", key: "copy", onclick: function () { me.save(); } });
        }
        if (this.options.candelete != false) {
            buttons.push(" ");
            buttons.push({ src: scil.App.imgSmall("del.png"), label: "Delete", key: "delete", onclick: function () { me.del(); } });
        }
        buttons.push(" ");
        buttons.push({ src: scil.App.imgSmall("cancel.png"), label: "Cancel", key: "cancel", onclick: function () { me.cancel(); } });
        if (this.options.editbuttons != null) {
            if (this.options.editbuttons.length == null)
                buttons.push(this.options.editbuttons);
            else
                buttons = buttons.concat(this.options.editbuttons);
        }

        if (this.options.usetabs) {
            this.dlg = scil.Form.createTabDlgForm(this.options.formcaption, { tabs: this.options.fields, buttons: buttons, border: true, onchange: this.options.onformdatachange });
        }
        else {
            this.dlg = scil.Form.createDlgForm(this.options.formcaption, this.options.fields, buttons,
                { alternativeforms: this.options.alternativeforms, hidelabel: this.options.hidelabel, oncreated: this.options.oncreateform, onchange: this.options.onformdatachange });
        }
    }
});




﻿//////////////////////////////////////////////////////////////////////////////////
//
// Scilligence JSDraw
// Copyright (C) 2018 Scilligence Corporation
// Version 1.0.0.2013-11-06
// http://www.scilligence.com/
//
//////////////////////////////////////////////////////////////////////////////////

/**
* Page.Tree class - Page.Tree Control
* @class scilligence.Page.Tree
* <pre>
* <b>Constructor Parameters:</b>
*    - buttons: {array}
*    - caption: {string}
*    - defaultvalues: {dict}, editing form default values
*    - expandable: {bool}
*    - expanded: {bool}
*    - fields: {dict}, editing form fields
*    - formcaption: {string}
*    - key: {string}, ajax parameter key
*    - marginTop: {int}
*    - marginBottom: {int}
*    - name: {string}, ajax parameter name
*    - object: {string}, ajax cmd namespace
*    - root: {dict}
*    - startrefresh: {bool}, default to true
*    - toolbarvisible: {bool}
*    - visible: {bool}
*    - onrender: function(parent, args)
*    - onexpand: function(node, f)
*    - onexpandform: function(f)
*    - onselectitem: function(node)
*    - onBuildArgs: function(node), return dict
*    - onshowform: function(dlg)
*    - onloaddata: function(ret)
*    - onbeforesave: function(data, sel)
*    - onSaved: function(this, data)
*    - oncreateform: function(form)
* </pre>
*/
scil.Page.Tree = scil.extend(scil._base, {
    constructor: function (page, options, parent) {
        var me = this;
        this.refreshneeded = true;
        this.page = page;
        this.options = options == null ? {} : options;
        this.receivers = [];

        var buttons = [];
        if (this.options.onrender == null) {
            buttons.push({ src: scil.App.imgSmall("refresh.png"), title: "Refresh", onclick: function () { me.refresh(); } });
            if (this.options.fields != null) {
                buttons.push("-", { src: scil.App.imgSmall("add.png"), title: "New", onclick: function () { me.add(); } });
                buttons.push({ src: scil.App.imgSmall("edit.png"), title: "Edit", onclick: function () { me.edit(); } });
            }
        }
        if (this.options.buttons != null)
            buttons = buttons.concat(this.options.buttons);

        var args = this.options.object == null ? null : { dropdown: this.options.dropdown, url: this.page.url + this.options.object + ".tree", icongap: "3px", onAddItem: this.options.onAddItem };
        this.form = new scil.Page.ExplorerForm(parent, scil.Page.ExplorerForm.cloneArgs(options, { buttons: buttons, collapsedwidth: 20 }));
        this.form.host = this;
        if (this.options.onrender != null) {
            this.options.onrender(this.form.div, args);
        }
        else {
            this.tree = new scil.Tree(this.form.div, args);
            this.tree.onSelectItem = function (item) { me.select(item); };
            this.tree.onExpandItem = function (node, f) { if (me.options.onexpand != null) return me.options.onexpand(node, f); };

            if (this.options.startrefresh != false)
                this.refresh();
        }

        this.form.main.style.padding = 0;
        scil.Page.setBorder(this.form);
    },

    show: function () {
        this.form.show();
    },

    hide: function () {
        this.form.hide();
    },

    select: function (node) {
        if (this.options.onselectitem != null) {
            if (this.options.onselectitem(node))
                return;
        }

        var args = {};
        if (this.options.onBuildArgs != null) {
            args = this.options.onBuildArgs(node);
        }
        else {
            if (node != null && node.item != null && node.item[this.options.key] != null)
                args = scil.clone(node.item);
        }

        this.page.receiverRefresh(this, args);
    },

    refresh: function (currentOnly) {
        if (!this.form.isVisible()) {
            this.refreshneeded = true;
            return;
        }

        if (this.tree == null)
            return;

        if (currentOnly) {
            this.tree.reloadCur();
            return;
        }

        this.refreshneeded = false;
        this.tree.clear();
        if (this.options.root != null) {
            if (this.options.root.selectable == null)
                this.options.root.selectable = false;
            if (this.options.root.showroot == false && this.options.root.children != null) {
                for (var i = 0; i < this.options.root.children.length; ++i)
                    this.tree.cur = this.tree.add(null, this.options.root.children[i]);
            }
            else {
                this.tree.cur = this.tree.add(null, this.options.root);
            }
        }
        if (this.options.object != null && this.options.object != "")
            this.tree.reloadCur();
    },

    applyArgs: function (data) {
        if (this.args != null)
            scil.apply(data, this.args);
    },

    add: function () {
        this.create();
        this.dlg.show();
        if (this.options.onshowform != null)
            this.options.onshowform(this.dlg);

        this.dlg.form.setData(this.options.defaultvalues == null ? {} : this.options.defaultvalues);
    },

    edit: function () {
        this.add();

        var data = {};
        data[this.options.key] = this.tree.cur == null || this.tree.cur.item == null ? null : this.tree.cur.item[this.options.key];
        if (data[this.options.key] != null) {
            var me = this;
            scil.Utils.ajax(this.page.url + this.options.object + ".load", function (ret) {
                if (me.options.onloaddata)
                    me.options.onloaddata(ret);
                me.dlg.form.setData(ret);
            }, data);
        }
    },

    save: function () {
        var me = this;
        var data = this.dlg.form.getData();
        if (this.options.onbeforesave) {
            var sel = {};
            sel[this.options.key] = this.tree.cur == null || this.tree.cur.item == null ? null : this.tree.cur.item[this.options.key];
            if (this.options.onbeforesave(data, sel) == false)
                return false;
        }
        scil.Utils.ajax(this.page.url + this.options.object + ".save", function () {
            me.dlg.hide();
            if (me.options.onSaved != null)
                me.options.onSaved(me, data);
            else
                me.refresh(true);
        }, data);
    },

    del: function () {
        var me = this;
        var data = this.dlg.form.getData();
        scil.Utils.ajax(this.page.url + this.options.object + ".del", function () { me.dlg.hide(); me.refresh(); }, data);
    },

    create: function () {
        if (this.dlg != null)
            return;

        var me = this;
        var buttons = [{ src: scil.App.imgSmall("submit.png"), label: "Save", onclick: function () { me.save(); } },
            { src: scil.App.imgSmall("del.png"), label: "Delete", onclick: function () { me.del(); } }];
        this.dlg = scil.Form.createDlgForm(this.options.formcaption, this.options.fields, buttons);
        if (this.options.oncreateform != null)
            this.options.oncreateform(this.dlg.form);
    }
});